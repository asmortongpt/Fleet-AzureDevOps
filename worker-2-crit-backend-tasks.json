[
  {
    "source": "backend",
    "sheet": "Architecture_N_Config",
    "row": 2,
    "key_metric": "TypeScript Config",
    "scope": "Application Level",
    "module_component": "api/tsconfig.json",
    "finding": "- need to modif two properties\n- \"strict\": true, \"noEmitOnError\": true,",
    "severity": "Critical",
    "impact": "- Disables all strict type checking\n   - No null/undefined checks\n   - No implicit any checks\n   - No strict function types\n- Compiles even with errors\n   - Allows broken code to be deployed",
    "solution": "- \"compilerOptions\": {\n    \"strict\": true,                    // Enable all strict checks\n    \"noEmitOnError\": true,             // Don't compile with errors\n    \"noUnusedLocals\": true,            // Catch unused variables\n    \"noUnusedParameters\": true,        // Catch unused parameters\n    \"noImplicitReturns\": true,         // Ensure all code paths return\n    \"noFallthroughCasesInSwitch\": true // Catch switch fallthrough\n  }",
    "notes": "nan",
    "hours": "12",
    "completion_pct": "nan",
    "status": "nan",
    "next_steps": "nan"
  },
  {
    "source": "backend",
    "sheet": "Architecture_N_Config",
    "row": 4,
    "key_metric": "Inconsistent Error Handling",
    "scope": "Application Level",
    "module_component": "nan",
    "finding": "- inconsistent error handling\n- most are try catch, some are zod validation based \n- we don't expose actual error to end users . we should only send generic error messages if are environment is not development \n1. **No custom error classes** - All errors treated the same\n2. **Inconsistent error responses** - Different formats across routes\n3. **Poor error logging** - Mix of console.error and logger\n4. **No error codes** - Can't distinguish error types programmatically\ntry {\n  // ... business logic\n  res.json(result)\n} catch (error) {\n\n\ntry {\n  const validated = schema.parse(req.body)\n  // ... business logic\n}\n",
    "severity": "Critical",
    "impact": "- need to implement error hierarchy with app level errors\n- Update Routes to Use Custom Errors\n\nError (built-in)\n   \u2514\u2500\u2500 AppError (base custom error)\n       \u251c\u2500\u2500 ValidationError (400)\n       \u251c\u2500\u2500 UnauthorizedError (401)\n       \u251c\u2500\u2500 Forbidden Error (403)\n       \u251c\u2500\u2500 NotFoundError (404)\n       \u251c\u2500\u2500 ConflictError (409)\n       \u2514\u2500\u2500 InternalError (500)\n\n- return res.status(500).json({\n    error: 'Internal Server Error',\n    code: 'INTERNAL_ERROR',\n    ...(process.env.NODE_ENV === 'development' && {\n      message: err.message,\n      stack: err.stack\n    })\n  })",
    "solution": "nan",
    "notes": "nan",
    "hours": "40",
    "completion_pct": "nan",
    "status": "nan",
    "next_steps": "nan"
  },
  {
    "source": "backend",
    "sheet": "Architecture_N_Config",
    "row": 8,
    "key_metric": "Need to add Eslint security config ",
    "scope": "Application Level",
    "module_component": "nan",
    "finding": "1. **Hardcoded secrets** not detected (API keys, passwords, tokens)\n2. **Unsafe regex** patterns not caught (ReDoS vulnerabilities)\n3. **Eval usage** not prevented\n4. **Unsafe object access** not detected\n5. **SQL injection patterns** not caught",
    "severity": "Critical",
    "impact": "- Install Security Plugins\n- Add Pre-Commit Hooks",
    "solution": "nan",
    "notes": "nan",
    "hours": "already covered",
    "completion_pct": "nan",
    "status": "nan",
    "next_steps": "nan"
  },
  {
    "source": "backend",
    "sheet": "Architecture_N_Config",
    "row": 10,
    "key_metric": "No Service Layer Abstraction",
    "scope": "Application Level",
    "module_component": "nan",
    "finding": "nan",
    "severity": "Critical",
    "impact": "- **Three-Layer Architecture**:\n```\nController (Route Handler)\n    \u2193\nService Layer (Business Logic)\n    \u2193\nRepository Layer (Data Access)",
    "solution": "nan",
    "notes": "nan",
    "hours": "already covered",
    "completion_pct": "nan",
    "status": "nan",
    "next_steps": "nan"
  },
  {
    "source": "backend",
    "sheet": "Security_N_Authentication",
    "row": 4,
    "key_metric": "Default JWT secret",
    "scope": "Application Level",
    "module_component": "nan",
    "finding": "try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'changeme') as any\n    req.user = decoded\n    next()\n  } catch (error) {\n    return res.status(401).json({ error: 'Invalid or expired token' })\n  }",
    "severity": "Critical",
    "impact": "- changeme comparison should never be used in production\n- also using any effectively bypassing type checking for this specific variable. This is often used when the exact structure of the decoded payload is not known at compile time or when dealing with dynamic data",
    "solution": "nan",
    "notes": "nan",
    "hours": "already covered",
    "completion_pct": "nan",
    "status": "nan",
    "next_steps": "nan"
  }
]