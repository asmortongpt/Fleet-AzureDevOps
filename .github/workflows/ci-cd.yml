name: Fleet Management CI/CD Pipeline

on:
  push:
    branches: [main, develop, stage-*]
  pull_request:
    branches: [main, develop]

env:
  NODE_VERSION: '20.x'
  ACR_NAME: 'fleetacr'
  AKS_CLUSTER: 'fleet-aks-cluster'
  AKS_RESOURCE_GROUP: 'fleet-management-rg'
  NAMESPACE: 'fleet-management'
  PRODUCTION_URL: 'https://fleet.capitaltechalliance.com'

jobs:
  # ===========================================================================
  # LINT & TYPE CHECK
  # ===========================================================================
  lint:
    name: Lint & Type Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install frontend dependencies
        run: npm install

      - name: Install API dependencies
        run: cd api && npm install

      - name: ESLint - Frontend
        run: npm run lint

      - name: ESLint - API
        run: cd api && npm run lint

      - name: TypeScript - Frontend
        run: npx tsc --noEmit

      - name: TypeScript - API
        run: cd api && npx tsc --noEmit

  # ===========================================================================
  # UNIT TESTS
  # ===========================================================================
  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install frontend dependencies
        run: npm install

      - name: Install API dependencies
        run: cd api && npm install

      - name: Run frontend tests
        run: npm test

      - name: Run API tests
        run: cd api && npm test

      - name: Generate coverage report
        run: cd api && npm run test:coverage

      - name: Check test coverage threshold
        run: |
          cd api
          COVERAGE=$(node -pe "require('./coverage/coverage-summary.json').total.lines.pct")
          echo "Current coverage: ${COVERAGE}%"
          if (( $(echo "$COVERAGE < 60" | bc -l) )); then
            echo "Coverage is below 60% threshold"
            exit 1
          fi

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./api/coverage/coverage-final.json
          flags: api
          fail_ci_if_error: true

  # ===========================================================================
  # BUILD VERIFICATION
  # ===========================================================================
  build:
    name: Build Verification
    runs-on: ubuntu-latest
    needs: [lint]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm install

      - name: Build frontend
        run: npm run build

      - name: Build API
        run: cd api && npm run build

      - name: Upload frontend artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: dist/

      - name: Upload API artifacts
        uses: actions/upload-artifact@v4
        with:
          name: api-dist
          path: api/dist/

  # ===========================================================================
  # DOCKER BUILD & PUSH (Main branch only)
  # ===========================================================================
  docker:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.ACR_NAME }}.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Extract metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.ACR_NAME }}.azurecr.io/fleet-api
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push API image
        id: docker-build-api
        uses: docker/build-push-action@v5
        with:
          context: ./api
          file: ./api/Dockerfile.production
          push: true
          tags: |
            ${{ env.ACR_NAME }}.azurecr.io/fleet-api:${{ github.sha }}
            ${{ env.ACR_NAME }}.azurecr.io/fleet-api:latest
          cache-from: type=registry,ref=${{ env.ACR_NAME }}.azurecr.io/fleet-api:buildcache
          cache-to: type=registry,ref=${{ env.ACR_NAME }}.azurecr.io/fleet-api:buildcache,mode=max

      - name: Build and push Frontend image
        id: docker-build-frontend
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.production
          push: true
          tags: |
            ${{ env.ACR_NAME }}.azurecr.io/fleet-frontend:${{ github.sha }}
            ${{ env.ACR_NAME }}.azurecr.io/fleet-frontend:latest
          cache-from: type=registry,ref=${{ env.ACR_NAME }}.azurecr.io/fleet-frontend:buildcache
          cache-to: type=registry,ref=${{ env.ACR_NAME }}.azurecr.io/fleet-frontend:buildcache,mode=max

      - name: Generate SBOM with Syft
        run: |
          # Install Syft
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

          # Generate SBOM for API image
          syft ${{ env.ACR_NAME }}.azurecr.io/fleet-api:${{ github.sha }} \
            -o spdx-json=sbom-api.spdx.json \
            -o cyclonedx-json=sbom-api.cyclonedx.json

          # Generate SBOM for Frontend image
          syft ${{ env.ACR_NAME }}.azurecr.io/fleet-frontend:${{ github.sha }} \
            -o spdx-json=sbom-frontend.spdx.json \
            -o cyclonedx-json=sbom-frontend.cyclonedx.json

      - name: Upload SBOM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sbom-reports
          path: |
            sbom-api.spdx.json
            sbom-api.cyclonedx.json
            sbom-frontend.spdx.json
            sbom-frontend.cyclonedx.json
          retention-days: 90

  # ===========================================================================
  # SECURITY SCANNING
  # ===========================================================================
  security:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: [docker]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Semgrep SAST
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/secrets
            p/owasp-top-ten
            p/javascript
            p/typescript
        env:
          SEMGREP_RULES: auto

      - name: Install Trivy
        run: |
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install trivy

      - name: Run Trivy vulnerability scanner - Frontend
        run: |
          trivy image \
            --severity CRITICAL,HIGH \
            --exit-code 1 \
            --no-progress \
            --format sarif \
            --output trivy-frontend-results.sarif \
            ${{ env.ACR_NAME }}.azurecr.io/fleet-frontend:${{ github.sha }}

      - name: Run Trivy vulnerability scanner - API
        run: |
          trivy image \
            --severity CRITICAL,HIGH \
            --exit-code 1 \
            --no-progress \
            --format sarif \
            --output trivy-api-results.sarif \
            ${{ env.ACR_NAME }}.azurecr.io/fleet-api:${{ github.sha }}

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: '.'

      - name: Run npm audit - Frontend
        run: |
          npm audit --audit-level=high --production
        continue-on-error: false

      - name: Run npm audit - API
        run: |
          cd api
          npm audit --audit-level=high --production
        continue-on-error: false

      - name: Scan for secrets with detect-secrets
        run: |
          pip install detect-secrets
          detect-secrets scan --baseline .secrets.baseline
          if [ $? -ne 0 ]; then
            echo "Secrets detected in code!"
            exit 1
          fi

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Sign container images
        run: |
          cosign sign --yes \
            ${{ env.ACR_NAME }}.azurecr.io/fleet-frontend:${{ github.sha }}
          cosign sign --yes \
            ${{ env.ACR_NAME }}.azurecr.io/fleet-api:${{ github.sha }}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Upload security scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-scan-results
          path: |
            trivy-frontend-results.sarif
            trivy-api-results.sarif
            semgrep-results.json

  # ===========================================================================
  # DEPLOY TO KUBERNETES (Main branch only)
  # ===========================================================================
  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [docker, security]
    if: github.ref == 'refs/heads/main'
    environment: production
    outputs:
      previous-api-image: ${{ steps.save-state.outputs.previous-api-image }}
      previous-frontend-image: ${{ steps.save-state.outputs.previous-frontend-image }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER }}

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update secrets with runtime config
        run: |
          kubectl create secret generic fleet-secrets \
            --from-literal=database-url="${{ secrets.DATABASE_URL }}" \
            --from-literal=jwt-secret="${{ secrets.JWT_SECRET }}" \
            --from-literal=azure-maps-key="${{ secrets.AZURE_MAPS_SUBSCRIPTION_KEY }}" \
            --from-literal=openai-api-key="${{ secrets.OPENAI_API_KEY }}" \
            --from-literal=anthropic-api-key="${{ secrets.ANTHROPIC_API_KEY }}" \
            --namespace ${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Save current deployment state for rollback
        id: save-state
        run: |
          # Get current image tags
          API_IMAGE=$(kubectl get deployment fleet-api -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.template.spec.containers[0].image}' || echo "")
          FRONTEND_IMAGE=$(kubectl get deployment fleet-frontend -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.template.spec.containers[0].image}' || echo "")

          echo "previous-api-image=${API_IMAGE}" >> $GITHUB_OUTPUT
          echo "previous-frontend-image=${FRONTEND_IMAGE}" >> $GITHUB_OUTPUT

          echo "Previous API image: ${API_IMAGE}"
          echo "Previous Frontend image: ${FRONTEND_IMAGE}"

      - name: Update API deployment image
        id: deploy-api
        run: |
          kubectl set image deployment/fleet-api \
            fleet-api=${{ env.ACR_NAME }}.azurecr.io/fleet-api:${{ github.sha }} \
            -n ${{ env.NAMESPACE }}

      - name: Update Frontend deployment image
        id: deploy-frontend
        run: |
          kubectl set image deployment/fleet-frontend \
            fleet-frontend=${{ env.ACR_NAME }}.azurecr.io/fleet-frontend:${{ github.sha }} \
            -n ${{ env.NAMESPACE }}

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/fleet-api -n ${{ env.NAMESPACE }} --timeout=5m
          kubectl rollout status deployment/fleet-frontend -n ${{ env.NAMESPACE }} --timeout=5m

      - name: Verify deployment
        run: |
          kubectl get pods -n ${{ env.NAMESPACE }}
          kubectl get services -n ${{ env.NAMESPACE }}

  # ===========================================================================
  # SMOKE TESTS (Post-deployment)
  # ===========================================================================
  smoke-test:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for services to be ready
        run: sleep 30

      - name: Health check - API
        id: health-api
        run: |
          curl --fail ${{ env.PRODUCTION_URL }}/api/health || exit 1

      - name: Health check - Frontend
        id: health-frontend
        run: |
          curl --fail ${{ env.PRODUCTION_URL }}/ || exit 1

      - name: Test authentication endpoint
        id: test-auth
        run: |
          curl --fail -X POST ${{ env.PRODUCTION_URL }}/api/auth/login \
            -H "Content-Type: application/json" \
            -d '{"email":"test@example.com","password":"wrong"}' || exit 1

  # ===========================================================================
  # ROLLBACK (On smoke test failure)
  # ===========================================================================
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    needs: [deploy, smoke-test]
    if: failure() && needs.deploy.result == 'success'
    environment: production
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER }}

      - name: Rollback to previous deployment
        run: |
          echo "Rolling back deployment due to smoke test failure..."

          # Rollback API deployment
          if [ -n "${{ needs.deploy.outputs.previous-api-image }}" ]; then
            echo "Rolling back API to: ${{ needs.deploy.outputs.previous-api-image }}"
            kubectl set image deployment/fleet-api \
              fleet-api=${{ needs.deploy.outputs.previous-api-image }} \
              -n ${{ env.NAMESPACE }}
            kubectl rollout status deployment/fleet-api -n ${{ env.NAMESPACE }} --timeout=3m
          else
            echo "No previous API image found, using kubectl rollout undo"
            kubectl rollout undo deployment/fleet-api -n ${{ env.NAMESPACE }}
            kubectl rollout status deployment/fleet-api -n ${{ env.NAMESPACE }} --timeout=3m
          fi

          # Rollback Frontend deployment
          if [ -n "${{ needs.deploy.outputs.previous-frontend-image }}" ]; then
            echo "Rolling back Frontend to: ${{ needs.deploy.outputs.previous-frontend-image }}"
            kubectl set image deployment/fleet-frontend \
              fleet-frontend=${{ needs.deploy.outputs.previous-frontend-image }} \
              -n ${{ env.NAMESPACE }}
            kubectl rollout status deployment/fleet-frontend -n ${{ env.NAMESPACE }} --timeout=3m
          else
            echo "No previous Frontend image found, using kubectl rollout undo"
            kubectl rollout undo deployment/fleet-frontend -n ${{ env.NAMESPACE }}
            kubectl rollout status deployment/fleet-frontend -n ${{ env.NAMESPACE }} --timeout=3m
          fi

      - name: Verify rollback
        run: |
          echo "Verifying rollback..."
          kubectl get pods -n ${{ env.NAMESPACE }}

          # Test health endpoints after rollback
          sleep 30
          curl --fail ${{ env.PRODUCTION_URL }}/api/health && echo "API health check passed after rollback"
          curl --fail ${{ env.PRODUCTION_URL }}/ && echo "Frontend health check passed after rollback"

      - name: Send rollback notification
        if: always()
        run: |
          echo "ROLLBACK EXECUTED: Deployment was rolled back due to smoke test failure."
          echo "Check logs at ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

  # ===========================================================================
  # NOTIFICATION (On failure)
  # ===========================================================================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [deploy, smoke-test, rollback]
    if: failure()
    steps:
      - name: Send failure notification
        run: |
          echo "Deployment failed! Check logs at ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          if [ "${{ needs.rollback.result }}" == "success" ]; then
            echo "Note: Automatic rollback was executed successfully."
          elif [ "${{ needs.rollback.result }}" == "failure" ]; then
            echo "WARNING: Automatic rollback failed! Manual intervention required!"
          fi
