#!/usr/bin/env python3
"""
GitHub Automation for Spider Certification
Handles parallel PR creation, tracking, and CI/CD integration
"""

import os
import subprocess
import json
from typing import Dict, List, Optional, Tuple
from datetime import datetime
import hashlib

# ============================================================================
# Configuration
# ============================================================================

REPO_PATH = '/Users/andrewmorton/Documents/GitHub/Fleet-CTA'
MAIN_BRANCH = 'main'
REMOTE_AZURE = 'origin'
REMOTE_GITHUB = 'github'

# ============================================================================
# Git Operations
# ============================================================================

class GitAutomation:
    """Handles Git operations for parallel PR workflows"""

    def __init__(self, repo_path: str = REPO_PATH):
        self.repo_path = repo_path
        self.current_branch = None

    def run_git(self, *args) -> Tuple[bool, str]:
        """Execute a git command"""
        try:
            result = subprocess.run(
                ['git', '-C', self.repo_path] + list(args),
                capture_output=True,
                text=True,
                check=True
            )
            return True, result.stdout.strip()
        except subprocess.CalledProcessError as e:
            return False, e.stderr.strip()

    def get_current_branch(self) -> str:
        """Get current branch name"""
        success, output = self.run_git('branch', '--show-current')
        return output if success else 'unknown'

    def ensure_clean_state(self) -> bool:
        """Ensure working directory is clean"""
        success, output = self.run_git('status', '--porcelain')
        if success and output:
            print(f"‚ö†Ô∏è  Working directory has uncommitted changes:")
            print(output)
            return False
        return True

    def pull_latest(self, remote: str = REMOTE_AZURE, branch: str = MAIN_BRANCH) -> bool:
        """Pull latest changes from remote"""
        print(f"üì• Pulling latest from {remote}/{branch}...")
        success, output = self.run_git('pull', remote, branch)
        if success:
            print(f"‚úÖ Pulled latest changes")
            return True
        else:
            print(f"‚ùå Pull failed: {output}")
            return False

    def create_feature_branch(self, branch_name: str, base_branch: str = MAIN_BRANCH) -> bool:
        """Create a new feature branch"""
        # Ensure we're on base branch
        success, _ = self.run_git('checkout', base_branch)
        if not success:
            print(f"‚ùå Failed to checkout {base_branch}")
            return False

        # Pull latest
        if not self.pull_latest(REMOTE_AZURE, base_branch):
            return False

        # Create and checkout new branch
        success, output = self.run_git('checkout', '-b', branch_name)
        if success:
            print(f"‚úÖ Created feature branch: {branch_name}")
            self.current_branch = branch_name
            return True
        else:
            print(f"‚ùå Branch creation failed: {output}")
            return False

    def stage_files(self, files: List[str]) -> bool:
        """Stage specific files for commit"""
        success, output = self.run_git('add', *files)
        if success:
            print(f"‚úÖ Staged {len(files)} file(s)")
            return True
        else:
            print(f"‚ùå Staging failed: {output}")
            return False

    def commit(self, message: str) -> bool:
        """Create a commit"""
        commit_msg = f"{message}\n\nü§ñ Generated by Spider Certification\nCo-Authored-By: Claude <noreply@anthropic.com>"

        success, output = self.run_git('commit', '-m', commit_msg)
        if success:
            print(f"‚úÖ Committed: {message}")
            return True
        else:
            print(f"‚ùå Commit failed: {output}")
            return False

    def push_branch(self, remote: str = REMOTE_AZURE, branch: str = None) -> bool:
        """Push branch to remote"""
        branch = branch or self.current_branch
        if not branch:
            print("‚ùå No branch specified")
            return False

        success, output = self.run_git('push', '-u', remote, branch)
        if success:
            print(f"‚úÖ Pushed {branch} to {remote}")
            return True
        else:
            print(f"‚ùå Push failed: {output}")
            return False

    def push_to_all_remotes(self, branch: str = None) -> Dict[str, bool]:
        """Push to all configured remotes"""
        branch = branch or self.current_branch
        results = {}

        for remote in [REMOTE_AZURE, REMOTE_GITHUB]:
            print(f"\nüì§ Pushing to {remote}...")
            results[remote] = self.push_branch(remote, branch)

        return results

# ============================================================================
# GitHub/Azure DevOps PR Creation
# ============================================================================

class PRAutomation:
    """Handles pull request creation and tracking"""

    def __init__(self, git: GitAutomation):
        self.git = git

    def create_pr_azure(self, branch: str, title: str, description: str) -> Optional[str]:
        """Create PR in Azure DevOps using az CLI"""
        try:
            cmd = [
                'az', 'repos', 'pr', 'create',
                '--source-branch', branch,
                '--target-branch', MAIN_BRANCH,
                '--title', title,
                '--description', description,
                '--auto-complete', 'false',
                '--output', 'json'
            ]

            result = subprocess.run(
                cmd,
                cwd=self.git.repo_path,
                capture_output=True,
                text=True,
                check=True
            )

            pr_data = json.loads(result.stdout)
            pr_url = pr_data.get('url')
            print(f"‚úÖ Azure DevOps PR created: {pr_url}")
            return pr_url

        except subprocess.CalledProcessError as e:
            print(f"‚ùå Azure PR creation failed: {e.stderr}")
            return None
        except Exception as e:
            print(f"‚ùå Azure PR error: {e}")
            return None

    def create_pr_github(self, branch: str, title: str, description: str) -> Optional[str]:
        """Create PR in GitHub using gh CLI"""
        try:
            cmd = [
                'gh', 'pr', 'create',
                '--head', branch,
                '--base', MAIN_BRANCH,
                '--title', title,
                '--body', description
            ]

            result = subprocess.run(
                cmd,
                cwd=self.git.repo_path,
                capture_output=True,
                text=True,
                check=True
            )

            pr_url = result.stdout.strip()
            print(f"‚úÖ GitHub PR created: {pr_url}")
            return pr_url

        except subprocess.CalledProcessError as e:
            print(f"‚ùå GitHub PR creation failed: {e.stderr}")
            return None
        except Exception as e:
            print(f"‚ùå GitHub PR error: {e}")
            return None

    def create_pr_both(self, branch: str, title: str, description: str) -> Dict[str, Optional[str]]:
        """Create PRs in both Azure and GitHub"""
        results = {
            'azure': self.create_pr_azure(branch, title, description),
            'github': self.create_pr_github(branch, title, description)
        }
        return results

# ============================================================================
# Parallel Workflow Manager
# ============================================================================

class ParallelWorkflowManager:
    """Manages parallel agent workflows with Git branches"""

    def __init__(self):
        self.git = GitAutomation()
        self.pr = PRAutomation(self.git)
        self.active_workflows = {}

    def generate_branch_name(self, agent_type: str, task_id: str) -> str:
        """Generate unique branch name for agent work"""
        # Use first 8 chars of task_id as unique identifier
        short_id = task_id[:8]
        timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')
        return f"spider-cert/{agent_type}/{short_id}-{timestamp}"

    def start_workflow(self, agent_id: str, agent_type: str, task_id: str,
                      task_description: str) -> Dict:
        """Start a new parallel workflow for an agent"""

        print(f"\nüîÄ Starting workflow for {agent_type} agent")
        print(f"   Task ID: {task_id}")

        workflow = {
            'agent_id': agent_id,
            'agent_type': agent_type,
            'task_id': task_id,
            'description': task_description,
            'branch': None,
            'commits': [],
            'pr_urls': {},
            'status': 'started',
            'created_at': datetime.now().isoformat()
        }

        # Create feature branch
        branch_name = self.generate_branch_name(agent_type, task_id)
        if self.git.create_feature_branch(branch_name):
            workflow['branch'] = branch_name
            workflow['status'] = 'branch_created'
        else:
            workflow['status'] = 'failed'
            return workflow

        self.active_workflows[task_id] = workflow
        print(f"‚úÖ Workflow started on branch: {branch_name}\n")

        return workflow

    def commit_work(self, task_id: str, files_changed: List[str], commit_message: str) -> bool:
        """Commit agent's work"""

        if task_id not in self.active_workflows:
            print(f"‚ùå No active workflow for task {task_id}")
            return False

        workflow = self.active_workflows[task_id]

        # Stage files
        if not self.git.stage_files(files_changed):
            return False

        # Commit
        if not self.git.commit(commit_message):
            return False

        # Track commit
        success, commit_sha = self.git.run_git('rev-parse', 'HEAD')
        if success:
            workflow['commits'].append({
                'sha': commit_sha,
                'message': commit_message,
                'files': files_changed,
                'timestamp': datetime.now().isoformat()
            })

        workflow['status'] = 'committed'
        return True

    def push_and_create_pr(self, task_id: str, pr_title: str, pr_description: str) -> Dict:
        """Push branch and create PRs"""

        if task_id not in self.active_workflows:
            print(f"‚ùå No active workflow for task {task_id}")
            return {}

        workflow = self.active_workflows[task_id]
        branch = workflow['branch']

        # Push to all remotes
        push_results = self.git.push_to_all_remotes(branch)

        if not all(push_results.values()):
            print("‚ö†Ô∏è  Some pushes failed")
            workflow['status'] = 'push_failed'
            return workflow

        # Create PRs
        pr_urls = self.pr.create_pr_both(branch, pr_title, pr_description)
        workflow['pr_urls'] = pr_urls
        workflow['status'] = 'pr_created'

        print(f"\n‚úÖ Workflow complete:")
        print(f"   Branch: {branch}")
        print(f"   Commits: {len(workflow['commits'])}")
        if pr_urls.get('azure'):
            print(f"   Azure PR: {pr_urls['azure']}")
        if pr_urls.get('github'):
            print(f"   GitHub PR: {pr_urls['github']}")

        return workflow

    def cleanup_workflow(self, task_id: str):
        """Cleanup and return to main branch"""
        if task_id in self.active_workflows:
            del self.active_workflows[task_id]

        self.git.run_git('checkout', MAIN_BRANCH)
        print(f"‚úÖ Returned to {MAIN_BRANCH}")

# ============================================================================
# Workflow Persistence (Database Integration)
# ============================================================================

class WorkflowPersistence:
    """Persist workflow state to orchestration database"""

    def __init__(self, db_manager):
        self.db = db_manager

    def save_workflow(self, task_id: str, workflow: Dict):
        """Save workflow metadata to database"""
        query = """
        UPDATE tasks
        SET output_data = output_data || %s
        WHERE task_id = %s
        """
        workflow_data = {
            'git_workflow': workflow
        }
        self.db.execute(query, (json.dumps(workflow_data), task_id))

    def save_pr_url(self, task_id: str, remote: str, pr_url: str):
        """Save PR URL to remediation_actions table"""
        query = """
        UPDATE remediation_actions
        SET github_pr_url = %s
        WHERE remediation_task_id = %s
        """
        self.db.execute(query, (pr_url, task_id))

    def record_commit(self, task_id: str, commit_sha: str, files_changed: List[str]):
        """Record commit in remediation_actions"""
        query = """
        UPDATE remediation_actions
        SET commit_sha = %s, files_changed = %s
        WHERE remediation_task_id = %s
        """
        self.db.execute(query, (commit_sha, files_changed, task_id))

# ============================================================================
# Example Usage
# ============================================================================

def example_parallel_workflow():
    """Demonstrate parallel workflow management"""

    manager = ParallelWorkflowManager()

    # Simulate 3 parallel agent workflows
    agents = [
        ('agent-001', 'remediation', 'task-abc-123', 'Fix authentication bug'),
        ('agent-002', 'remediation', 'task-def-456', 'Update API schema validation'),
        ('agent-003', 'remediation', 'task-ghi-789', 'Improve error handling')
    ]

    workflows = []

    for agent_id, agent_type, task_id, description in agents:
        # Start workflow
        workflow = manager.start_workflow(agent_id, agent_type, task_id, description)
        workflows.append(workflow)

        # Simulate some file changes
        files = [f"src/fix-{task_id[:8]}.ts"]

        # Commit work
        if manager.commit_work(task_id, files, f"fix: {description}"):
            # Create PR
            pr_title = f"Spider Cert: {description}"
            pr_body = f"""## Automated Remediation

Task ID: {task_id}
Agent: {agent_type}

### Changes
{description}

### Evidence
See spider certification report for full evidence trail.

ü§ñ Generated by Spider Certification System
"""
            manager.push_and_create_pr(task_id, pr_title, pr_body)

        # Cleanup
        manager.cleanup_workflow(task_id)

    print(f"\n‚úÖ Completed {len(workflows)} parallel workflows")

if __name__ == '__main__':
    print("=" * 80)
    print("üîÄ GitHub Automation for Spider Certification")
    print("=" * 80)
    print()

    example_parallel_workflow()
