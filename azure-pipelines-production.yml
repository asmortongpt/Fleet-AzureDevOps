# ============================================================================
# Fleet Management System - Production Deployment Pipeline
# ============================================================================
# This pipeline deploys the Fleet application to production using existing
# AKS cluster: fleet-aks-cluster in fleet-production-rg
# ACR: fleetappregistry.azurecr.io
# ============================================================================

trigger:
  branches:
    include:
      - main
  paths:
    exclude:
      - '*.md'
      - 'docs/**'
      - '.github/**'

pr: none  # Production deployments are manual only

variables:
  # Azure Resources (existing)
  containerRegistry: 'fleetappregistry.azurecr.io'
  acrName: 'fleetappregistry'
  imageRepository: 'fleet-app'

  # AKS Configuration (existing)
  aksResourceGroup: 'fleet-production-rg'
  aksClusterName: 'fleet-aks-cluster'
  productionNamespace: 'fleet-management'

  # Service Connections (to be created in Azure DevOps)
  azureServiceConnection: 'Azure-Production-Connection'
  containerRegistryConnection: 'FleetACR-Connection'

  # Build Configuration
  buildId: '$(Build.BuildId)'
  imageTag: '$(Build.BuildId)'

  # Security
  DOCKER_BUILDKIT: 1

stages:
  # ==========================================================================
  # Stage 1: Build Docker Image
  # ==========================================================================
  - stage: Build
    displayName: 'Build Application'
    jobs:
      - job: BuildAndPush
        displayName: 'Build and Push Docker Image'
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - checkout: self
            fetchDepth: 0
            clean: true

          - task: Bash@3
            displayName: 'Display Build Info'
            inputs:
              targetType: 'inline'
              script: |
                echo "================================================"
                echo "Fleet Production Build"
                echo "================================================"
                echo "Build ID: $(Build.BuildId)"
                echo "Branch: $(Build.SourceBranchName)"
                echo "Commit: $(Build.SourceVersion)"
                echo "Image: $(containerRegistry)/$(imageRepository):$(imageTag)"
                echo "================================================"

          # Login to ACR
          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: login
              containerRegistry: $(containerRegistryConnection)

          # Build Docker Image
          - task: Docker@2
            displayName: 'Build Docker Image'
            inputs:
              command: build
              repository: $(imageRepository)
              dockerfile: '$(Build.SourcesDirectory)/Dockerfile'
              containerRegistry: $(containerRegistryConnection)
              tags: |
                $(imageTag)
                latest
                production-$(imageTag)
              arguments: |
                --build-arg NODE_ENV=production
                --build-arg BUILD_VERSION=$(imageTag)
                --build-arg GIT_COMMIT=$(Build.SourceVersion)

          # Security Scan
          - task: Bash@3
            displayName: 'Security Scan'
            inputs:
              targetType: 'inline'
              script: |
                echo "Installing Trivy scanner..."
                curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

                echo "Scanning image for vulnerabilities..."
                trivy image --severity HIGH,CRITICAL \
                  --exit-code 0 \
                  --format json \
                  --output $(Build.ArtifactStagingDirectory)/trivy-report.json \
                  $(containerRegistry)/$(imageRepository):$(imageTag)

                echo "Security scan completed"

          # Push to ACR
          - task: Docker@2
            displayName: 'Push to ACR'
            inputs:
              command: push
              repository: $(imageRepository)
              containerRegistry: $(containerRegistryConnection)
              tags: |
                $(imageTag)
                latest
                production-$(imageTag)

          # Publish Artifacts
          - task: PublishBuildArtifacts@1
            displayName: 'Publish Security Report'
            inputs:
              pathToPublish: '$(Build.ArtifactStagingDirectory)'
              artifactName: 'security-reports'

  # ==========================================================================
  # Stage 2: Deploy to Production
  # ==========================================================================
  - stage: DeployProduction
    displayName: 'Deploy to Production'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - deployment: DeployToProduction
        displayName: 'Deploy to AKS Production'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'fleet-production'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                # Install kubectl
                - task: KubectlInstaller@0
                  displayName: 'Install kubectl'
                  inputs:
                    kubectlVersion: 'latest'

                # Get AKS credentials
                - task: AzureCLI@2
                  displayName: 'Connect to AKS'
                  inputs:
                    azureSubscription: $(azureServiceConnection)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Connecting to AKS cluster..."
                      az aks get-credentials \
                        --resource-group $(aksResourceGroup) \
                        --name $(aksClusterName) \
                        --overwrite-existing

                      echo "Verifying connection..."
                      kubectl cluster-info
                      kubectl get nodes

                # Update deployment image
                - task: Kubernetes@1
                  displayName: 'Update Deployment'
                  inputs:
                    connectionType: 'Azure Resource Manager'
                    azureSubscriptionEndpoint: $(azureServiceConnection)
                    azureResourceGroup: $(aksResourceGroup)
                    kubernetesCluster: $(aksClusterName)
                    namespace: $(productionNamespace)
                    command: 'set'
                    arguments: 'image deployment/fleet-app fleet-app=$(containerRegistry)/$(imageRepository):$(imageTag)'

                # Wait for rollout
                - task: Kubernetes@1
                  displayName: 'Wait for Rollout'
                  inputs:
                    connectionType: 'Azure Resource Manager'
                    azureSubscriptionEndpoint: $(azureServiceConnection)
                    azureResourceGroup: $(aksResourceGroup)
                    kubernetesCluster: $(aksClusterName)
                    namespace: $(productionNamespace)
                    command: 'rollout'
                    arguments: 'status deployment/fleet-app --timeout=10m'

                # Verify deployment
                - task: Bash@3
                  displayName: 'Verify Deployment'
                  inputs:
                    targetType: 'inline'
                    script: |
                      echo "Verifying deployment health..."

                      # Get deployment status
                      kubectl get deployment fleet-app -n $(productionNamespace)

                      # Check pod status
                      kubectl get pods -n $(productionNamespace) -l app=fleet-app

                      # Wait for pods to be ready
                      kubectl wait --for=condition=ready pod \
                        -l app=fleet-app \
                        -n $(productionNamespace) \
                        --timeout=300s

                      # Verify replicas
                      DESIRED=$(kubectl get deployment fleet-app -n $(productionNamespace) -o jsonpath='{.spec.replicas}')
                      READY=$(kubectl get deployment fleet-app -n $(productionNamespace) -o jsonpath='{.status.readyReplicas}')

                      if [ "$DESIRED" != "$READY" ]; then
                        echo "❌ Deployment unhealthy: $READY/$DESIRED pods ready"
                        exit 1
                      fi

                      echo "✅ Deployment successful: $READY/$DESIRED pods ready"

                # Get service info
                - task: Bash@3
                  displayName: 'Display Service Info'
                  inputs:
                    targetType: 'inline'
                    script: |
                      echo "================================================"
                      echo "Production Deployment Complete"
                      echo "================================================"
                      echo "Namespace: $(productionNamespace)"
                      echo "Image: $(containerRegistry)/$(imageRepository):$(imageTag)"
                      echo ""
                      echo "Services:"
                      kubectl get services -n $(productionNamespace)
                      echo ""
                      echo "Ingress:"
                      kubectl get ingress -n $(productionNamespace)
                      echo "================================================"

  # ==========================================================================
  # Stage 3: Health Check
  # ==========================================================================
  - stage: HealthCheck
    displayName: 'Post-Deployment Health Check'
    dependsOn: DeployProduction
    condition: succeeded()
    jobs:
      - job: HealthCheck
        displayName: 'Run Health Checks'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: Bash@3
            displayName: 'Wait for Stabilization'
            inputs:
              targetType: 'inline'
              script: |
                echo "Waiting 60 seconds for deployment to stabilize..."
                sleep 60

          - task: AzureCLI@2
            displayName: 'Run Health Checks'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Connecting to AKS..."
                az aks get-credentials \
                  --resource-group $(aksResourceGroup) \
                  --name $(aksClusterName) \
                  --overwrite-existing

                echo "Checking deployment health..."
                kubectl get deployment fleet-app -n $(productionNamespace)

                echo "Checking pod health..."
                kubectl get pods -n $(productionNamespace) -l app=fleet-app

                # Check if all pods are running
                NOT_RUNNING=$(kubectl get pods -n $(productionNamespace) -l app=fleet-app --field-selector=status.phase!=Running --no-headers 2>/dev/null | wc -l)

                if [ "$NOT_RUNNING" -gt 0 ]; then
                  echo "❌ $NOT_RUNNING pods are not running"
                  kubectl describe pods -n $(productionNamespace) -l app=fleet-app
                  exit 1
                fi

                echo "✅ All health checks passed"

  # ==========================================================================
  # Stage 4: Notification
  # ==========================================================================
  - stage: Notify
    displayName: 'Send Notification'
    dependsOn:
      - DeployProduction
      - HealthCheck
    condition: always()
    jobs:
      - job: SendNotification
        displayName: 'Notify Team'
        steps:
          - task: Bash@3
            displayName: 'Generate Summary'
            inputs:
              targetType: 'inline'
              script: |
                if [ "$(Agent.JobStatus)" == "Succeeded" ]; then
                  echo "✅ PRODUCTION DEPLOYMENT SUCCESSFUL"
                  echo "================================================"
                  echo "Build ID: $(Build.BuildId)"
                  echo "Image: $(containerRegistry)/$(imageRepository):$(imageTag)"
                  echo "Namespace: $(productionNamespace)"
                  echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
                  echo "================================================"
                else
                  echo "❌ PRODUCTION DEPLOYMENT FAILED"
                  echo "Please check the logs and investigate"
                fi
