/**
 * useReactiveSafetyComplianceData - Enterprise-grade safety & compliance data with real-time updates
 * Features comprehensive Zod validation, security measures, and optimized performance
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import DOMPurify from 'dompurify'
import { useState, useCallback, useMemo, useEffect } from 'react'
import { z } from 'zod'

import logger from '@/utils/logger';
import logger from '@/utils/logger';
const API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:3000/api'

// Enhanced Zod schemas with comprehensive validation
const SafetyIncidentSchema = z.object({
  id: z.string().uuid(),
  vehicleId: z.string().uuid(),
  driverId: z.string().uuid(),
  type: z.enum(['collision', 'near_miss', 'property_damage', 'injury', 'other']),
  severity: z.enum(['low', 'medium', 'high', 'critical']),
  status: z.enum(['open', 'investigating', 'resolved', 'closed']),
  description: z.string().min(1).max(500).transform(str => DOMPurify.sanitize(str)),
  reportedDate: z.string().datetime(),
  investigator: z.string().optional(),
  location: z.object({
    lat: z.number().min(-90).max(90),
    lng: z.number().min(-180).max(180),
    zone: z.string().min(1).max(50)
  }).optional(),
  rootCause: z.string().optional(),
  correctiveActions: z.array(z.string()).optional()
})

const SafetyInspectionSchema = z.object({
  id: z.string().uuid(),
  vehicleId: z.string().uuid(),
  type: z.enum(['dot_annual', 'dot_90day', 'dvir', 'osha', 'facility']),
  status: z.enum(['pending', 'scheduled', 'completed', 'failed']),
  inspector: z.string().min(1).max(100),
  scheduledDate: z.string().datetime(),
  completedDate: z.string().datetime().optional(),
  findings: z.array(z.string()).optional(),
  score: z.number().min(0).max(100).optional()
})

const CertificationSchema = z.object({
  id: z.string().uuid(),
  driverId: z.string().uuid(),
  type: z.enum(['cdl', 'medical_card', 'hazmat', 'safety_training', 'forklift', 'osha_10', 'osha_30', 'defensive_driving']),
  status: z.enum(['current', 'expiring_soon', 'expired']),
  issueDate: z.string().datetime(),
  expiryDate: z.string().datetime(),
  certificationNumber: z.string().min(1).max(50),
  renewalReminder: z.boolean().optional()
})

const ViolationSchema = z.object({
  id: z.string().uuid(),
  vehicleId: z.string().uuid().optional(),
  driverId: z.string().uuid().optional(),
  type: z.enum(['dot', 'osha', 'epa', 'ifta', 'fmcsa', 'other']),
  severity: z.enum(['minor', 'major', 'critical']),
  status: z.enum(['open', 'appealed', 'resolved', 'paid']),
  description: z.string().min(1).max(500).transform(str => DOMPurify.sanitize(str)),
  fineAmount: z.number().min(0).optional(),
  dateIssued: z.string().datetime(),
  dueDate: z.string().datetime().optional()
})

const OSHAMetricsSchema = z.object({
  trir: z.number().min(0), // Total Recordable Incident Rate
  dart: z.number().min(0), // Days Away, Restricted, or Transferred rate
  ltifr: z.number().min(0), // Lost Time Injury Frequency Rate
  safeDays: z.number().int().min(0),
  lastIncident: z.string().datetime().nullable(),
  yearToDateIncidents: z.number().int().min(0),
  industryAverage: z.object({
    trir: z.number(),
    dart: z.number(),
    ltifr: z.number()
  })
})

const RiskAssessmentSchema = z.object({
  id: z.string().uuid(),
  hazard: z.string().min(1).max(200),
  likelihood: z.number().min(1).max(5),
  severity: z.number().min(1).max(5),
  riskScore: z.number().min(1).max(25),
  controlMeasures: z.array(z.string()),
  status: z.enum(['identified', 'mitigated', 'accepted', 'monitoring']),
  reviewDate: z.string().datetime()
})

const SafetyTrainingSchema = z.object({
  id: z.string().uuid(),
  title: z.string().min(1).max(200),
  category: z.enum(['mandatory', 'recommended', 'specialized']),
  completionRate: z.number().min(0).max(100),
  dueDate: z.string().datetime().optional(),
  participants: z.array(z.object({
    id: z.string().uuid(),
    name: z.string(),
    completedDate: z.string().datetime().optional(),
    score: z.number().min(0).max(100).optional()
  }))
})

type SafetyIncident = z.infer<typeof SafetyIncidentSchema>
type SafetyInspection = z.infer<typeof SafetyInspectionSchema>
type Certification = z.infer<typeof CertificationSchema>
type Violation = z.infer<typeof ViolationSchema>
type OSHAMetrics = z.infer<typeof OSHAMetricsSchema>
type RiskAssessment = z.infer<typeof RiskAssessmentSchema>
type SafetyTraining = z.infer<typeof SafetyTrainingSchema>

// Security helper for XSS prevention
const sanitizeInput = (input: string): string => {
  return DOMPurify.sanitize(input, {
    ALLOWED_TAGS: [],
    ALLOWED_ATTR: []
  })
}

// Get CSRF token from meta tag
const getCSRFToken = (): string => {
  return document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''
}

export function useReactiveSafetyComplianceData() {
  const [realTimeUpdate, setRealTimeUpdate] = useState(0)
  const [wsConnection, setWsConnection] = useState<WebSocket | null>(null)
  const queryClient = useQueryClient()

  // Enhanced fetch with security headers
  const secureFetch = useCallback(async (endpoint: string, options?: RequestInit) => {
    const token = localStorage.getItem('authToken')
    const response = await fetch(`${API_BASE}${endpoint}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': token ? `Bearer ${token}` : '',
        'X-CSRF-Token': getCSRFToken(),
        'X-Requested-With': 'XMLHttpRequest',
        ...options?.headers
      }
    })

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    const data = await response.json()
    return data
  }, [])

  // Fetch safety incidents with validation
  const { data: incidents = [], isLoading: incidentsLoading } = useQuery<SafetyIncident[]>({
    queryKey: ['safety-incidents', realTimeUpdate],
    queryFn: async () => {
      const data = await secureFetch('/safety/incidents')
      return z.array(SafetyIncidentSchema).parse(data)
    },
    refetchInterval: 10000,
    staleTime: 5000,
  })

  // Fetch safety inspections with validation
  const { data: inspections = [], isLoading: inspectionsLoading } = useQuery<SafetyInspection[]>({
    queryKey: ['safety-inspections', realTimeUpdate],
    queryFn: async () => {
      const data = await secureFetch('/safety/inspections')
      return z.array(SafetyInspectionSchema).parse(data)
    },
    refetchInterval: 10000,
    staleTime: 5000,
  })

  // Fetch certifications with validation
  const { data: certifications = [], isLoading: certificationsLoading } = useQuery<Certification[]>({
    queryKey: ['certifications', realTimeUpdate],
    queryFn: async () => {
      const data = await secureFetch('/safety/certifications')
      return z.array(CertificationSchema).parse(data)
    },
    refetchInterval: 10000,
    staleTime: 5000,
  })

  // Fetch violations with validation
  const { data: violations = [], isLoading: violationsLoading } = useQuery<Violation[]>({
    queryKey: ['violations', realTimeUpdate],
    queryFn: async () => {
      const data = await secureFetch('/safety/violations')
      return z.array(ViolationSchema).parse(data)
    },
    refetchInterval: 10000,
    staleTime: 5000,
  })

  // Fetch OSHA metrics
  const { data: oshaMetrics } = useQuery<OSHAMetrics>({
    queryKey: ['osha-metrics', realTimeUpdate],
    queryFn: async () => {
      const data = await secureFetch('/safety/osha-metrics')
      return OSHAMetricsSchema.parse(data)
    },
    refetchInterval: 30000,
    staleTime: 15000,
  })

  // Fetch risk assessments
  const { data: riskAssessments = [] } = useQuery<RiskAssessment[]>({
    queryKey: ['risk-assessments', realTimeUpdate],
    queryFn: async () => {
      const data = await secureFetch('/safety/risk-assessments')
      return z.array(RiskAssessmentSchema).parse(data)
    },
    refetchInterval: 30000,
    staleTime: 15000,
  })

  // Fetch safety training
  const { data: trainings = [] } = useQuery<SafetyTraining[]>({
    queryKey: ['safety-training', realTimeUpdate],
    queryFn: async () => {
      const data = await secureFetch('/safety/training')
      return z.array(SafetyTrainingSchema).parse(data)
    },
    refetchInterval: 30000,
    staleTime: 15000,
  })

  // Memoized calculations for performance
  const openIncidents = useMemo(() =>
    incidents.filter((i) => i.status === 'open' || i.status === 'investigating'),
    [incidents]
  )

  const criticalIncidents = useMemo(() =>
    incidents.filter((i) => i.severity === 'critical' || i.severity === 'high'),
    [incidents]
  )

  // Days since last incident
  const daysSinceLastIncident = useMemo(() => {
    const sortedIncidents = [...incidents].sort((a, b) =>
      new Date(b.reportedDate).getTime() - new Date(a.reportedDate).getTime()
    )
    return sortedIncidents.length > 0
      ? Math.floor((Date.now() - new Date(sortedIncidents[0].reportedDate).getTime()) / (1000 * 60 * 60 * 24))
      : 999
  }, [incidents])

  // Active violations (defined early as it's used in complianceScore)
  const activeViolations = useMemo(() =>
    violations.filter((v) => v.status === 'open' || v.status === 'appealed'),
    [violations]
  )

  // Enhanced compliance score calculation
  const complianceScore = useMemo(() => {
    let score = 100
    const weights = {
      inspections: 0.25,
      certifications: 0.25,
      incidents: 0.2,
      training: 0.15,
      violations: 0.15
    }

    // Inspection compliance
    const passedInspections = inspections.filter(i => i.status === 'completed').length
    const inspectionScore = inspections.length > 0
      ? (passedInspections / inspections.length) * 100
      : 100
    score *= (inspectionScore / 100) * weights.inspections

    // Certification compliance
    const validCerts = certifications.filter(c => c.status === 'current').length
    const certScore = certifications.length > 0
      ? (validCerts / certifications.length) * 100
      : 100
    score *= (certScore / 100) * weights.certifications

    // Incident impact
    const incidentPenalty = Math.min(criticalIncidents.length * 5, 50)
    score -= incidentPenalty * weights.incidents

    // Training completion
    const avgTrainingCompletion = trainings.length > 0
      ? trainings.reduce((sum, t) => sum + t.completionRate, 0) / trainings.length
      : 100
    score *= (avgTrainingCompletion / 100) * weights.training

    // Violation impact
    const violationPenalty = Math.min(activeViolations.length * 10, 50)
    score -= violationPenalty * weights.violations

    return Math.max(0, Math.min(100, Math.round(score)))
  }, [inspections, certifications, incidents, trainings, activeViolations])

  // OSHA compliance calculation
  const oshaCompliance = useMemo(() => {
    const recordableInjuries = incidents.filter(
      i => i.type === 'injury' && i.severity !== 'low'
    ).length
    return recordableInjuries === 0 ? 100 : Math.max(0, 100 - (recordableInjuries * 10))
  }, [incidents])

  // Training completion
  const trainingCompletion = useMemo(() => {
    if (trainings.length === 0) return 0
    const totalCompletion = trainings.reduce((sum, t) => sum + t.completionRate, 0)
    return Math.round(totalCompletion / trainings.length)
  }, [trainings])

  // Certifications expiring soon (within 30 days)
  const expiringCertifications = useMemo(() =>
    certifications.filter((c) => {
      const daysUntilExpiry = Math.floor(
        (new Date(c.expiryDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24)
      )
      return daysUntilExpiry <= 30 && daysUntilExpiry > 0
    }),
    [certifications]
  )

  // Expired certifications
  const expiredCertifications = useMemo(() =>
    certifications.filter((c) => c.status === 'expired'),
    [certifications]
  )

  // Total fines
  const totalFines = useMemo(() =>
    violations.reduce((sum, v) => sum + (v.fineAmount || 0), 0),
    [violations]
  )

  // Comprehensive metrics object
  const metrics = useMemo(() => ({
    complianceScore,
    totalIncidents: incidents.length,
    openCases: openIncidents.length,
    trainingCompletion,
    daysSinceLastIncident,
    oshaCompliance,
    activeViolations: activeViolations.length,
    totalFines,
    criticalIncidents: criticalIncidents.length,
    pendingInspections: inspections.filter((i) => i.status === 'pending' || i.status === 'scheduled').length,
    expiringCertifications: expiringCertifications.length,
    expiredCertifications: expiredCertifications.length,
    trir: oshaMetrics?.trir || 0,
    dart: oshaMetrics?.dart || 0,
    ltifr: oshaMetrics?.ltifr || 0,
    safeDays: oshaMetrics?.safeDays || daysSinceLastIncident
  }), [
    complianceScore, incidents, openIncidents, trainingCompletion,
    daysSinceLastIncident, oshaCompliance, activeViolations, totalFines,
    criticalIncidents, inspections, expiringCertifications,
    expiredCertifications, oshaMetrics
  ])

  // Custom data for incident heat map visualization
  const getIncidentHeatMapData = useCallback(() => {
    const zoneMap = new Map<string, { count: number; severity: number }>()

    incidents.forEach(incident => {
      if (incident.location) {
        const zone = incident.location.zone
        const severityScore = {
          'low': 1,
          'medium': 2,
          'high': 3,
          'critical': 4
        }[incident.severity]

        if (zoneMap.has(zone)) {
          const current = zoneMap.get(zone)!
          current.count++
          current.severity = Math.max(current.severity, severityScore)
        } else {
          zoneMap.set(zone, { count: 1, severity: severityScore })
        }
      }
    })

    return Array.from(zoneMap.entries()).map(([zone, data]) => ({
      zone,
      count: data.count,
      severity: data.severity
    }))
  }, [incidents])

  // Custom data for risk matrix visualization
  const getRiskMatrixData = useCallback(() => {
    const matrix: { [key: string]: { count: number; risks: string[] } } = {}

    riskAssessments.forEach(risk => {
      const key = `${risk.likelihood}-${risk.severity}`
      if (matrix[key]) {
        matrix[key].count++
        matrix[key].risks.push(risk.hazard)
      } else {
        matrix[key] = { count: 1, risks: [risk.hazard] }
      }
    })

    // Generate full 5x5 matrix
    const fullMatrix = []
    for (let likelihood = 1; likelihood <= 5; likelihood++) {
      for (let severity = 1; severity <= 5; severity++) {
        const key = `${likelihood}-${severity}`
        fullMatrix.push({
          likelihood,
          severity,
          count: matrix[key]?.count || 0,
          risks: matrix[key]?.risks || [],
          riskScore: likelihood * severity
        })
      }
    }

    return fullMatrix
  }, [riskAssessments])

  // Custom data for certification wheel
  const getCertificationWheelData = useCallback(() => {
    const certTypes = [
      'cdl', 'medical_card', 'hazmat', 'safety_training',
      'forklift', 'osha_10', 'osha_30', 'defensive_driving'
    ]

    return certTypes.map(type => {
      const typeCerts = certifications.filter(c => c.type === type)
      const current = typeCerts.filter(c => c.status === 'current').length
      const expiring = typeCerts.filter(c => c.status === 'expiring_soon').length
      const expired = typeCerts.filter(c => c.status === 'expired').length
      const total = typeCerts.length

      return {
        type,
        current,
        expiring,
        expired,
        total,
        percentage: total > 0 ? Math.round((current / total) * 100) : 0
      }
    })
  }, [certifications])

  // Timeline data for safety events
  const getSafetyTimelineData = useCallback(() => {
    const events = [
      ...incidents.map(i => ({
        date: i.reportedDate,
        type: 'incident' as const,
        severity: i.severity,
        description: i.description
      })),
      ...inspections.map(i => ({
        date: i.scheduledDate,
        type: 'inspection' as const,
        status: i.status,
        description: `${i.type} inspection`
      })),
      ...violations.map(v => ({
        date: v.dateIssued,
        type: 'violation' as const,
        severity: v.severity,
        description: v.description
      }))
    ].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())

    return events.slice(0, 20) // Return last 20 events
  }, [incidents, inspections, violations])

  // Trend data for compliance score
  const getComplianceTrendData = useCallback(() => {
    // Generate mock trend data for last 12 months
    const months = []
    for (let i = 11; i >= 0; i--) {
      const date = new Date()
      date.setMonth(date.getMonth() - i)
      const monthName = date.toLocaleDateString('en-US', { month: 'short' })

      // Simulate historical scores with slight variations
      const baseScore = complianceScore
      const variation = Math.sin(i) * 10
      const score = Math.max(0, Math.min(100, baseScore + variation))

      months.push({
        month: monthName,
        score: Math.round(score),
        target: 90
      })
    }

    return months
  }, [complianceScore])

  // Department compliance data
  const getDepartmentComplianceData = useCallback(() => {
    const departments = ['Operations', 'Maintenance', 'Transportation', 'Warehouse', 'Administration']

    return departments.map(dept => {
      // Simulate department-specific scores
      const baseScore = complianceScore
      const variation = Math.random() * 20 - 10
      const score = Math.max(0, Math.min(100, baseScore + variation))

      return {
        department: dept,
        score: Math.round(score),
        openIssues: Math.floor(Math.random() * 5)
      }
    })
  }, [complianceScore])

  // Mutations for updating data
  const updateIncidentMutation = useMutation({
    mutationFn: async ({ id, data }: { id: string; data: Partial<SafetyIncident> }) => {
      const sanitizedId = sanitizeInput(id)
      const response = await secureFetch(`/safety/incidents/${sanitizedId}`, {
        method: 'PATCH',
        body: JSON.stringify(data)
      })
      return SafetyIncidentSchema.parse(response)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['safety-incidents'] })
    }
  })

  const addRiskAssessmentMutation = useMutation({
    mutationFn: async (assessment: Omit<RiskAssessment, 'id'>) => {
      const response = await secureFetch('/safety/risk-assessments', {
        method: 'POST',
        body: JSON.stringify(assessment)
      })
      return RiskAssessmentSchema.parse(response)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['risk-assessments'] })
    }
  })

  const scheduleTrainingMutation = useMutation({
    mutationFn: async (training: Omit<SafetyTraining, 'id'>) => {
      const response = await secureFetch('/safety/training', {
        method: 'POST',
        body: JSON.stringify(training)
      })
      return SafetyTrainingSchema.parse(response)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['safety-training'] })
    }
  })

  // WebSocket connection for real-time updates
  useEffect(() => {
    const token = localStorage.getItem('authToken')
    if (!token) return

    const wsUrl = `${API_BASE.replace('http', 'ws')}/ws/safety-compliance`
    const ws = new WebSocket(wsUrl)

    ws.onopen = () => {
      ws.send(JSON.stringify({ type: 'auth', token }))
      setWsConnection(ws)
    }

    ws.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data)

        if (message.type === 'incident-update' ||
            message.type === 'compliance-update' ||
            message.type === 'certification-update') {
          setRealTimeUpdate(prev => prev + 1) // Trigger refetch
        }
      } catch (error) {
        logger.error('WebSocket message error:', error)
      }
    }

    ws.onerror = (error) => {
      logger.error('WebSocket error:', error)
    }

    ws.onclose = () => {
      setWsConnection(null)
    }

    return () => {
      ws.close()
    }
  }, [])

  return {
    // Data
    incidents,
    inspections,
    certifications,
    violations,
    riskAssessments,
    trainings,
    oshaMetrics,
    metrics,

    // Filtered data
    openIncidents,
    criticalIncidents,
    expiringCertifications,
    expiredCertifications,
    activeViolations,

    // Visualization data
    getIncidentHeatMapData: useMemo(() => getIncidentHeatMapData, [getIncidentHeatMapData]),
    getRiskMatrixData: useMemo(() => getRiskMatrixData, [getRiskMatrixData]),
    getCertificationWheelData: useMemo(() => getCertificationWheelData, [getCertificationWheelData]),
    getSafetyTimelineData: useMemo(() => getSafetyTimelineData, [getSafetyTimelineData]),
    getComplianceTrendData: useMemo(() => getComplianceTrendData, [getComplianceTrendData]),
    getDepartmentComplianceData: useMemo(() => getDepartmentComplianceData, [getDepartmentComplianceData]),

    // Mutations
    updateIncident: updateIncidentMutation.mutate,
    addRiskAssessment: addRiskAssessmentMutation.mutate,
    scheduleTraining: scheduleTrainingMutation.mutate,

    // Status
    isLoading: incidentsLoading || inspectionsLoading || certificationsLoading || violationsLoading,
    lastUpdate: new Date(),
    refresh: () => setRealTimeUpdate((prev) => prev + 1),
    wsConnected: wsConnection !== null
  }
}
