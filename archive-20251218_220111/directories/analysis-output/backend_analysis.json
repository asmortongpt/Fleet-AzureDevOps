{
  "Architecture_N_Config": [
    {
      "Key Metric": "TypeScript Config",
      "Scope": "Application Level",
      "Module/Component": "api/tsconfig.json",
      "Finding": "- need to modif two properties\n- \"strict\": true, \"noEmitOnError\": true,",
      "Severity": "Critical",
      "Impact": "- Disables all strict type checking\n   - No null/undefined checks\n   - No implicit any checks\n   - No strict function types\n- Compiles even with errors\n   - Allows broken code to be deployed",
      "Probable Solution/Code Considerations": "- \"compilerOptions\": {\n    \"strict\": true,                    // Enable all strict checks\n    \"noEmitOnError\": true,             // Don't compile with errors\n    \"noUnusedLocals\": true,            // Catch unused variables\n    \"noUnusedParameters\": true,        // Catch unused parameters\n    \"noImplicitReturns\": true,         // Ensure all code paths return\n    \"noFallthroughCasesInSwitch\": true // Catch switch fallthrough\n  }",
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 12
    },
    {
      "Key Metric": "No Dependency Injection",
      "Scope": "Component Level",
      "Module/Component": NaN,
      "Finding": "- some classes have direct instantiation\nlet samsaraService: SamsaraService | null = null\ntry {\n  if (process.env.SAMSARA_API_TOKEN) {\n    samsaraService = new SamsaraService(pool)\n  }\n} catch (error: any) {\n  console.warn('\u26a0\ufe0f  Samsara service not initialized:', error.message)\n}\n\n\n\n\n- some have lazy instantation \nlet mobileDamageService: MobileDamageService | null = null\nlet visionService: OpenAIVisionService | null = null\n\nfunction getMobileDamageService(): MobileDamageService {\n  if (!mobileDamageService) {\n    mobileDamageService = new MobileDamageService()\n  }\n  return mobileDamageService\n}",
      "Severity": "High",
      "Impact": "- we can use dependency injection container\n\nimport { Container } from 'inversify'\nimport { VehiclesService } from './services/vehicles.service'\nimport { VehiclesRepository } from './repositories/vehicles.repository'\n\nconst container = new Container()\n\n// Bind repositories\ncontainer.bind<VehiclesRepository>('VehiclesRepository').to(VehiclesRepository).inSingletonScope()\n\n// Bind services\ncontainer.bind<VehiclesService>('VehiclesService').to(VehiclesService).inSingletonScope()\n",
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 40
    },
    {
      "Key Metric": "Inconsistent Error Handling",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- inconsistent error handling\n- most are try catch, some are zod validation based \n- we don't expose actual error to end users . we should only send generic error messages if are environment is not development \n1. **No custom error classes** - All errors treated the same\n2. **Inconsistent error responses** - Different formats across routes\n3. **Poor error logging** - Mix of console.error and logger\n4. **No error codes** - Can't distinguish error types programmatically\ntry {\n  // ... business logic\n  res.json(result)\n} catch (error) {\n\n\ntry {\n  const validated = schema.parse(req.body)\n  // ... business logic\n}\n",
      "Severity": "Critical",
      "Impact": "- need to implement error hierarchy with app level errors\n- Update Routes to Use Custom Errors\n\nError (built-in)\n   \u2514\u2500\u2500 AppError (base custom error)\n       \u251c\u2500\u2500 ValidationError (400)\n       \u251c\u2500\u2500 UnauthorizedError (401)\n       \u251c\u2500\u2500 Forbidden Error (403)\n       \u251c\u2500\u2500 NotFoundError (404)\n       \u251c\u2500\u2500 ConflictError (409)\n       \u2514\u2500\u2500 InternalError (500)\n\n- return res.status(500).json({\n    error: 'Internal Server Error',\n    code: 'INTERNAL_ERROR',\n    ...(process.env.NODE_ENV === 'development' && {\n      message: err.message,\n      stack: err.stack\n    })\n  })",
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 40
    },
    {
      "Key Metric": "Routes Structure",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "routes/\n  \u251c\u2500\u2500 vehicles.ts\n  \u251c\u2500\u2500 drivers.ts\n  \u251c\u2500\u2500 work-orders.ts",
      "Severity": "High",
      "Impact": "we should have domain based routes for better readability\n\nmodules/\n  \u251c\u2500\u2500 fleet/\n  \u2502   \u251c\u2500\u2500 vehicles.routes.ts\n  \u2502   \u251c\u2500\u2500 vehicles.service.ts\n  \u2502   \u251c\u2500\u2500 vehicles.repository.ts\n  \u2502   \u2514\u2500\u2500 vehicles.types.ts\n  \u251c\u2500\u2500 maintenance/\n  \u2502   \u251c\u2500\u2500 work-orders.routes.ts\n  \u2502   \u251c\u2500\u2500 work-orders.service.ts",
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 12
    },
    {
      "Key Metric": "Services not grouped by domain",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- flat structure",
      "Severity": "High",
      "Impact": "- need to group by domain ",
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 16
    },
    {
      "Key Metric": "Business logic, database query and other login  in routes",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "-  // ISSUE: Direct database query in route handler\n      const result = await pool.query(\n        `SELECT * FROM vehicles WHERE tenant_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3`,\n        [req.user!.tenant_id, limit, offset]\n      )\n\n\n\n- // : Data transformation in route handler\n      cost transformedData = result.rows.map((v: any) => ({\n        id: v.id,\n        tenantId: v.tenant_id,\n        number: v.license_plate || v.vin,\n        // ... 20+ lines of transformation logic\n      }))\n\n\n- lot of code duplicated like the pagination logic",
      "Severity": "High",
      "Impact": "- \"- **Three-Layer Architecture**:\n```\nController (Route Handler)\n    \u2193\nService Layer (Business Logic)\n    \u2193\nRepository Layer (Data Access)\" \n\n\n**Recommended Refactoring**:\n```typescript\n// routes/vehicles.routes.ts\nrouter.get(\n  '/',\n  authorize('admin', 'fleet_manager'),\n  auditLog({ action: 'READ', resourceType: 'vehicles' }),\n  async (req: AuthRequest, res: Response, next: NextFunction) => {\n    try {\n      const { page = 1, limit = 50 } = req.query\n      const result = await vehiclesService.getVehicles(\n        req.user!.tenant_id,\n        { page: Number(page), limit: Number(limit) }\n      )\n      res.json(result)\n    } catch (error) {\n      next(error) // Let global error handler deal with it\n    }\n  }\n)\n\n// services/vehicles.service.ts\nclass VehiclesService {\n  constructor(private vehiclesRepository: VehiclesRepository) {}\n\n  async getVehicles(tenantId: string, pagination: PaginationParams) {\n    const vehicles = await this.vehiclesRepository.findByTenant(tenantId, pagination)\n    const count = await this.vehiclesRepository.countByTenant(tenantId)\n\n    return {\n      data: vehicles.map(this.transformVehicle),\n      pagination: this.buildPaginationMeta(pagination, count)\n    }\n  }\n}\n\n// repositories/vehicles.repository.ts\nclass VehiclesRepository {\n  constructor(private db: Pool) {}\n\n  async findByTenant(tenantId: string, pagination: PaginationParams) {\n    const offset = (pagination.page - 1) * pagination.limit\n    const result = await this.db.query(\n      `SELECT * FROM vehicles WHERE tenant_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3`,\n      [tenantId, pagination.limit, offset]\n    )\n    return result.rows\n  }\n}\n",
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 120
    },
    {
      "Key Metric": "Need to add Eslint security config ",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "1. **Hardcoded secrets** not detected (API keys, passwords, tokens)\n2. **Unsafe regex** patterns not caught (ReDoS vulnerabilities)\n3. **Eval usage** not prevented\n4. **Unsafe object access** not detected\n5. **SQL injection patterns** not caught",
      "Severity": "Critical",
      "Impact": "- Install Security Plugins\n- Add Pre-Commit Hooks",
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": "already covered"
    },
    {
      "Key Metric": "Missing Global Error Middleware",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": NaN,
      "Severity": "High",
      "Impact": "- to be registered last in the middleware\n- Centralized error handling\n- Consistent error responses",
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 24
    },
    {
      "Key Metric": "No Service Layer Abstraction",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": NaN,
      "Severity": "Critical",
      "Impact": "- **Three-Layer Architecture**:\n```\nController (Route Handler)\n    \u2193\nService Layer (Business Logic)\n    \u2193\nRepository Layer (Data Access)",
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": "already covered"
    },
    {
      "Key Metric": "Identify ASYNC jobs ",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "-currently everything is fetched real time with user having to wait for the operation to finish . we have to identify api's that can be processed async and or in batch (like external tools call etc)",
      "Severity": "Medium",
      "Impact": NaN,
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": NaN
    },
    {
      "Key Metric": "Lack of Repository Pattern",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- missing basic repositry pattern design",
      "Severity": "High",
      "Impact": "Refactor to Repository Pattern\nCreate BaseRepository with tenant filtering\nMove database queries out of route handlers\nStandardize error handling",
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": "already covered"
    }
  ],
  "API_N_DataFetching": [
    {
      "Key Metric": "NO ORM",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- no orm configured",
      "Severity": "High",
      "Impact": "- maintainence cost is hgh \n- No abstraction layer for tenant filtering\n- Repetitive code across 60+ files\n- Risk of developer forgetting to add tenant filter in new queries",
      "Probable Solution/Code Considerations": "- use ORM tool like PRISMA",
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 120
    },
    {
      "Key Metric": "- query performance monitoring\n- pool performance monitoring",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- nothing configured as of now",
      "Severity": "High",
      "Impact": "- Can't identify slow queries\n- cant monitor connection pool stats",
      "Probable Solution/Code Considerations": "- we can at least start with  pg_stat_statements enabled",
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": NaN
    },
    {
      "Key Metric": "No proper response format",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- Multiple response formats across endpoints\n- checked for vehicles, login, telematic\n- some responses had data with pagination , some had raw object , some had raw data , some did not have proper status code returned ",
      "Severity": "High",
      "Impact": "- client code must handle multiple formats with no consistent interface",
      "Probable Solution/Code Considerations": "- Create type definitions, response utilities, error handler",
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 40
    },
    {
      "Key Metric": "Filtering logic duplication",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- code duplicated for filtration in all routes",
      "Severity": "High",
      "Impact": NaN,
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": "already covered"
    },
    {
      "Key Metric": "No API versioning ",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- app.use('/api/vehicles', vehicles Router)\n     app.use('/api/drivers', drivers Router)\n     app.use('/api/work-orders', work Orders Router)",
      "Severity": "Medium",
      "Impact": NaN,
      "Probable Solution/Code Considerations": "app.use('/api/v1/vehicles', vehicles Router)\n     app.use('/api/v1/drivers', drivers Router)\n     app.use('/api/v1/work-orders', work Orders Router)",
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": NaN
    },
    {
      "Key Metric": "Over Fetching (Select Queries)",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- Many routes use `SELECT *` instead of specific columns",
      "Severity": "Medium",
      "Impact": "Over-fetching data, increased memory usage",
      "Probable Solution/Code Considerations": "- Select only needed columns",
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": NaN
    },
    {
      "Key Metric": "using PATCH",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- we use PUT for all updates",
      "Severity": "Medium",
      "Impact": "- PUT requires full resource which is not needed for partial updates",
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": NaN
    }
  ],
  "Security_N_Authentication": [
    {
      "Key Metric": "Rate Limiting",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- we can have different limits based api (auth vs data vs something else )",
      "Severity": "Medium",
      "Impact": NaN,
      "Probable Solution/Code Considerations": "- more to be analyzed",
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": NaN
    },
    {
      "Key Metric": "Error Logging",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "-though winston is used as dependency , the proper logging code is not present \n- there are no log  levels\n- no structured logging",
      "Severity": "High",
      "Impact": "-really difficult to analyze/debug production issue",
      "Probable Solution/Code Considerations": "- Uses Winston with proper configuration",
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 32
    },
    {
      "Key Metric": "Default JWT secret",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'changeme') as any\n    req.user = decoded\n    next()\n  } catch (error) {\n    return res.status(401).json({ error: 'Invalid or expired token' })\n  }",
      "Severity": "Critical",
      "Impact": "- changeme comparison should never be used in production\n- also using any effectively bypassing type checking for this specific variable. This is often used when the exact structure of the decoded payload is not known at compile time or when dealing with dynamic data",
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": "already covered"
    },
    {
      "Key Metric": "Log sanitization",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- sensitive information (tokens, pii etc ) may end up in logs as we are not filtering the logs",
      "Severity": "Medium",
      "Impact": NaN,
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": NaN
    },
    {
      "Key Metric": "Input Validation",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- only 30 % routes used zod validation \n- no middleware protection",
      "Severity": "High",
      "Impact": "- need to comply to 100% input validation through zod\n- can add a dedicated validation middleware powered through zod",
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 24
    },
    {
      "Key Metric": "CSRF Protection",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- implementation missing",
      "Severity": "Critical",
      "Impact": NaN,
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": "already covered"
    },
    {
      "Key Metric": "Security headers",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- basic helmet config",
      "Severity": "High",
      "Impact": "- need to work on our cors config to stop all origin setting\n- ",
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 16
    },
    {
      "Key Metric": "Refresh Tokens",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- no implementation",
      "Severity": "High",
      "Impact": "- **XSS Attack**: If attacker steals token, they have 24 hours of access\n- **Token Theft**: Long-lived tokens increase attack window",
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": "already covered"
    }
  ],
  "Performance_n_Optimization": [
    {
      "Key Metric": "Caching",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- configured but not used as per code i saw\n- No Redis client installed in\n- No caching middleware implemented",
      "Severity": "Critical",
      "Impact": "- most used reads can be cached to avoid repetitive network calls and better performance",
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 80.0
    },
    {
      "Key Metric": "N+1 Query Patterns",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- Multiple routes fetch related data in loops",
      "Severity": "High",
      "Impact": "-**Impact**: For 50 communications, this becomes 150 queries!\n\n- **File**: `api/src/routes/communications.ts:127-147`\n   ```typescript\n   // \u26a0\ufe0f BAD: 3 separate queries per communication\n   const result = await pool.query(\n     'SELECT * FROM communications WHERE id = $1 AND tenant_id = $2',\n     [req.params.id, req.user!.tenant_id]\n   )\n   \n   // Query 2: Get linked entities\n   const linksResult = await pool.query(\n     `SELECT * FROM communication_entity_links WHERE communication_id = $1`,\n     [req.params.id]\n   )\n   \n   // Query 3: Get attachments\n   const attachmentsResult = await pool.query(\n     `SELECT * FROM communication_attachments WHERE communication_id = $1`,\n     [req.params.id]\n   )",
      "Probable Solution/Code Considerations": "**Remediation**: Use JOINs or batch queries\n   ```typescript\n   // \u2705 GOOD: Single query with JOINs\n   const result = await pool.query(`\n     SELECT \n       c.*,\n       json_agg(DISTINCT jsonb_build_object(\n         'entity_type', cel.entity_type,\n         'entity_id', cel.entity_id,\n         'link_type', cel.link_type\n       )) FILTER (WHERE cel.id IS NOT NULL) as linked_entities,\n       json_agg(DISTINCT jsonb_build_object(\n         'id', ca.id,\n         'filename', ca.filename,\n         'url', ca.url\n       )) FILTER (WHERE ca.id IS NOT NULL) as attachments\n     FROM communications c\n     LEFT JOIN communication_entity_links cel ON c.id = cel.communication_id\n     LEFT JOIN communication_attachments ca ON c.id = ca.communication_id\n     WHERE c.id = $1 AND c.tenant_id = $2\n     GROUP BY c.id\n   `, [req.params.id, req.user!.tenant_id])",
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 40.0
    },
    {
      "Key Metric": "Have API response middleware",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- no measure on which api's are slow and need to be looked into",
      "Severity": "High",
      "Impact": "-Can't identify slow endpoints",
      "Probable Solution/Code Considerations": "- we can add response time middleware in the start before we have a hold on every api performance matching our benchmark",
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 16.0
    },
    {
      "Key Metric": "Add memory leak detection",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- no tool currently used\n- things like database connection, timers, listeners, streams were not removed/cleaned up \n- there were code snippets like following : \n\nrouter.get('/vehicles', async (req, res) => {\n  const client = await pool.connect()\n  const result = await client.query('SELECT * FROM vehicles')\n  res.json(result.rows)\n  // Connection never released!\n})\n\n\n\n",
      "Severity": "Critical",
      "Impact": "- the initial dev part should have memory leak tool to identify to identify leaks ",
      "Probable Solution/Code Considerations": "- we can start with something like clinic.js or similar in combination with heap dump \n\n\n\n- Always release connection\nrouter.get('/vehicles', async (req, res) => {\n  const client = await pool.connect()\n  try {\n    const result = await client.query('SELECT * FROM vehicles')\n    res.json(result.rows)\n  } finally {\n    client.release()  // Always release\n  }\n})\n\n// \u2705 BETTER: Use pool.query (auto-releases)\nrouter.get('/vehicles', async (req, res) => {\n  const result = await pool.query('SELECT * FROM vehicles')\n  res.json(result.rows)\n})",
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 16.0
    },
    {
      "Key Metric": "Worker Threads for CPU intensive tasks ",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- not using worker threads at all",
      "Severity": "High",
      "Impact": "-  All requests blocked during generation/processing\n-  event loop gets choked",
      "Probable Solution/Code Considerations": "- we can identify places to use worker thread ,s pecially where there are : \n- CPU-intensive computations (image processing, encryption) - external AI and other tool calls (if needed)\n- Heavy JSON parsing/serialization\n- Data transformation (large datasets)\n- Cryptographic operations",
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": 32.0
    },
    {
      "Key Metric": "Use of streams",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- have to identify hot spots for this as i didnt find usage of streams in the code ",
      "Severity": "Medium",
      "Impact": "- app memory gets loaded with unnecessary information slowing everything else",
      "Probable Solution/Code Considerations": "- use streams when loading big file in memory . we don't need to load the whole 50 mb file in memory\n- use for things like csv or excel export , rather than getting all the data loaded into memory to dump to an csv , collect and push 100 records at a time and similar",
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": NaN
    },
    {
      "Key Metric": "- Async Processing and Background Jobs",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- async def process_generation_task(task_id: str, image: Image.Image, ...):\n       processed_image = process_image(image, remove_bg, foreground_ratio)\n       result = await loop.run_in_executor(None, generate_3d_mesh, processed_image, task_id)",
      "Severity": "Medium",
      "Impact": "**Request timeouts** ( for external calls might take more time)\n**Poor user experience** (users wait for processing)",
      "Probable Solution/Code Considerations": "- we can implement queue based solution after identifying async jobs ",
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": NaN
    },
    {
      "Key Metric": "- have read replicas (database side)",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- there is only one primary for now",
      "Severity": "Low",
      "Impact": NaN,
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN,
      "Rough Estimates (hrs)": NaN
    }
  ],
  "multi_tenancy": [
    {
      "Key Metric": "- enable RLS ",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": NaN,
      "Severity": "Medium",
      "Impact": NaN,
      "Probable Solution/Code Considerations": "need to create and apply row level security/policies for added level of security",
      "Notes/Comments": NaN
    },
    {
      "Key Metric": "- some tables foud with no tenant_id",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- can you please check tables like charging sessions, communications, vehicle telemetry",
      "Severity": "Critical",
      "Impact": NaN,
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN
    },
    {
      "Key Metric": "- some tables found with nullable tenant _id ",
      "Scope": "Application Level",
      "Module/Component": NaN,
      "Finding": "- can you please check tables like drivers, fuel transactions, work orders",
      "Severity": "Critical",
      "Impact": NaN,
      "Probable Solution/Code Considerations": NaN,
      "Notes/Comments": NaN
    }
  ]
}