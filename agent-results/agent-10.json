{
  "agent_id": 10,
  "name": "App Init Signatures",
  "file": "api/src/app.ts",
  "status": "success",
  "content": "/**\n * Fleet Management API - Main Application\n *\n * Production-ready Express application with complete middleware stack\n * and service integration.\n *\n * Features:\n * - JWT authentication with session management\n * - Role-based authorization\n * - Rate limiting with Redis\n * - Comprehensive audit logging\n * - Secrets and configuration management\n * - Graceful shutdown\n * - Health checks\n * - OpenAPI documentation\n */\n\nimport cors from 'cors';\nimport express, { Application, Request, Response } from 'express';\nimport helmet from 'helmet';\nimport Redis from 'ioredis';\nimport { Pool } from 'pg';\n\n// Services\nimport { createAuthMiddleware } from './middleware/auth.middleware';\nimport { createAuthzMiddleware } from './middleware/authz.middleware';\nimport { createErrorMiddleware } from './middleware/error.middleware';\nimport { createRateLimitMiddleware } from './middleware/rate-limit.middleware';\nimport { createAuthRoutes } from './routes/auth.routes';\nimport { AuditService } from './services/audit/AuditService';\nimport { AuthenticationService } from './services/auth/AuthenticationService';\nimport { AuthorizationService } from './services/authz/AuthorizationService';\nimport { ConfigurationManagementService } from './services/config/ConfigurationManagementService';\nimport { SecretsManagementService } from './services/secrets/SecretsManagementService';\n\n// Middleware\n\n// Routes\n\nexport class FleetAPI {\n  private app: Application;\n  private pool: Pool;\n  private redis: Redis;\n\n  // Services\n  private auditService: AuditService;\n  private authService: AuthenticationService;\n  private authzService: AuthorizationService;\n  private secretsService: SecretsManagementService;\n  private configService: ConfigurationManagementService;\n\n  constructor() {\n    this.app = express();\n\n    // Initialize database connection\n    this.pool = new Pool({\n      connectionString: process.env.DATABASE_URL,\n      ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : undefined,\n      max: 20,\n      idleTimeoutMillis: 30000,\n      connectionTimeoutMillis: 2000,\n    });\n\n    // Initialize Redis\n    this.redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379', {\n      maxRetriesPerRequest: 3,\n      enableReadyCheck: true,\n      lazyConnect: true\n    });\n\n    // Initialize services\n    this.auditService = new AuditService(this.pool, {\n      azureBlobConnectionString: process.env.AZURE_STORAGE_CONNECTION_STRING,\n      azureKeyVaultUrl: process.env.AZURE_KEYVAULT_URL\n    });\n\n    this.authService = new AuthenticationService(this.pool, this.redis);\n    this.authzService = new AuthorizationService(this.pool, true, process.env.REDIS_URL);\n    this.secretsService = new SecretsManagementService(this.pool);\n    this.configService = new ConfigurationManagementService(this.pool, this.redis);\n\n    this.setupMiddleware();\n    this.setupRoutes();\n    this.setupErrorHandling();\n  }\n\n  private setupMiddleware(): void {\n    // Security headers (FIRST)\n    this.app.use(helmet({\n      contentSecurityPolicy: {\n        directives: {\n          defaultSrc: [\"'self'\"],\n          styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n          scriptSrc: [\"'self'\"],\n          imgSrc: [\"'self'\", 'data:', 'https:'],\n        }\n      },\n      hsts: {\n        maxAge: 31536000,\n        includeSubDomains: true,\n        preload: true\n      }\n    }));\n\n    // CORS\n    this.app.use(cors({\n      origin: process.env.CORS_ORIGIN || '*',\n      credentials: true,\n      methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],\n      allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID']\n    }));\n\n    // Body parsing\n    this.app.use(express.json({ limit: '10mb' }));\n    this.app.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n    // Request ID\n    this.app.use((req: Request, res: Response, next) => {\n      req.headers['x-request-id'] = req.headers['x-request-id'] ||\n        `${Date.now()}-${Math.random().toString(36).substring(7)}`;\n      res.setHeader('X-Request-ID', req.headers['x-request-id'] as string);\n      next();\n    });\n\n    // Rate limiting\n    const rateLimitMiddleware = createRateLimitMiddleware(this.redis);\n    this.app.use(rateLimitMiddleware.global);\n\n    // Request logging\n    this.app.use((req: Request, res: Response, next) => {\n      const start = Date.now();\n      res.on('finish', () => {\n        const duration = Date.now() - start;\n        console.log(`${req.method} ${req.path} ${res.statusCode} ${duration}ms`);\n      });\n      next();\n    });\n  }\n\n  private setupRoutes(): void {\n    // Health check endpoint (no auth required)\n    this.app.get('/health', async (req: Request, res: Response) => {\n      try {\n        // Check database\n        await this.pool.query('SELECT 1');\n\n        // Check Redis\n        await this.redis.ping();\n\n        res.json({\n          success: true,\n          data: {\n            status: 'healthy',\n            timestamp: new Date().toISOString(),\n            uptime: process.uptime(),\n            version: process.env.npm_package_version || '1.0.0'\n          }\n        });\n      } catch (_error) {\n        res.status(503).json({\n          success: false,\n          error: {\n            code: 'UNHEALTHY',\n            message: 'Service is unhealthy'\n          }\n        });\n      }\n    });\n\n    // API root\n    this.app.get('/', (req: Request, res: Response) => {\n      res.json({\n        name: 'Fleet Management API',\n        version: '1.0.0',\n        documentation: '/api-docs',\n        health: '/health'\n      });\n    });\n\n    // Auth middleware instances\n    const authMiddleware = createAuthMiddleware(this.pool, this.redis, this.auditService);\n    const authzMiddleware = createAuthzMiddleware(this.pool, this.auditService);\n\n    // Public routes (no authentication required)\n    this.app.use('/auth', createAuthRoutes(this.pool, this.redis, this.auditService));\n\n    // Protected routes (authentication required)\n    // Config routes\n    this.app.get('/config/:key', authMiddleware.authenticate, async (req: Request, res: Response, next) => {\n      try {\n        const value = await this.configService.get(req.params.key);\n        res.json({ success: true, data: value });\n      } catch (error) {\n        next(error);\n      }\n    });\n\n    this.app.post('/config/:key',\n      authMiddleware.authenticate,\n      authzMiddleware.requirePermission('config:write:global'),\n      async (req: Request, res: Response, next) => {\n        try {\n          if (!req.user) {\n            res.status(401).json({ success: false, error: 'Unauthorized' });\n            return;\n          }\n          const version = await this.configService.set(\n            req.params.key,\n            req.body.value,\n            { scope: req.body.scope || 'global', scopeId: req.body.scopeId },\n            req.user.userId.toString(),\n            req.body.comment\n          );\n          res.json({ success: true, data: version });\n        } catch (error) {\n          next(error);\n        }\n      }\n    );\n\n    // Secrets routes\n    this.app.get('/secrets/:name',\n      authMiddleware.authenticate,\n      authzMiddleware.requirePermission('secrets:read:global'),\n      async (req: Request, res: Response, next) => {\n        try {\n          if (!req.user) {\n            res.status(401).json({ success: false, error: 'Unauthorized' });\n            return;\n          }\n          const value = await this.secretsService.getSecret(req.params.name, {\n            userId: req.user.userId.toString(),\n            ipAddress: req.ip || '',\n            userAgent: req.headers['user-agent'] || ''\n          });\n          res.json({ success: true, data: { value } });\n        } catch (error) {\n          next(error);\n        }\n      }\n    );\n\n    this.app.post('/secrets/:name',\n      authMiddleware.authenticate,\n      authzMiddleware.requirePermission('secrets:write:global'),\n      async (req: Request, res: Response, next) => {\n        try {\n          if (!req.user) {\n            res.status(401).json({ success: false, error: 'Unauthorized' });\n            return;\n          }\n          await this.secretsService.setSecret(\n            req.params.name,\n            req.body.value,\n            req.body.metadata,\n            {\n              userId: req.user.userId.toString(),\n              ipAddress: req.ip || '',\n              userAgent: req.headers['user-agent'] || ''\n            }\n          );\n          res.json({ success: true, message: 'Secret stored successfully' });\n        } catch (error) {\n          next(error);\n        }\n      }\n    );\n\n    // Audit routes\n    this.app.get('/audit/logs',\n      authMiddleware.authenticate,\n      authzMiddleware.requireRole(['Admin', 'Auditor']),\n      async (req: Request, res: Response, next) => {\n        try {\n          const logs = await this.auditService.query({\n            userId: req.query.userId as string,\n            action: req.query.action as string,\n            startDate: req.query.startDate ? new Date(req.query.startDate as string) : undefined,\n            endDate: req.query.endDate ? new Date(req.query.endDate as string) : undefined,\n            limit: parseInt(req.query.limit as string) || 100,\n            offset: parseInt(req.query.offset as string) || 0\n          });\n          res.json({ success: true, data: logs });\n        } catch (error) {\n          next(error);\n        }\n      }\n    );\n\n    this.app.get('/audit/verify',\n      authMiddleware.authenticate,\n      authzMiddleware.requireRole(['Admin']),\n      async (req: Request, res: Response, next) => {\n        try {\n          const verification = await this.auditService.verifyChain();\n          res.json({ success: true, data: verification });\n        } catch (error) {\n          next(error);\n        }\n      }\n    );\n\n    // Admin routes\n    this.app.post('/admin/users/:id/roles',\n      authMiddleware.authenticate,\n      authzMiddleware.requireRole(['Admin']),\n      async (req: Request, res: Response, next) => {\n        try {\n          if (!req.user) {\n            res.status(401).json({ success: false, error: 'Unauthorized' });\n            return;\n          }\n          await this.authzService.assignRole(\n            req.params.id,\n            req.body.roleId,\n            req.user.userId.toString(),\n            req.body.expiresAt ? new Date(req.body.expiresAt) : undefined\n          );\n          res.json({ success: true, message: 'Role assigned successfully' });\n        } catch (error) {\n          next(error);\n        }\n      }\n    );\n\n    // 404 handler\n    this.app.use((req: Request, res: Response) => {\n      res.status(404).json({\n        success: false,\n        error: {\n          code: 'NOT_FOUND',\n          message: 'Endpoint not found'\n        }\n      });\n    });\n  }\n\n  private setupErrorHandling(): void {\n    // @ts-expect-error - Build compatibility fix\n    const errorMiddleware = createErrorMiddleware(this.auditService);\n    this.app.use(errorMiddleware.handle);\n  }\n\n  async start(port: number = 3000): Promise<void> {\n    try {\n      // Connect to Redis\n      await this.redis.connect();\n      console.log('\u2713 Redis connected');\n\n      // Initialize secrets service\n      await this.secretsService.initialize();\n      console.log('\u2713 Secrets service initialized');\n\n      // Test database connection\n      await this.pool.query('SELECT 1');\n      console.log('\u2713 Database connected');\n\n      // Start server\n      this.app.listen(port, () => {\n        console.log(`\u2713 Fleet Management API running on port ${port}`);\n        console.log(`  Health: http://localhost:${port}/health`);\n        console.log(`  Environment: ${process.env.NODE_ENV || 'development'}`);\n      });\n\n      // Setup graceful shutdown\n      this.setupGracefulShutdown();\n    } catch (error) {\n      console.error('Failed to start server:', error);\n      process.exit(1);\n    }\n  }\n\n  private setupGracefulShutdown(): void {\n    const shutdown = async (signal: string) => {\n      console.log(`\\n${signal} received. Starting graceful shutdown...`);\n\n      try {\n        // Close Redis\n        await this.redis.quit();\n        console.log('\u2713 Redis connection closed');\n\n        // Close database pool\n        await this.pool.end();\n        console.log('\u2713 Database pool closed');\n\n        // Shutdown secrets service\n        await this.secretsService.shutdown();\n        console.log('\u2713 Secrets service shutdown complete');\n\n        console.log('\u2713 Graceful shutdown complete');\n        process.exit(0);\n      } catch (error) {\n        console.error('Error during shutdown:', error);\n        process.exit(1);\n      }\n    };\n\n    process.on('SIGTERM', () => shutdown('SIGTERM'));\n    process.on('SIGINT', () => shutdown('SIGINT'));\n  }\n\n  getApp(): Application {\n    return this.app;\n  }\n}\n\n// Start server if run directly\nif (require.main === module) {\n  const api = new FleetAPI();\n  const port = parseInt(process.env.PORT || '3000', 10);\n  api.start(port);\n}\n\nexport default FleetAPI;",
  "timestamp": "2026-01-18T16:21:48.530903"
}