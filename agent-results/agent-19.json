{
  "agent_id": 19,
  "name": "Vehicles Base Repo",
  "file": "api/src/repositories/vehicles.repository.ts",
  "status": "success",
  "content": "import { Pool } from 'pg';\n\nimport { pool } from '../config/database' // Changed to valid pool import\nimport { container } from '../container'\nimport { NotFoundError, ValidationError } from '../errors/app-error'\n\nimport { BaseRepository, PaginationParams } from './base/BaseRepository';\n\nimport { CacheService, CacheKeys } from '../services/cache.service'\n\nexport interface Vehicle {\n  id: number\n  vin: string\n  licensePlate: string\n  make: string\n  model: string\n  year: number\n  tenantId: string\n  status: 'active' | 'maintenance' | 'retired'\n  mileage?: number\n  fuelType?: string\n  department?: string\n  createdAt: Date\n  updatedAt: Date\n}\n\n/**\n * VehiclesRepository - BACKEND-17\n * All queries use parameterized statements ($1, $2, $3) for SQL injection prevention\n * All operations enforce tenant isolation\n * Includes Redis caching layer with cache invalidation on mutations\n */\nimport { TYPES } from '../types';\n\nexport class VehiclesRepository extends BaseRepository<any> {\n  private cache: CacheService\n\n  constructor(pool: Pool) {\n    super(pool, 'vehicles');\n    this.cache = container.get<CacheService>(TYPES.CacheService)\n  }\n\n  /**\n   * Find vehicle by ID with tenant isolation (cached)\n   * @param id Vehicle ID\n   * @param tenantId Tenant ID for isolation\n   * @returns Vehicle or null\n   */\n  async findById(id: number, tenantId: string): Promise<Vehicle | null> {\n    const cacheKey = CacheKeys.vehicle(id)\n\n    return await this.cache.getOrSet(\n      cacheKey,\n      async () => {\n        const result = await this.pool.query(\n          'SELECT id, vin, license_plate, make, model, year, status, mileage, fuel_type, department, tenant_id, created_at, updated_at FROM vehicles WHERE id = $1 AND tenant_id = $2',\n          [id, tenantId]\n        )\n        return result.rows[0] || null\n      },\n      3600 // Cache for 1 hour\n    )\n  }\n\n  /**\n   * Find all vehicles for a tenant with pagination\n   * @param tenantId Tenant ID for isolation\n   * @param pagination Pagination parameters\n   * @returns Array of vehicles\n   */\n  async findByTenant(\n    tenantId: string,\n    pagination: PaginationParams = {}\n  ): Promise<Vehicle[]> {\n    const { page = 1, limit = 20, sortBy = 'created_at', sortOrder = 'desc' } = pagination\n    const offset = (page - 1) * limit\n\n    // Whitelist sortBy to prevent SQL injection\n    const allowedSortColumns = ['id', 'vin', 'make', 'model', 'year', 'created_at', 'updated_at', 'status']\n    const safeSortBy = allowedSortColumns.includes(sortBy) ? sortBy : 'created_at'\n    const safeSortOrder = sortOrder?.toUpperCase() === 'ASC' ? 'ASC' : 'DESC'\n\n    const result = await this.pool.query(\n      `SELECT id, vin, license_plate, make, model, year, status, mileage, fuel_type, department, tenant_id, created_at, updated_at FROM vehicles \n       WHERE tenant_id = $1 \n       ORDER BY ${safeSortBy} ${safeSortOrder} \n       LIMIT $2 OFFSET $3`,\n      [tenantId, limit, offset]\n    )\n    return result.rows\n  }\n\n  /**\n   * Find vehicle by VIN with tenant isolation\n   * @param vin Vehicle Identification Number\n   * @param tenantId Tenant ID for isolation\n   * @returns Vehicle or null\n   */\n  async findByVIN(vin: string, tenantId: string): Promise<Vehicle | null> {\n    const result = await this.pool.query(\n      'SELECT id, vin, license_plate, make, model, year, status, mileage, fuel_type, department, tenant_id, created_at, updated_at FROM vehicles WHERE vin = $1 AND tenant_id = $2',\n      [vin, tenantId]\n    )\n    return result.rows[0] || null\n  }\n\n  /**\n   * Find vehicles by status with tenant isolation\n   * @param status Vehicle status\n   * @param tenantId Tenant ID for isolation\n   * @returns Array of vehicles\n   */\n  async findByStatus(\n    status: 'active' | 'maintenance' | 'retired',\n    tenantId: string\n  ): Promise<Vehicle[]> {\n    const result = await this.pool.query(\n      'SELECT id, vin, license_plate, make, model, year, status, mileage, fuel_type, department, tenant_id, created_at, updated_at FROM vehicles WHERE status = $1 AND tenant_id = $2 ORDER BY created_at DESC',\n      [status, tenantId]\n    )\n    return result.rows\n  }\n\n  /**\n   * Create new vehicle with tenant isolation (invalidates cache)\n   * @param data Partial vehicle data\n   * @param tenantId Tenant ID for isolation\n   * @returns Created vehicle\n   */\n  async create(data: Partial<Vehicle>, tenantId: string): Promise<Vehicle> {\n    // Validate required fields\n    if (!data.vin || !data.make || !data.model || !data.year) {\n      throw new ValidationError('VIN, make, model, and year are required')\n    }\n\n    // Check for duplicate VIN\n    const existing = await this.findByVIN(data.vin, tenantId)\n    if (existing) {\n      throw new ValidationError(`Vehicle with VIN ${data.vin} already exists`)\n    }\n\n    const result = await this.pool.query(\n      `INSERT INTO vehicles (\n        vin, license_plate, make, model, year, status, mileage, fuel_type, department, tenant_id\n      )\n      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\n      RETURNING id, vin, license_plate, make, model, year, status, mileage, fuel_type, department, tenant_id, created_at, updated_at`,\n      [\n        data.vin,\n        data.licensePlate || null,\n        data.make,\n        data.model,\n        data.year,\n        data.status || 'active',\n        data.mileage || 0,\n        data.fuelType || null,\n        data.department || null,\n        tenantId\n      ]\n    )\n\n    // Invalidate tenant-level cache\n    await this.cache.deletePattern(CacheKeys.vehicles(parseInt(tenantId)))\n\n    return result.rows[0]\n  }\n\n  /**\n   * Update vehicle with tenant isolation (invalidates cache)\n   * @param id Vehicle ID\n   * @param data Partial vehicle data\n   * @param tenantId Tenant ID for isolation\n   * @returns Updated vehicle\n   */\n  async update(\n    id: number,\n    data: Partial<Vehicle>,\n    tenantId: string\n  ): Promise<Vehicle> {\n    // Verify vehicle exists and belongs to tenant\n    const existing = await this.findById(id, tenantId)\n    if (!existing) {\n      throw new NotFoundError('Vehicle')\n    }\n\n    const result = await this.pool.query(\n      `UPDATE vehicles\n       SET license_plate = COALESCE($1, license_plate),\n           make = COALESCE($2, make),\n           model = COALESCE($3, model),\n           year = COALESCE($4, year),\n           status = COALESCE($5, status),\n           mileage = COALESCE($6, mileage),\n           fuel_type = COALESCE($7, fuel_type),\n           department = COALESCE($8, department),\n           updated_at = NOW()\n       WHERE id = $9 AND tenant_id = $10\n       RETURNING id, vin, license_plate, make, model, year, status, mileage, fuel_type, department, tenant_id, created_at, updated_at`,\n      [\n        data.licensePlate,\n        data.make,\n        data.model,\n        data.year,\n        data.status,\n        data.mileage,\n        data.fuelType,\n        data.department,\n        id,\n        tenantId\n      ]\n    )\n\n    // Invalidate individual and tenant-level cache\n    await this.cache.delete(CacheKeys.vehicle(id))\n    await this.cache.deletePattern(CacheKeys.vehicles(parseInt(tenantId)))\n\n    return result.rows[0]\n  }\n\n  /**\n   * Delete vehicle with tenant isolation (invalidates cache)\n   * @param id Vehicle ID\n   * @param tenantId Tenant ID for isolation\n   * @returns true if deleted\n   */\n  async delete(id: number, tenantId: string): Promise<boolean> {\n    const result = await this.pool.query(\n      'DELETE FROM vehicles WHERE id = $1 AND tenant_id = $2',\n      [id, tenantId]\n    )\n\n    const deleted = (result.rowCount ?? 0) > 0\n    if (deleted) {\n      // Invalidate individual and tenant-level cache\n      await this.cache.delete(CacheKeys.vehicle(id))\n      await this.cache.deletePattern(CacheKeys.vehicles(parseInt(tenantId)))\n    }\n\n    return deleted\n  }\n\n  /**\n   * Count total vehicles for a tenant\n   * @param tenantId Tenant ID for isolation\n   * @returns Total count\n   */\n  async countByTenant(tenantId: string): Promise<number> {\n    const result = await this.pool.query(\n      'SELECT COUNT(*) FROM vehicles WHERE tenant_id = $1',\n      [tenantId]\n    )\n    return parseInt(result.rows[0].count, 10)\n  }\n\n  /**\n   * Search vehicles by keyword with tenant isolation\n   * @param keyword Search keyword\n   * @param tenantId Tenant ID for isolation\n   * @returns Array of vehicles\n   */\n  async search(keyword: string, tenantId: string): Promise<Vehicle[]> {\n    const searchTerm = `%${keyword}%`\n    const result = await this.pool.query(\n      `SELECT id, vin, license_plate, make, model, year, status, mileage, fuel_type, department, tenant_id, created_at, updated_at FROM vehicles\n       WHERE tenant_id = $1\n       AND (\n         make ILIKE $2 OR\n         model ILIKE $2 OR\n         vin ILIKE $2 OR\n         license_plate ILIKE $2\n       )\n       ORDER BY created_at DESC`,\n      [tenantId, searchTerm]\n    )\n    return result.rows\n  }\n\n  /**\n   * Validate that a vehicle exists and belongs to the tenant\n   * @param id Vehicle ID\n   * @param tenantId Tenant ID for isolation\n   * @returns true if vehicle exists and belongs to tenant\n   */\n  async validateOwnership(id: number, tenantId: string): Promise<boolean> {\n    const result = await this.pool.query(\n      'SELECT id FROM vehicles WHERE id = $1 AND tenant_id = $2',\n      [id, tenantId]\n    )\n    return result.rows.length > 0\n  }\n\n  // ========================================================================\n  // EAGER LOADING METHODS - B9 (N+1 Query Prevention)\n  // ========================================================================\n\n  /**\n   * B9: Fetch vehicles with driver information (eager loading)\n   * Prevents N+1 query problem by using LEFT JOIN\n   * @param tenantId Tenant ID for isolation\n   * @param pagination Pagination parameters\n   * @returns Array of vehicles with driver data\n   */\n  async findByTenantWithDrivers(\n    tenantId: string,\n    pagination: PaginationParams = {}\n  ): Promise<any[]> {\n    const { page = 1, limit = 20, sortBy = 'created_at', sortOrder = 'desc' } = pagination\n    const offset = (page - 1) * limit\n\n    const allowedSortColumns = ['id', 'vin', 'make', 'model', 'year', 'created_at', 'updated_at', 'status']\n    const safeSortBy = allowedSortColumns.includes(sortBy) ? `v.${sortBy}` : 'v.created_at'\n    const safeSortOrder = (sortOrder?.toUpperCase() === 'ASC' || sortOrder?.toLowerCase() === 'asc') ? 'ASC' : 'DESC'\n\n    const result = await this.pool.query(\n      `SELECT\n        v.*,\n        d.id as driver_id,\n        d.name as driver_name,\n        d.license_number as driver_license,\n        d.phone as driver_phone,\n        d.email as driver_email\n      FROM vehicles v\n      LEFT JOIN drivers d ON v.assigned_driver_id = d.id AND d.tenant_id = $1\n      WHERE v.tenant_id = $1\n      ORDER BY ${safeSortBy} ${safeSortOrder}\n      LIMIT $2 OFFSET $3`,\n      [tenantId, limit, offset]\n    )\n\n    return result.rows\n  }\n\n  /**\n   * B9: Fetch single vehicle with all related data (eager loading)\n   * Prevents N+1 by fetching all relations in one query\n   * @param id Vehicle ID\n   * @param tenantId Tenant ID for isolation\n   * @returns Vehicle with all relations or null\n   */\n  async findByIdWithRelations(id: number, tenantId: string): Promise<any | null> {\n    const result = await this.pool.query(\n      `SELECT\n        v.*,\n        d.id as driver_id,\n        d.name as driver_name,\n        d.license_number as driver_license,\n        COUNT(DISTINCT m.id) as maintenance_count,\n        COUNT(DISTINCT f.id) as fuel_transaction_count,\n        MAX(m.service_date) as last_service_date\n      FROM vehicles v\n      LEFT JOIN drivers d ON v.assigned_driver_id = d.id AND d.tenant_id = $2\n      LEFT JOIN maintenance_records m ON v.id = m.vehicle_id AND m.tenant_id = $2\n      LEFT JOIN fuel_transactions f ON v.id = f.vehicle_id AND f.tenant_id = $2\n      WHERE v.id = $1 AND v.tenant_id = $2\n      GROUP BY v.id, d.id, d.name, d.license_number`,\n      [id, tenantId]\n    )\n\n    return result.rows[0] || null\n  }\n\n  /**\n   * N+1 PREVENTION: Fetch vehicle with driver and last 5 maintenance records\n   */\n  async findWithDriverAndMaintenance(id: string, tenantId: string) {\n    const query = `\n      SELECT\n        v.id, v.make, v.model, v.year, v.vin, v.license_plate, v.mileage, v.status,\n        d.id as driver_id, d.name as driver_name, d.email as driver_email, d.phone as driver_phone,\n        m.id as maintenance_id, m.type as maintenance_type, m.date as maintenance_date,\n        m.cost as maintenance_cost, m.description as maintenance_description\n      FROM vehicles v\n      LEFT JOIN drivers d ON v.driver_id = d.id\n      LEFT JOIN LATERAL (\n        SELECT * FROM maintenance\n        WHERE vehicle_id = v.id AND deleted_at IS NULL\n        ORDER BY date DESC\n        LIMIT 5\n      ) m ON true\n      WHERE v.id = $1 AND v.tenant_id = $2 AND v.deleted_at IS NULL\n    `;\n    const result = await this.pool.query(query, [id, tenantId]);\n    return result.rows;\n  }\n\n  /**\n   * N+1 PREVENTION: Fetch all vehicles with drivers and status\n   */\n  async findAllWithDriversAndStatus(tenantId: string) {\n    const query = `\n      SELECT\n        v.id, v.make, v.model, v.year, v.vin, v.license_plate, v.mileage, v.",
  "timestamp": "2026-01-18T16:21:48.533604"
}