{
  "agent_id": 8,
  "name": "Drill-Through Routes",
  "file": "api/src/routes/drill-through/drill-through.routes.enhanced.ts",
  "status": "success",
  "content": "import express, { Request, Response } from 'express';\nimport rateLimit from 'express-rate-limit';\nimport helmet from 'helmet';\nimport { Pool } from 'pg';\nimport { z } from 'zod';\n\nimport { doubleCsrfProtection } from '../../middleware/csrf';\n\nimport { generateExcel } from './utils/generateExcel';\nimport { generatePDF } from './utils/generatePDF';\nimport { buildDrillThroughQuery } from './utils/queryBuilder';\nimport { validateEntityType, validateFilters, validateFormat } from './validators';\n\n\n\nconst router = express.Router();\n\nrouter.use(helmet());\nrouter.use(express.json());\n// SECURITY: Using csrf-csrf (double-submit cookie) instead of vulnerable csurf\nrouter.use(doubleCsrfProtection);\n\nconst apiLimiter = rateLimit({\n  windowMs: 60 * 1000, // 1 minute\n  max: 100,\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nrouter.use(apiLimiter);\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nrouter.get('/:entityType', async (req: Request, res: Response) => {\n  try {\n    const entityTypeSchema = z.string();\n    const entityType = entityTypeSchema.parse(req.params.entityType);\n    validateEntityType(entityType);\n\n    const { page = '1', pageSize = '50', filters = '{}' } = req.query as { page?: string; pageSize?: string; filters?: string };\n\n    const pageNum = parseInt(page, 10);\n    const pageSizeNum = parseInt(pageSize, 10);\n    const offset = (pageNum - 1) * pageSizeNum;\n\n    const filtersSchema = z.object({}).passthrough();\n    const parsedFilters = validateFilters(filtersSchema, filters);\n\n    const { query, countQuery, params, summary } = buildDrillThroughQuery(\n      entityType,\n      parsedFilters,\n      pageSizeNum,\n      offset\n    );\n\n    const countResult = await pool.query(countQuery, params.slice(0, -2));\n    const totalCount = parseInt(countResult.rows[0].count, 10);\n    const totalPages = Math.ceil(totalCount / pageSizeNum);\n\n    const dataResult = await pool.query(query, params);\n\n    let summaryData = null;\n    if (summary) {\n      const summaryResult = await pool.query(summary.query, summary.params);\n      summaryData = summaryResult.rows[0];\n    }\n\n    res.json({\n      totalCount,\n      data: dataResult.rows,\n      page: pageNum,\n      pageSize: pageSizeNum,\n      totalPages,\n      summary: summaryData,\n    });\n  } catch (error) {\n    console.error('Drill-through error:', error);\n    res.status(500).json({ error: 'Failed to fetch drill-through data' });\n  }\n});\n\nrouter.get('/:entityType/export', async (req: Request, res: Response) => {\n  try {\n    const entityType = validateEntityType(req.params.entityType);\n    const { filters = '{}', format = 'csv' } = req.query as { filters?: string; format?: string };\n\n    const parsedFilters = validateFilters(z.object({}).passthrough(), filters);\n\n    const { query, params } = buildDrillThroughQuery(\n      entityType,\n      parsedFilters,\n      1000000,\n      0\n    );\n\n    const exportQuery = query.replace(/LIMIT \\$\\d+ OFFSET \\$\\d+/, '');\n    const result = await pool.query(exportQuery, params.slice(0, -2));\n\n    const filename = `${entityType}_export_${new Date().toISOString().split('T')[0]}`;\n\n    validateFormat(format);\n\n    switch (format) {\n      case 'xlsx':\n        const workbook = await generateExcel(result.rows);\n        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');\n        res.setHeader('Content-Disposition', `attachment; filename=${filename}.xlsx`);\n        await workbook.xlsx.write(res);\n        res.end();\n        break;\n      case 'pdf':\n        const pdfDoc = await generatePDF(result.rows);\n        res.setHeader('Content-Type', 'application/pdf');\n        res.setHeader('Content-Disposition', `attachment; filename=${filename}.pdf`);\n        const pdfBytes = await pdfDoc.save();\n        res.send(pdfBytes);\n        break;\n      default:\n        res.status(400).json({ error: 'Unsupported export format' });\n    }\n  } catch (error) {\n    console.error('Export error:', error);\n    res.status(500).json({ error: 'Failed to export data' });\n  }\n});\n\nexport default router;",
  "timestamp": "2026-01-18T16:21:48.529414"
}