{
  "agent_id": 4,
  "name": "ConfigurationManagement",
  "file": "api/src/services/config/ConfigurationManagementService.ts",
  "status": "success",
  "content": "```typescript\n/**\n * Configuration Management Service\n *\n * Comprehensive configuration management with versioning, rollback, and approval workflows.\n * Acts as the SINGLE SOURCE OF TRUTH for all application configuration.\n *\n * Features:\n * - Typed configuration with Zod validation\n * - Hierarchical scope inheritance (global \u2192 org \u2192 team \u2192 user)\n * - Git-like versioning with complete history\n * - Point-in-time recovery and rollback\n * - Approval workflow for critical changes\n * - Feature flags with gradual rollout\n * - Real-time configuration updates\n * - Impact analysis before changes\n * - Encrypted sensitive values\n * - Complete audit trail\n *\n * @module ConfigurationManagementService\n */\n\nimport * as crypto from 'crypto';\nimport { EventEmitter } from 'events';\n\nimport Redis from 'ioredis';\nimport { Pool } from 'pg';\nimport { z } from 'zod';\n\n// ============================================================================\n// Types and Enums\n// ============================================================================\n\nexport enum ConfigScope {\n  GLOBAL = 'global',        // Applies to entire system\n  ORGANIZATION = 'org',     // Applies to one organization\n  TEAM = 'team',            // Applies to one team\n  USER = 'user'             // User-specific overrides\n}\n\nexport enum ImpactLevel {\n  NONE = 'none',           // No impact\n  LOW = 'low',             // Minor UI changes\n  MEDIUM = 'medium',       // Feature behavior changes\n  HIGH = 'high',           // Critical system behavior\n  CRITICAL = 'critical'    // Requires downtime or approval\n}\n\nexport enum ChangeStatus {\n  PENDING = 'pending',\n  APPROVED = 'approved',\n  REJECTED = 'rejected',\n  APPLIED = 'applied'\n}\n\nexport interface ConfigVersion {\n  id: string;\n  key: string;\n  value: any;\n  version: string;\n  previousVersion?: string;\n  scope: ConfigScope;\n  scopeId?: string;\n  changedBy: string;\n  changedAt: Date;\n  comment?: string;\n  tags: string[];\n  impactLevel: ImpactLevel;\n  isRollback: boolean;\n  rollbackFromVersion?: string;\n  diff?: ConfigDiff[];\n}\n\nexport interface ConfigDiff {\n  path: string;\n  operation: 'add' | 'modify' | 'delete';\n  oldValue?: any;\n  newValue?: any;\n}\n\nexport interface ChangeRequest {\n  id: string;\n  key: string;\n  currentValue: any;\n  proposedValue: any;\n  scope: ConfigScope;\n  scopeId?: string;\n  status: ChangeStatus;\n  impactLevel: ImpactLevel;\n  requestedBy: string;\n  requestedAt: Date;\n  justification: string;\n  minimumApprovals: number;\n  approvals: ChangeApproval[];\n  rejections: ChangeApproval[];\n  appliedAt?: Date;\n  appliedVersion?: string;\n  expiresAt?: Date;\n}\n\nexport interface ChangeApproval {\n  userId: string;\n  timestamp: Date;\n  comment?: string;\n}\n\nexport interface FeatureFlag {\n  name: string;\n  enabled: boolean;\n  rolloutPercentage: number;\n  conditions?: FlagCondition[];\n  description: string;\n  metadata?: Record<string, any>;\n}\n\nexport interface FlagCondition {\n  attribute: string;\n  operator: 'equals' | 'in' | 'notIn' | 'gt' | 'lt' | 'contains';\n  value?: any;\n  values?: any[];\n}\n\nexport interface FlagContext {\n  userId?: string;\n  organizationId?: string;\n  environment?: string;\n  attributes?: Record<string, any>;\n}\n\nexport interface ImpactReport {\n  impactLevel: ImpactLevel;\n  affectedServices: string[];\n  affectedUsers: number;\n  requiresApproval: boolean;\n  requiredApprovers: string[];\n  estimatedDowntime?: number;\n  rollbackPlan: string;\n  testingRecommendations: string[];\n  dependencies: string[];\n}\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors?: Array<{ path: string; message: string }>;\n}\n\nexport interface ImportResult {\n  imported: number;\n  failed: number;\n  errors: Array<{ key: string; error: string }>;\n}\n\nexport interface ConfigChange {\n  key: string;\n  oldValue: any;\n  newValue: any;\n  scope: ConfigScope;\n  scopeId?: string;\n  changedBy: string;\n  version: string;\n}\n\n// ============================================================================\n// Pre-defined Configuration Schemas\n// ============================================================================\n\nconst brandingSchema = z.object({\n  logo: z.string().url(),\n  primaryColor: z.string().regex(/^#[0-9A-F]{6}$/),\n  secondaryColor: z.string().regex(/^#[0-9A-F]{6}$/),\n  companyName: z.string().min(1).max(100),\n  tagline: z.string().max(200).optional()\n});\n\nconst pmIntervalsSchema = z.object({\n  lightDuty: z.number().min(1000).max(10000),\n  mediumDuty: z.number().min(5000).max(20000),\n  heavyDuty: z.number().min(10000).max(50000)\n});\n\nconst approvalThresholdsSchema = z.object({\n  maintenanceApproval: z.number().min(0),\n  procurementApproval: z.number().min(0),\n  budgetVariance: z.number().min(0).max(100)\n});\n\nconst emailNotificationsSchema = z.object({\n  maintenanceDue: z.boolean(),\n  inspectionDue: z.boolean(),\n  documentExpiring: z.boolean(),\n  workOrderAssigned: z.boolean(),\n  dailyDigest: z.boolean()\n});\n\nconst systemSettingsSchema = z.object({\n  maintenanceMode: z.boolean(),\n  allowSelfRegistration: z.boolean(),\n  sessionTimeout: z.number().min(5).max(1440),\n  maxLoginAttempts: z.number().min(3).max(10)\n});\n\n// ============================================================================\n// Configuration Management Service\n// ============================================================================\n\nexport class ConfigurationManagementService {\n  private pool: Pool;\n  private redis?: Redis;\n  private eventEmitter: EventEmitter;\n  private encryptionKey: Buffer;\n  private cacheEnabled: boolean;\n  private cacheTtl: number;\n  private schemas: Map<string, z.ZodSchema>;\n\n  /**\n   * Create a new ConfigurationManagementService\n   *\n   * @param pool - PostgreSQL connection pool\n   * @param options - Service configuration options\n   */\n  constructor(\n    pool: Pool,\n    options: {\n      redis?: Redis;\n      encryptionKey?: string;\n      cacheEnabled?: boolean;\n      cacheTtl?: number;\n    } = {}\n  ) {\n    this.pool = pool;\n    this.redis = options.redis;\n    this.eventEmitter = new EventEmitter();\n    this.cacheEnabled = options.cacheEnabled ?? true;\n    this.cacheTtl = options.cacheTtl ?? 300; // 5 minutes default\n\n    // Initialize encryption key (from env or generate)\n    const keyString = options.encryptionKey || process.env.CONFIG_ENCRYPTION_KEY;\n    if (keyString) {\n      this.encryptionKey = Buffer.from(keyString, 'base64');\n    } else {\n      // Generate a random key (should be persisted in production)\n      this.encryptionKey = crypto.randomBytes(32);\n      console.warn(\n        '[ConfigService] No encryption key provided, generated random key. ' +\n        'Set CONFIG_ENCRYPTION_KEY env var in production!'\n      );\n    }\n\n    // Register built-in schemas\n    this.schemas = new Map<string, z.ZodSchema>();\n    this.schemas.set('branding', brandingSchema);\n    this.schemas.set('pm_intervals', pmIntervalsSchema);\n    this.schemas.set('approval_thresholds', approvalThresholdsSchema);\n    this.schemas.set('email_notifications', emailNotificationsSchema);\n    this.schemas.set('system_settings', systemSettingsSchema);\n  }\n\n  // ============================================================================\n  // Configuration CRUD Operations\n  // ============================================================================\n\n  /**\n   * Get a configuration value with scope inheritance\n   *\n   * Lookup order: USER \u2192 TEAM \u2192 ORG \u2192 GLOBAL\n   *\n   * @example\n   * ```typescript\n   * const branding = await configService.getConfig<BrandingConfig>(\n   *   'branding',\n   *   { scope: ConfigScope.ORGANIZATION, scopeId: 'org-123' }\n   * );\n   * console.log(branding.primaryColor); // \"#FF6B00\"\n   * ```\n   */\n  async getConfig<T = any>(\n    key: string,\n    scope?: { scope: ConfigScope; scopeId?: string }\n  ): Promise<T | null> {\n    const cacheKey = this.getCacheKey(key, scope);\n\n    // Try cache first\n    if (this.cacheEnabled && this.redis) {\n      const cached = await this.redis.get(cacheKey);\n      if (cached) {\n        await this.recordAudit('get', key, undefined, true, { cache: 'hit' });\n        return JSON.parse(cached);\n      }\n    }\n\n    try {\n      // Build scope hierarchy for inheritance\n      const scopes = this.buildScopeHierarchy(scope);\n\n      // Query with scope precedence\n      const result = await this.pool.query<{\n        value: any;\n        is_encrypted: boolean;\n      }>(\n        `SELECT value, is_encrypted\n         FROM configuration_settings\n         WHERE key = $1\n         AND scope = ANY($2)\n         AND (scope_id = $3 OR scope_id IS NULL)\n         AND is_active = true\n         ORDER BY\n           CASE scope\n             WHEN 'user' THEN 1\n             WHEN 'team' THEN 2\n             WHEN 'org' THEN 3\n             WHEN 'global' THEN 4\n           END\n         LIMIT 1`,\n        [key, scopes.map(s => s.scope), scope?.scopeId || null]\n      );\n\n      if (result.rows.length === 0) {\n        await this.recordAudit('get', key, undefined, true, { found: false });\n        return null;\n      }\n\n      let value = result.rows[0].value;\n\n      // Decrypt if encrypted\n      if (result.rows[0].is_encrypted) {\n        value = this.decrypt(value);\n      }\n\n      // Cache the result\n      if (this.cacheEnabled && this.redis) {\n        await this.redis.setex(cacheKey, this.cacheTtl, JSON.stringify(value));\n      }\n\n      await this.recordAudit('get', key, undefined, true, { cache: 'miss' });\n      return value as T;\n    } catch (error) {\n      await this.recordAudit('get', key, undefined, false, {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Set a configuration value with automatic versioning\n   *\n   * @example\n   * ```typescript\n   * const version = await configService.setConfig(\n   *   'branding',\n   *   { logo: 'https://example.com/logo.png', primaryColor: '#FF6B00' },\n   *   { scope: ConfigScope.ORGANIZATION, scopeId: 'org-123' },\n   *   'user-456',\n   *   'Updated branding colors'\n   * );\n   * console.log('Created version:', version.version);\n   * ```\n   */\n  async setConfig<T = any>(\n    key: string,\n    value: T,\n    scope: { scope: ConfigScope; scopeId?: string },\n    userId: string,\n    comment?: string\n  ): Promise<ConfigVersion> {\n    const client = await this.pool.connect();\n\n    try {\n      await client.query('BEGIN');\n\n      // Validate against schema if exists\n      const validationResult = await this.validateConfig(key, value);\n      if (!validationResult.valid) {\n        throw new Error(\n          `Validation failed: ${validationResult.errors?.map(e => e.message).join(', ')}`\n        );\n      }\n\n      // Get current value for diff calculation\n      const currentResult = await client.query<{ value: any; current_version: string }>(\n        `SELECT value, current_version\n         FROM configuration_settings\n         WHERE key = $1 AND scope = $2 AND (scope_id = $3 OR (scope_id IS NULL AND $3 IS NULL))`,\n        [key, scope.scope, scope.scopeId || null]\n      );\n\n      const previousValue = currentResult.rows[0]?.value || null;\n      const previousVersion = currentResult.rows[0]?.current_version;\n\n      // Determine if value should be encrypted\n      const shouldEncrypt = this.shouldEncrypt(key);\n      const storedValue = shouldEncrypt ? this.encrypt(value) : value;\n\n      // Generate new version\n      const version = this.generateVersion(key, value);\n\n      // Calculate diff\n      const diff = previousValue ? this.calculateDiff(previousValue, value) : null;\n\n      // Determine impact level\n      const impactLevel = await this.determineImpactLevel(key, value);\n\n      // Check if approval is required\n      const schema = await this.getSchema(key);\n      if (schema?.requiresApproval && impactLevel !== ImpactLevel.NONE && impactLevel !== ImpactLevel.LOW) {\n        // Create change request instead of applying directly\n        await client.query('ROLLBACK');\n        const requestId = await this.requestChange({\n          key,\n          currentValue: previousValue,\n          proposedValue: value,\n          scope: scope.scope,\n          scopeId: scope.scopeId,\n          requestedBy: userId,\n          justification: comment || 'Configuration change',\n          impactLevel\n        } as any);\n\n        throw new Error(\n          `This change requires approval. Change request created: ${requestId}`\n        );\n      }\n\n      // Insert or update configuration_settings\n      await client.query(\n        `INSERT INTO configuration_settings\n         (key, value, scope, scope_id, current_version, is_encrypted, updated_by)\n         VALUES ($1, $2, $3, $4, $5, $6, $7)\n         ON CONFLICT (key, scope, scope_id)\n         DO UPDATE SET\n           value = EXCLUDED.value,\n           current_version = EXCLUDED.current_version,\n           is_encrypted = EXCLUDED.is_encrypted,\n           updated_by = EXCLUDED.updated_by,\n           updated_at = NOW()`,\n        [key, storedValue, scope.scope, scope.scopeId || null, version, shouldEncrypt, userId]\n      );\n\n      // Insert version history\n      const versionResult = await client.query<ConfigVersion>(\n        `INSERT INTO configuration_versions\n         (key, value, version, previous_version, scope, scope_id, impact_level,\n          changed_by, comment, diff)\n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\n         RETURNING\n           id, key, value, version, previous_version, scope, scope_id::text as \"scopeId\",\n           impact_level as \"impactLevel\", changed_by as \"changedBy\",\n           changed_at as \"changedAt\", comment, tags, is_rollback as \"isRollback\",\n           rollback_from_version as \"rollbackFromVersion\", diff`,\n        [\n          key,\n          value,\n          version,\n          previousVersion || null,\n          scope.scope,\n          scope.scopeId || null,\n          impactLevel,\n          userId,\n          comment || null,\n          diff ? JSON.stringify(diff) : null\n        ]\n      );\n\n      await client.query('COMMIT');\n\n      // Invalidate cache\n      if (this.cacheEnabled && this.redis) {\n        await this.invalidateCache(key);",
  "timestamp": "2026-01-18T16:21:48.527199"
}