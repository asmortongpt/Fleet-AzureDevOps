{
  "agent_id": 9,
  "name": "Integrations Health",
  "file": "api/src/routes/integrations-health.ts",
  "status": "success",
  "content": "/**\n * Integrations Health Check API Routes\n * Provides real-time connectivity status for all external integrations\n *\n * SECURITY:\n * - All routes require JWT authentication\n * - Admin-only access\n * - No secrets exposed in responses\n */\n\nimport { Router, Request, Response } from 'express';\nimport axios from 'axios';\nimport { authenticateJWT } from '../middleware/auth.middleware';\nimport { requireRBAC, Role } from '../middleware/rbac';\nimport { asyncHandler } from '../middleware/async-handler';\nimport logger from '../config/logger';\nimport { pool } from '../db/connection';\nimport { cache } from '../utils/cache';\n\nconst router = Router();\n\n// All routes require authentication and admin role\nrouter.use(authenticateJWT);\nrouter.use(requireRBAC({ roles: [Role.ADMIN], permissions: [], enforceTenantIsolation: false }));\n\n/**\n * Integration Health Status Interface\n */\ninterface IntegrationHealth {\n  name: string;\n  status: 'healthy' | 'degraded' | 'down' | 'unknown';\n  configured: boolean;\n  lastCheck: string;\n  lastSuccess?: string;\n  responseTime?: number;\n  errorMessage?: string;\n  technicalDetails?: string;\n  requiredConfig: string[];\n  optionalConfig: string[];\n  capabilities?: string[];\n}\n\n/**\n * GET /api/integrations/health\n * Returns health status for all integrations\n */\nrouter.get('/health',\n  asyncHandler(async (req: Request, res: Response) => {\n    logger.info('Checking health of all integrations');\n\n    const checks = await Promise.allSettled([\n      checkGoogleMaps(),\n      checkOpenAI(),\n      checkAzureAD(),\n      checkSmartCar(),\n      checkRedis(),\n      checkDatabase()\n    ]);\n\n    const results: IntegrationHealth[] = checks.map((result, index) => {\n      if (result.status === 'fulfilled') {\n        return result.value;\n      } else {\n        const names = ['Google Maps', 'OpenAI', 'Azure AD', 'SmartCar', 'Redis', 'Database'];\n        return {\n          name: names[index],\n          status: 'unknown' as const,\n          configured: false,\n          lastCheck: new Date().toISOString(),\n          errorMessage: 'Health check failed',\n          technicalDetails: result.reason?.message,\n          requiredConfig: [],\n          optionalConfig: []\n        };\n      }\n    });\n\n    res.json({\n      timestamp: new Date().toISOString(),\n      integrations: results,\n      summary: {\n        total: results.length,\n        healthy: results.filter(r => r.status === 'healthy').length,\n        degraded: results.filter(r => r.status === 'degraded').length,\n        down: results.filter(r => r.status === 'down').length,\n        unknown: results.filter(r => r.status === 'unknown').length\n      }\n    });\n  })\n);\n\n/**\n * GET /api/integrations/health/:integration\n * Returns detailed health status for a specific integration\n */\nrouter.get('/health/:integration',\n  asyncHandler(async (req: Request, res: Response) => {\n    const { integration } = req.params;\n    logger.info(`Checking health of ${integration}`);\n\n    let result: IntegrationHealth;\n\n    switch (integration.toLowerCase()) {\n      case 'google-maps':\n        result = await checkGoogleMaps();\n        break;\n      case 'openai':\n        result = await checkOpenAI();\n        break;\n      case 'azure-ad':\n        result = await checkAzureAD();\n        break;\n      case 'smartcar':\n        result = await checkSmartCar();\n        break;\n      case 'redis':\n        result = await checkRedis();\n        break;\n      case 'database':\n        result = await checkDatabase();\n        break;\n      default:\n        return res.status(404).json({ error: 'Integration not found' });\n    }\n\n    res.json(result);\n  })\n);\n\n/**\n * GET /api/integrations/google-maps/status\n * Returns Google Maps integration status\n */\nrouter.get('/google-maps/status',\n  asyncHandler(async (req: Request, res: Response) => {\n    logger.info('Checking Google Maps status');\n\n    const result = await checkGoogleMaps();\n\n    res.json({\n      integration: 'Google Maps',\n      status: result.status,\n      configured: result.configured,\n      lastCheck: result.lastCheck,\n      lastSuccess: result.lastSuccess,\n      responseTime: result.responseTime,\n      errorMessage: result.errorMessage,\n      capabilities: result.capabilities,\n      timestamp: new Date().toISOString()\n    });\n  })\n);\n\n/**\n * POST /api/integrations/health/:integration/test\n * Performs a live test of the integration with detailed results\n */\nrouter.post('/health/:integration/test',\n  asyncHandler(async (req: Request, res: Response) => {\n    const { integration } = req.params;\n    logger.info(`Testing integration: ${integration}`);\n\n    let testResult: any;\n\n    switch (integration.toLowerCase()) {\n      case 'google-maps':\n        testResult = await testGoogleMaps(req.body);\n        break;\n      case 'openai':\n        testResult = await testOpenAI(req.body);\n        break;\n      case 'azure-ad':\n        testResult = await testAzureAD(req.body);\n        break;\n      default:\n        return res.status(404).json({ error: 'Integration test not available' });\n    }\n\n    res.json(testResult);\n  })\n);\n\n/**\n * Google Maps Health Check\n */\nasync function checkGoogleMaps(): Promise<IntegrationHealth> {\n  const apiKey = process.env.GOOGLE_MAPS_API_KEY || process.env.VITE_GOOGLE_MAPS_API_KEY;\n  const startTime = Date.now();\n\n  const health: IntegrationHealth = {\n    name: 'Google Maps',\n    status: 'unknown',\n    configured: !!apiKey,\n    lastCheck: new Date().toISOString(),\n    requiredConfig: ['GOOGLE_MAPS_API_KEY'],\n    optionalConfig: [],\n    capabilities: ['Geocoding', 'Directions', 'Places', 'Maps JavaScript API']\n  };\n\n  if (!apiKey) {\n    health.status = 'down';\n    health.errorMessage = 'API key not configured';\n    health.technicalDetails = 'Missing GOOGLE_MAPS_API_KEY environment variable';\n    return health;\n  }\n\n  try {\n    // Test geocoding API\n    const response = await axios.get('https://maps.googleapis.com/maps/api/geocode/json', {\n      params: {\n        address: '1600 Amphitheatre Parkway, Mountain View, CA',\n        key: apiKey\n      },\n      timeout: 5000\n    });\n\n    health.responseTime = Date.now() - startTime;\n\n    if (response.data.status === 'OK') {\n      health.status = 'healthy';\n      health.lastSuccess = new Date().toISOString();\n    } else if (response.data.status === 'REQUEST_DENIED') {\n      health.status = 'down';\n      health.errorMessage = 'API key invalid or restricted';\n      health.technicalDetails = response.data.error_message || 'API request denied';\n    } else {\n      health.status = 'degraded';\n      health.errorMessage = `API returned status: ${response.data.status}`;\n      health.technicalDetails = response.data.error_message;\n    }\n  } catch (error: any) {\n    health.status = 'down';\n    health.errorMessage = 'Unable to connect to Google Maps API';\n    health.technicalDetails = error.message;\n  }\n\n  return health;\n}\n\n/**\n * OpenAI Health Check\n */\nasync function checkOpenAI(): Promise<IntegrationHealth> {\n  const apiKey = process.env.OPENAI_API_KEY || process.env.VITE_OPENAI_API_KEY;\n  const startTime = Date.now();\n\n  const health: IntegrationHealth = {\n    name: 'OpenAI',\n    status: 'unknown',\n    configured: !!apiKey,\n    lastCheck: new Date().toISOString(),\n    requiredConfig: ['OPENAI_API_KEY'],\n    optionalConfig: ['OPENAI_SERVICE_ACCOUNT'],\n    capabilities: ['Text Generation', 'Embeddings', 'Image Generation']\n  };\n\n  if (!apiKey) {\n    health.status = 'down';\n    health.errorMessage = 'API key not configured';\n    health.technicalDetails = 'Missing OPENAI_API_KEY environment variable';\n    return health;\n  }\n\n  try {\n    // Test models endpoint (lightweight check)\n    const response = await axios.get('https://api.openai.com/v1/models', {\n      headers: {\n        'Authorization': `Bearer ${apiKey}`\n      },\n      timeout: 5000\n    });\n\n    health.responseTime = Date.now() - startTime;\n\n    if (response.status === 200) {\n      health.status = 'healthy';\n      health.lastSuccess = new Date().toISOString();\n    } else {\n      health.status = 'degraded';\n      health.errorMessage = `Unexpected status code: ${response.status}`;\n    }\n  } catch (error: any) {\n    health.status = 'down';\n\n    if (error.response?.status === 401) {\n      health.errorMessage = 'API key invalid or expired';\n      health.technicalDetails = 'Authentication failed - check API key';\n    } else if (error.response?.status === 429) {\n      health.status = 'degraded';\n      health.errorMessage = 'Rate limit exceeded';\n      health.technicalDetails = 'Too many requests - consider implementing rate limiting';\n    } else if (error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT') {\n      health.errorMessage = 'Unable to connect to OpenAI API';\n      health.technicalDetails = 'Network connectivity issue or API endpoint unavailable';\n    } else {\n      health.errorMessage = 'OpenAI API check failed';\n      health.technicalDetails = error.message;\n    }\n  }\n\n  return health;\n}\n\n/**\n * Azure AD Health Check\n */\nasync function checkAzureAD(): Promise<IntegrationHealth> {\n  const clientId = process.env.AZURE_AD_CLIENT_ID || process.env.VITE_AZURE_AD_CLIENT_ID;\n  const tenantId = process.env.AZURE_AD_TENANT_ID || process.env.VITE_AZURE_AD_TENANT_ID;\n  const startTime = Date.now();\n\n  const health: IntegrationHealth = {\n    name: 'Azure AD',\n    status: 'unknown',\n    configured: !!(clientId && tenantId),\n    lastCheck: new Date().toISOString(),\n    requiredConfig: ['AZURE_AD_CLIENT_ID', 'AZURE_AD_TENANT_ID'],\n    optionalConfig: ['AZURE_AD_REDIRECT_URI'],\n    capabilities: ['Authentication', 'User Management', 'SSO']\n  };\n\n  if (!clientId || !tenantId) {\n    health.status = 'down';\n    health.errorMessage = 'Azure AD not fully configured';\n    health.technicalDetails = 'Missing AZURE_AD_CLIENT_ID or AZURE_AD_TENANT_ID';\n    return health;\n  }\n\n  try {\n    // Check OpenID configuration endpoint\n    const response = await axios.get(\n      `https://login.microsoftonline.com/${tenantId}/v2.0/.well-known/openid-configuration`,\n      { timeout: 5000 }\n    );\n\n    health.responseTime = Date.now() - startTime;\n\n    if (response.status === 200 && response.data.authorization_endpoint) {\n      health.status = 'healthy';\n      health.lastSuccess = new Date().toISOString();\n    } else {\n      health.status = 'degraded';\n      health.errorMessage = 'OpenID configuration incomplete';\n    }\n  } catch (error: any) {\n    health.status = 'down';\n\n    if (error.response?.status === 400) {\n      health.errorMessage = 'Invalid tenant ID';\n      health.technicalDetails = 'The configured tenant ID does not exist';\n    } else {\n      health.errorMessage = 'Unable to connect to Azure AD';\n      health.technicalDetails = error.message;\n    }\n  }\n\n  return health;\n}\n\n/**\n * SmartCar Health Check\n */\nasync function checkSmartCar(): Promise<IntegrationHealth> {\n  const clientId = process.env.SMARTCAR_CLIENT_ID;\n  const clientSecret = process.env.SMARTCAR_CLIENT_SECRET;\n  const startTime = Date.now();\n\n  const health: IntegrationHealth = {\n    name: 'SmartCar',\n    status: 'unknown',\n    configured: !!(clientId && clientSecret),\n    lastCheck: new Date().toISOString(),\n    requiredConfig: ['SMARTCAR_CLIENT_ID', 'SMARTCAR_CLIENT_SECRET'],\n    optionalConfig: ['SMARTCAR_APPLICATION_MANAGEMENT_TOKEN'],\n    capabilities: ['Vehicle Data', 'Telemetry', 'Remote Control']\n  };\n\n  if (!clientId || !clientSecret) {\n    health.status = 'down';\n    health.errorMessage = 'SmartCar credentials not configured';\n    health.technicalDetails = 'Missing SMARTCAR_CLIENT_ID or SMARTCAR_CLIENT_SECRET';\n    return health;\n  }\n\n  try {\n    // Test compatibility endpoint (public endpoint)\n    const response = await axios.get('https://api.smartcar.com/v2.0/compatibility', {\n      params: {\n        vin: '1HGBH41JXMN109186', // Test VIN\n        scope: 'read_vehicle_info'\n      },\n      headers: {\n        'Authorization': `Basic ${Buffer.from(`${clientId}:${clientSecret}`).toString('base64')}`\n      },\n      timeout: 5000\n    });\n\n    health.responseTime = Date.now() - startTime;\n\n    if (response.status === 200) {\n      health.status = 'healthy';\n      health.lastSuccess = new Date().toISOString();\n    } else {\n      health.status = 'degraded';\n      health.errorMessage = `Unexpected response: ${response.status}`;\n    }\n  } catch (error: any) {\n    if (error.response?.status === 401) {\n      health.status = 'down';\n      health.errorMessage = 'Invalid SmartCar credentials';\n      health.technicalDetails = 'Authentication failed - check client ID and secret';\n    } else if (error.response?.status === 404) {\n      // This might be expected if endpoint structure changed\n      health.status = 'degraded';\n      health.errorMessage = 'API endpoint structure may have changed';\n      health.technicalDetails = 'Consider updating integration code';\n    } else {\n      health.status = 'down';\n      health.errorMessage = 'Unable to connect to SmartCar API';\n      health.technicalDetails = error.message;\n    }\n  }\n\n  return health;\n}\n\n/**\n * Redis Health Check\n */\nasync function checkRedis(): Promise<IntegrationHealth> {\n  const startTime = Date.now();\n\n  const health: IntegrationHealth = {\n    name: 'Redis',\n    status: 'unknown',\n    configured: true,\n    lastCheck: new Date().toISOString(),\n    requiredConfig: [],\n    optionalConfig: ['REDIS_URL', 'REDIS_HOST', 'REDIS_PORT'],\n    capabilities: ['Caching', 'Session Storage', 'Rate Limiting']\n  };\n\n  try {\n    if (!cache.isConnected()) {\n      health.status = 'down';\n      health.errorMessage = 'Redis not connected';\n      health.technicalDetails = '",
  "timestamp": "2026-01-18T16:21:48.529907"
}