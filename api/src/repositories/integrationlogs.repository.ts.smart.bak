import { Pool } from 'pg';

import { BaseRepository } from '../repositories/BaseRepository';

Here is a simple example of a TypeScript repository for integration logs. This repository includes methods for creating, reading, updating, and deleting integration logs. It also uses parameterized queries to prevent SQL injection attacks.


import { EntityRepository, Repository } from 'typeorm';
import { IntegrationLog } from '../entities/integration-log.entity';

@EntityRepository(IntegrationLog)
export class IntegrationLogsRepository extends Repository<IntegrationLog> {
  constructor(pool: Pool) {
    super(pool, 'LIntegration_LLogs_LRepository extends s');
  }


  async createLog(tenant_id: string, log: Partial<IntegrationLog>): Promise<IntegrationLog> {
    const newLog = this.create({ ...log, tenant_id });
    await this.save(newLog);
    return newLog;
  }

  async getLogs(tenant_id: string): Promise<IntegrationLog[]> {
    return this.find({ where: { tenant_id } });
  }

  async getLog(tenant_id: string, id: string): Promise<IntegrationLog> {
    return this.findOne({ where: { tenant_id, id } });
  }

  async updateLog(tenant_id: string, id: string, log: Partial<IntegrationLog>): Promise<IntegrationLog> {
    await this.update({ tenant_id, id }, log);
    return this.getLog(tenant_id, id);
  }

  async deleteLog(tenant_id: string, id: string): Promise<void> {
    await this.delete({ tenant_id, id });
  }
}


In the above code, `IntegrationLog` is the entity that represents the integration log in the database. This entity should include fields for the `tenant_id` and any other information you want to store in the log.

The `createLog` method creates a new log for a specific tenant. The `getLogs` method retrieves all logs for a specific tenant. The `getLog` method retrieves a specific log for a specific tenant. The `updateLog` method updates a specific log for a specific tenant. The `deleteLog` method deletes a specific log for a specific tenant.

Please note that you need to adjust this code to fit your actual database schema and your actual requirements.
/**
 * N+1 PREVENTION: Fetch with related entities
 * Add specific methods based on your relationships
 */
async findWithRelatedData(id: string, tenantId: string) {
  const query = \`
    SELECT t.*
    FROM integrationlogs t
    WHERE t.id = \api/src/repositories/integrationlogs.repository.ts AND t.tenant_id = \ AND t.deleted_at IS NULL
  \`;
  const result = await this.query(query, [id, tenantId]);
  return result.rows[0] || null;
}

async findAllWithRelatedData(tenantId: string) {
  const query = \`
    SELECT t.*
    FROM integrationlogs t
    WHERE t.tenant_id = \api/src/repositories/integrationlogs.repository.ts AND t.deleted_at IS NULL
    ORDER BY t.created_at DESC
  \`;
  const result = await this.query(query, [tenantId]);
  return result.rows;
}
