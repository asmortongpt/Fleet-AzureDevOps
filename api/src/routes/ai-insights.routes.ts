/**
 * AI Insights API Routes
 * Endpoints for AI/ML predictions, recommendations, RAG queries, and model management
 */

import express, { Response } from 'express'
import { AuthRequest, authenticateJWT } from '../middleware/auth'
import { requirePermission } from '../middleware/permissions'
import { auditLog } from '../middleware/audit'
import { z } from 'zod'
import fleetCognitionService from '../services/fleet-cognition.service'
import mlDecisionEngineService from '../services/ml-decision-engine.service'
import ragEngineService from '../services/rag-engine.service'
import mlTrainingService from '../services/ml-training.service'
import mcpServerService from '../services/mcp-server.service'
import pool from '../config/database'

const router = express.Router()
router.use(authenticateJWT)

// ============================================================================
// FLEET COGNITION & INSIGHTS
// ============================================================================

/**
 * @openapi
 * /api/ai-insights/cognition/insights:
 *   get:
 *     summary: Get AI-generated fleet insights
 *     description: Retrieve high-level insights generated by the centralized cognition engine
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: severity
 *         schema:
 *           type: string
 *           enum: [info, low, medium, high, critical]
 *       - in: query
 *         name: insight_type
 *         schema:
 *           type: string
 *       - in: query
 *         name: acknowledged
 *         schema:
 *           type: boolean
 *     responses:
 *       200:
 *         description: Insights retrieved successfully
 */
router.get(
  '/cognition/insights',
  requirePermission('report:view:global'),
  auditLog({ action: 'READ', resourceType: 'ai_insights' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const { severity, insight_type, acknowledged } = req.query

      let query = 'SELECT * FROM cognition_insights WHERE tenant_id = $1'
      const params: any[] = [req.user!.tenant_id]
      let paramCount = 1

      if (severity) {
        paramCount++
        query += ` AND severity = $${paramCount}`
        params.push(severity)
      }

      if (insight_type) {
        paramCount++
        query += ` AND insight_type = $${paramCount}`
        params.push(insight_type)
      }

      if (acknowledged !== undefined) {
        paramCount++
        query += ` AND is_acknowledged = $${paramCount}`
        params.push(acknowledged === 'true')
      }

      query += ' ORDER BY created_at DESC LIMIT 100'

      const result = await pool.query(query, params)

      res.json({
        insights: result.rows,
        count: result.rows.length
      })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to retrieve insights', message: error.message })
    }
  }
)

/**
 * @openapi
 * /api/ai-insights/cognition/generate:
 *   post:
 *     summary: Generate new fleet insights
 *     description: Trigger AI analysis to generate new insights
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.post(
  '/cognition/generate',
  requirePermission('report:generate:global'),
  auditLog({ action: 'CREATE', resourceType: 'ai_insights' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const insights = await fleetCognitionService.generateFleetInsights(req.user!.tenant_id)

      res.json({
        insights,
        count: insights.length,
        generated_at: new Date().toISOString()
      })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to generate insights', message: error.message })
    }
  }
)

/**
 * @openapi
 * /api/ai-insights/cognition/health-score:
 *   get:
 *     summary: Get fleet health score
 *     description: Overall fleet health score with component breakdowns
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.get(
  '/cognition/health-score',
  requirePermission('report:view:global'),
  auditLog({ action: 'READ', resourceType: 'ai_insights' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const healthScore = await fleetCognitionService.getFleetHealthScore(req.user!.tenant_id)
      res.json(healthScore)
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to calculate health score', message: error.message })
    }
  }
)

/**
 * @openapi
 * /api/ai-insights/cognition/recommendations:
 *   get:
 *     summary: Get personalized recommendations
 *     description: AI-generated recommendations for fleet optimization
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.get(
  '/cognition/recommendations',
  requirePermission('report:view:global'),
  auditLog({ action: 'READ', resourceType: 'ai_insights' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const context = (req.query.context as any) || 'all'
      const recommendations = await fleetCognitionService.getRecommendations(
        req.user!.tenant_id,
        context
      )

      res.json({
        recommendations,
        context,
        count: recommendations.length
      })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to get recommendations', message: error.message })
    }
  }
)

/**
 * @openapi
 * /api/ai-insights/cognition/patterns:
 *   get:
 *     summary: Get detected patterns
 *     description: Patterns detected across fleet operations
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.get(
  '/cognition/patterns',
  requirePermission('report:view:global'),
  auditLog({ action: 'READ', resourceType: 'ai_insights' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const result = await pool.query(
        `SELECT * FROM detected_patterns
         WHERE tenant_id = $1 AND is_monitored = true
         ORDER BY occurrence_count DESC, last_detected_at DESC
         LIMIT 50`,
        [req.user!.tenant_id]
      )

      res.json({
        patterns: result.rows,
        count: result.rows.length
      })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to retrieve patterns', message: error.message })
    }
  }
)

/**
 * @openapi
 * /api/ai-insights/cognition/anomalies:
 *   get:
 *     summary: Get detected anomalies
 *     description: Anomalies detected in fleet operations
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.get(
  '/cognition/anomalies',
  requirePermission('report:view:global'),
  auditLog({ action: 'READ', resourceType: 'ai_insights' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const { resolved, severity } = req.query

      let query = 'SELECT * FROM anomalies WHERE tenant_id = $1'
      const params: any[] = [req.user!.tenant_id]
      let paramCount = 1

      if (resolved !== undefined) {
        paramCount++
        query += ` AND is_resolved = $${paramCount}`
        params.push(resolved === 'true')
      }

      if (severity) {
        paramCount++
        query += ` AND severity = $${paramCount}`
        params.push(severity)
      }

      query += ' ORDER BY detected_at DESC LIMIT 100'

      const result = await pool.query(query, params)

      res.json({
        anomalies: result.rows,
        count: result.rows.length
      })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to retrieve anomalies', message: error.message })
    }
  }
)

// ============================================================================
// ML PREDICTIONS
// ============================================================================

const MaintenancePredictionSchema = z.object({
  vehicle_id: z.string().uuid()
})

/**
 * @openapi
 * /api/ai-insights/predictions/maintenance:
 *   post:
 *     summary: Predict vehicle maintenance needs
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.post(
  '/predictions/maintenance',
  requirePermission('report:generate:global'),
  auditLog({ action: 'CREATE', resourceType: 'ai_prediction' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const { vehicle_id } = MaintenancePredictionSchema.parse(req.body)

      const prediction = await mlDecisionEngineService.predictMaintenance(
        req.user!.tenant_id,
        vehicle_id
      )

      res.json(prediction)
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: 'Validation error', details: error.errors })
      }
      res.status(500).json({ error: 'Prediction failed', message: error.message })
    }
  }
)

const DriverBehaviorScoreSchema = z.object({
  driver_id: z.string().uuid(),
  period: z.enum(['7d', '30d', '90d']).optional().default('30d')
})

/**
 * @openapi
 * /api/ai-insights/predictions/driver-behavior:
 *   post:
 *     summary: Calculate driver behavior score
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.post(
  '/predictions/driver-behavior',
  requirePermission('report:generate:global'),
  auditLog({ action: 'CREATE', resourceType: 'ai_prediction' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const { driver_id, period } = DriverBehaviorScoreSchema.parse(req.body)

      const score = await mlDecisionEngineService.scoreDriverBehavior(
        req.user!.tenant_id,
        driver_id,
        period
      )

      res.json(score)
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: 'Validation error', details: error.errors })
      }
      res.status(500).json({ error: 'Scoring failed', message: error.message })
    }
  }
)

const IncidentRiskSchema = z.object({
  entity_type: z.enum(['vehicle', 'driver', 'route']),
  entity_id: z.string()
})

/**
 * @openapi
 * /api/ai-insights/predictions/incident-risk:
 *   post:
 *     summary: Predict incident risk
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.post(
  '/predictions/incident-risk',
  requirePermission('report:generate:global'),
  auditLog({ action: 'CREATE', resourceType: 'ai_prediction' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const { entity_type, entity_id } = IncidentRiskSchema.parse(req.body)

      const prediction = await mlDecisionEngineService.predictIncidentRisk(
        req.user!.tenant_id,
        entity_type,
        entity_id
      )

      res.json(prediction)
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: 'Validation error', details: error.errors })
      }
      res.status(500).json({ error: 'Prediction failed', message: error.message })
    }
  }
)

const CostForecastSchema = z.object({
  forecast_period: z.enum(['week', 'month', 'quarter'])
})

/**
 * @openapi
 * /api/ai-insights/predictions/cost-forecast:
 *   post:
 *     summary: Forecast fleet costs
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.post(
  '/predictions/cost-forecast',
  requirePermission('report:generate:global'),
  auditLog({ action: 'CREATE', resourceType: 'ai_prediction' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const { forecast_period } = CostForecastSchema.parse(req.body)

      const forecast = await mlDecisionEngineService.forecastCosts(
        req.user!.tenant_id,
        forecast_period
      )

      res.json(forecast)
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: 'Validation error', details: error.errors })
      }
      res.status(500).json({ error: 'Forecasting failed', message: error.message })
    }
  }
)

/**
 * @openapi
 * /api/ai-insights/predictions/{id}/outcome:
 *   put:
 *     summary: Record actual outcome for prediction
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.put(
  '/predictions/:id/outcome',
  requirePermission('report:generate:global'),
  auditLog({ action: 'UPDATE', resourceType: 'ai_prediction' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const { actual_outcome } = req.body

      await mlDecisionEngineService.recordActualOutcome(
        req.params.id,
        req.user!.tenant_id,
        actual_outcome,
        req.user!.id
      )

      res.json({ message: 'Outcome recorded successfully' })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to record outcome', message: error.message })
    }
  }
)

// ============================================================================
// RAG SYSTEM
// ============================================================================

const RAGQuerySchema = z.object({
  query: z.string().min(3),
  context_type: z.string().optional(),
  max_chunks: z.number().min(1).max(20).optional(),
  similarity_threshold: z.number().min(0).max(1).optional()
})

/**
 * @openapi
 * /api/ai-insights/rag/query:
 *   post:
 *     summary: Query the RAG system
 *     description: Semantic search and Q&A over fleet knowledge base
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.post(
  '/rag/query',
  requirePermission('report:view:global'),
  auditLog({ action: 'READ', resourceType: 'rag_query' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const queryData = RAGQuerySchema.parse(req.body)

      const response = await ragEngineService.query(
        req.user!.tenant_id,
        req.user!.id,
        queryData
      )

      res.json(response)
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: 'Validation error', details: error.errors })
      }
      res.status(500).json({ error: 'RAG query failed', message: error.message })
    }
  }
)

const IndexDocumentSchema = z.object({
  document_type: z.string(),
  document_id: z.string().optional(),
  document_title: z.string(),
  document_source: z.string().optional(),
  content: z.string().min(10),
  metadata: z.record(z.any()).optional()
})

/**
 * @openapi
 * /api/ai-insights/rag/index:
 *   post:
 *     summary: Index document into RAG system
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.post(
  '/rag/index',
  requirePermission('report:generate:global'),
  auditLog({ action: 'CREATE', resourceType: 'rag_document' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const document = IndexDocumentSchema.parse(req.body)

      const result = await ragEngineService.indexDocument(req.user!.tenant_id, document)

      res.json({
        message: 'Document indexed successfully',
        ...result
      })
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: 'Validation error', details: error.errors })
      }
      res.status(500).json({ error: 'Indexing failed', message: error.message })
    }
  }
)

/**
 * @openapi
 * /api/ai-insights/rag/feedback:
 *   post:
 *     summary: Provide feedback on RAG response
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.post(
  '/rag/feedback',
  requirePermission('report:view:global'),
  auditLog({ action: 'CREATE', resourceType: 'rag_feedback' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const { query_id, was_helpful, feedback } = req.body

      await ragEngineService.provideFeedback(
        query_id,
        req.user!.tenant_id,
        was_helpful,
        feedback
      )

      res.json({ message: 'Feedback recorded' })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to record feedback', message: error.message })
    }
  }
)

/**
 * @openapi
 * /api/ai-insights/rag/stats:
 *   get:
 *     summary: Get RAG system statistics
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.get(
  '/rag/stats',
  requirePermission('report:view:global'),
  auditLog({ action: 'READ', resourceType: 'rag_stats' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const stats = await ragEngineService.getStatistics(req.user!.tenant_id)
      res.json(stats)
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to retrieve stats', message: error.message })
    }
  }
)

// ============================================================================
// ML MODELS & TRAINING
// ============================================================================

/**
 * @openapi
 * /api/ai-insights/models:
 *   get:
 *     summary: Get all ML models
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.get(
  '/models',
  requirePermission('report:view:global'),
  auditLog({ action: 'READ', resourceType: 'ml_model' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const { model_type, is_active } = req.query

      let query = 'SELECT * FROM ml_models WHERE tenant_id = $1'
      const params: any[] = [req.user!.tenant_id]
      let paramCount = 1

      if (model_type) {
        paramCount++
        query += ` AND model_type = $${paramCount}`
        params.push(model_type)
      }

      if (is_active !== undefined) {
        paramCount++
        query += ` AND is_active = $${paramCount}`
        params.push(is_active === 'true')
      }

      query += ' ORDER BY created_at DESC'

      const result = await pool.query(query, params)

      res.json({
        models: result.rows,
        count: result.rows.length
      })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to retrieve models', message: error.message })
    }
  }
)

/**
 * @openapi
 * /api/ai-insights/models/{id}/performance:
 *   get:
 *     summary: Get model performance metrics
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.get(
  '/models/:id/performance',
  requirePermission('report:view:global'),
  auditLog({ action: 'READ', resourceType: 'ml_model' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const performance = await mlTrainingService.getModelPerformanceHistory(
        req.params.id,
        req.user!.tenant_id
      )

      res.json({
        model_id: req.params.id,
        performance_history: performance
      })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to retrieve performance', message: error.message })
    }
  }
)

/**
 * @openapi
 * /api/ai-insights/models/{id}/deploy:
 *   post:
 *     summary: Deploy model to production
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.post(
  '/models/:id/deploy',
  requirePermission('report:generate:global'),
  auditLog({ action: 'UPDATE', resourceType: 'ml_model' }),
  async (req: AuthRequest, res: Response) => {
    try {
      await mlTrainingService.deployModel(req.params.id, req.user!.tenant_id, req.user!.id)

      res.json({ message: 'Model deployed successfully' })
    } catch (error: any) {
      res.status(500).json({ error: 'Deployment failed', message: error.message })
    }
  }
)

/**
 * @openapi
 * /api/ai-insights/training/jobs:
 *   get:
 *     summary: Get training job history
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.get(
  '/training/jobs',
  requirePermission('report:view:global'),
  auditLog({ action: 'READ', resourceType: 'training_job' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const result = await pool.query(
        `SELECT * FROM training_jobs
         WHERE tenant_id = $1
         ORDER BY created_at DESC
         LIMIT 50`,
        [req.user!.tenant_id]
      )

      res.json({
        jobs: result.rows,
        count: result.rows.length
      })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to retrieve jobs', message: error.message })
    }
  }
)

export default router
