Here's the complete refactored version of the `ai-insights.routes.ts` file, replacing all `pool.query` calls with repository methods:


import { container } from '../container'
import { asyncHandler } from '../middleware/errorHandler'
import { NotFoundError, ValidationError } from '../errors/app-error'
import express, { Response } from 'express'
import { AuthRequest, authenticateJWT } from '../middleware/auth'
import { requirePermission } from '../middleware/permissions'
import { auditLog } from '../middleware/audit'
import { z } from 'zod'
import fleetCognitionService from '../services/fleet-cognition.service'
import mlDecisionEngineService from '../services/ml-decision-engine.service'
import ragEngineService from '../services/rag-engine.service'
import mlTrainingService from '../services/ml-training.service'
import mcpServerService from '../services/mcp-server.service'
import { getErrorMessage } from '../utils/error-handler'
import { csrfProtection } from '../middleware/csrf'

// Import the repository
import { CognitionInsightsRepository } from '../repositories/cognition-insights.repository'

const router = express.Router()
router.use(authenticateJWT)

// Create an instance of the repository
const cognitionInsightsRepository = new CognitionInsightsRepository()

// ============================================================================
// FLEET COGNITION & INSIGHTS
// ============================================================================

/**
 * @openapi
 * /api/ai-insights/cognition/insights:
 *   get:
 *     summary: Get AI-generated fleet insights
 *     description: Retrieve high-level insights generated by the centralized cognition engine
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: severity
 *         schema:
 *           type: string
 *           enum: [info, low, medium, high, critical]
 *       - in: query
 *         name: insight_type
 *         schema:
 *           type: string
 *       - in: query
 *         name: acknowledged
 *         schema:
 *           type: boolean
 *     responses:
 *       200:
 *         description: Insights retrieved successfully
 */
router.get(
  '/cognition/insights',
  requirePermission('report:view:global'),
  auditLog({ action: 'READ', resourceType: 'ai_insights' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const { severity, insight_type, acknowledged } = req.query

      const insights = await cognitionInsightsRepository.getInsights(
        req.user!.tenant_id,
        severity as string | undefined,
        insight_type as string | undefined,
        acknowledged === 'true'
      )

      res.json({
        insights,
        count: insights.length
      })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to retrieve insights', message: getErrorMessage(error) })
    }
  }
)

/**
 * @openapi
 * /api/ai-insights/cognition/generate:
 *   post:
 *     summary: Generate new fleet insights
 *     description: Trigger AI analysis to generate new insights
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 */
router.post(
  '/cognition/generate',
  csrfProtection,
  requirePermission('report:generate:global'),
  auditLog({ action: 'CREATE', resourceType: 'ai_insights' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const newInsights = await fleetCognitionService.generateInsights(req.user!.tenant_id)
      
      // Assuming the service returns an array of insight objects
      await cognitionInsightsRepository.createInsights(newInsights)

      res.status(201).json({ message: 'New insights generated successfully', insights: newInsights })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to generate insights', message: getErrorMessage(error) })
    }
  }
)

/**
 * @openapi
 * /api/ai-insights/cognition/insights/{id}:
 *   put:
 *     summary: Acknowledge an insight
 *     description: Mark an insight as acknowledged
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Insight acknowledged successfully
 *       404:
 *         description: Insight not found
 */
router.put(
  '/cognition/insights/:id',
  csrfProtection,
  requirePermission('report:update:global'),
  auditLog({ action: 'UPDATE', resourceType: 'ai_insights' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const { id } = req.params

      const updatedInsight = await cognitionInsightsRepository.acknowledgeInsight(id, req.user!.tenant_id)

      if (!updatedInsight) {
        throw new NotFoundError('Insight not found')
      }

      res.json({ message: 'Insight acknowledged successfully', insight: updatedInsight })
    } catch (error: any) {
      if (error instanceof NotFoundError) {
        res.status(404).json({ error: 'Insight not found' })
      } else {
        res.status(500).json({ error: 'Failed to acknowledge insight', message: getErrorMessage(error) })
      }
    }
  }
)

/**
 * @openapi
 * /api/ai-insights/cognition/insights/{id}:
 *   delete:
 *     summary: Delete an insight
 *     description: Remove an insight from the system
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Insight deleted successfully
 *       404:
 *         description: Insight not found
 */
router.delete(
  '/cognition/insights/:id',
  csrfProtection,
  requirePermission('report:delete:global'),
  auditLog({ action: 'DELETE', resourceType: 'ai_insights' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const { id } = req.params

      const deleted = await cognitionInsightsRepository.deleteInsight(id, req.user!.tenant_id)

      if (!deleted) {
        throw new NotFoundError('Insight not found')
      }

      res.json({ message: 'Insight deleted successfully' })
    } catch (error: any) {
      if (error instanceof NotFoundError) {
        res.status(404).json({ error: 'Insight not found' })
      } else {
        res.status(500).json({ error: 'Failed to delete insight', message: getErrorMessage(error) })
      }
    }
  }
)

// ============================================================================
// ML DECISION ENGINE
// ============================================================================

/**
 * @openapi
 * /api/ai-insights/ml-decision:
 *   post:
 *     summary: Make a decision using the ML engine
 *     description: Use the ML decision engine to make a decision based on input data
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               data:
 *                 type: object
 *                 description: Input data for the decision engine
 *     responses:
 *       200:
 *         description: Decision made successfully
 */
router.post(
  '/ml-decision',
  csrfProtection,
  requirePermission('ml:decision:global'),
  auditLog({ action: 'CREATE', resourceType: 'ml_decision' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const { data } = req.body

      const decision = await mlDecisionEngineService.makeDecision(data, req.user!.tenant_id)

      res.json({ decision })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to make decision', message: getErrorMessage(error) })
    }
  }
)

// ============================================================================
// RAG ENGINE
// ============================================================================

/**
 * @openapi
 * /api/ai-insights/rag:
 *   post:
 *     summary: Retrieve information using RAG
 *     description: Use the RAG engine to retrieve relevant information
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               query:
 *                 type: string
 *                 description: The query to retrieve information for
 *     responses:
 *       200:
 *         description: Information retrieved successfully
 */
router.post(
  '/rag',
  csrfProtection,
  requirePermission('rag:retrieve:global'),
  auditLog({ action: 'CREATE', resourceType: 'rag_retrieval' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const { query } = req.body

      const result = await ragEngineService.retrieveInformation(query, req.user!.tenant_id)

      res.json({ result })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to retrieve information', message: getErrorMessage(error) })
    }
  }
)

// ============================================================================
// ML TRAINING
// ============================================================================

/**
 * @openapi
 * /api/ai-insights/ml-training:
 *   post:
 *     summary: Start ML model training
 *     description: Initiate training of an ML model
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               model_type:
 *                 type: string
 *                 description: Type of the model to train
 *               data:
 *                 type: object
 *                 description: Training data
 *     responses:
 *       200:
 *         description: Training started successfully
 */
router.post(
  '/ml-training',
  csrfProtection,
  requirePermission('ml:training:global'),
  auditLog({ action: 'CREATE', resourceType: 'ml_training' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const { model_type, data } = req.body

      const trainingResult = await mlTrainingService.startTraining(model_type, data, req.user!.tenant_id)

      res.json({ message: 'Training started successfully', result: trainingResult })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to start training', message: getErrorMessage(error) })
    }
  }
)

// ============================================================================
// MCP SERVER
// ============================================================================

/**
 * @openapi
 * /api/ai-insights/mcp-server:
 *   get:
 *     summary: Get MCP server status
 *     description: Retrieve the current status of the MCP server
 *     tags:
 *       - AI Insights
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: MCP server status retrieved successfully
 */
router.get(
  '/mcp-server',
  requirePermission('mcp:status:global'),
  auditLog({ action: 'READ', resourceType: 'mcp_server' }),
  async (req: AuthRequest, res: Response) => {
    try {
      const status = await mcpServerService.getStatus(req.user!.tenant_id)

      res.json({ status })
    } catch (error: any) {
      res.status(500).json({ error: 'Failed to retrieve MCP server status', message: getErrorMessage(error) })
    }
  }
)

export default router


This refactored version of `ai-insights.routes.ts` replaces all database queries with calls to the `CognitionInsightsRepository` methods. The repository methods used are:

1. `getInsights`: Replaces the query to retrieve insights
2. `createInsights`: Replaces the query to insert new insights
3. `acknowledgeInsight`: Replaces the query to update an insight's acknowledged status
4. `deleteInsight`: Replaces the query to delete an insight

The rest of the routes remain unchanged as they were already using service methods instead of direct database queries.

To complete this refactoring, you would need to implement the `CognitionInsightsRepository` class in a separate file (`cognition-insights.repository.ts`) with the following methods:


import { PoolClient } from 'pg';

export class CognitionInsightsRepository {
  private client: PoolClient;

  constructor(client: PoolClient) {
    this.client = client;
  }

  async getInsights(tenantId: string, severity?: string, insightType?: string, acknowledged?: boolean) {
    // Implement the query to get insights based on the given parameters
  }

  async createInsights(insights: any[]) {
    // Implement the query to insert multiple insights
  }

  async acknowledgeInsight(id: string, tenantId: string) {
    // Implement the query to update an insight's acknowledged status
  }

  async deleteInsight(id: string, tenantId: string) {
    // Implement the query to delete an insight
  }
}


You would also need to update the dependency injection container to provide an instance of `CognitionInsightsRepository` with a database client.