#!/usr/bin/env tsx
/**
 * Integration Test Generator
 * Generates comprehensive integration tests for all API routes
 * Agent 5: Test Coverage & QA Specialist
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface RouteInfo {
  method: string;
  path: string;
  handler: string;
  requiresAuth: boolean;
}

interface RouteFileInfo {
  fileName: string;
  basePath: string;
  routes: RouteInfo[];
}

function analyzeRouteFile(filePath: string): RouteFileInfo | null {
  const content = fs.readFileSync(filePath, 'utf-8');
  const fileName = path.basename(filePath);

  // Try to extract base path from router definition
  const routerMatch = content.match(/router\.use\(['"`]([^'"`]+)['"`]/);
  const basePath = routerMatch ? routerMatch[1] : `/${fileName.replace('.ts', '')}`;

  // Extract routes
  const routes: RouteInfo[] = [];
  const routeRegex = /router\.(get|post|put|patch|delete)\s*\(\s*['"`]([^'"`]+)['"`]/g;
  let match;

  while ((match = routeRegex.exec(content)) !== null) {
    const method = match[1].toUpperCase();
    const path = match[2];

    // Check if route requires authentication
    const requiresAuth = content.includes('authenticateToken') ||
                         content.includes('requireAuth') ||
                         content.includes('isAuthenticated');

    routes.push({
      method,
      path,
      handler: `${method} ${basePath}${path}`,
      requiresAuth
    });
  }

  if (routes.length === 0) {
    return null;
  }

  return {
    fileName,
    basePath,
    routes
  };
}

function generateIntegrationTest(routeInfo: RouteFileInfo): string {
  const { fileName, basePath, routes } = routeInfo;
  const testName = fileName.replace('.ts', '');

  return `import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import { app } from '../../server';

/**
 * Integration tests for ${basePath} routes
 * Generated by: Agent 5 Test Generator
 * Coverage target: 100% of endpoints
 */

describe('${basePath} API Integration Tests', () => {
  let authToken: string;
  let testTenantId: string;
  let testUserId: string;

  beforeAll(async () => {
    // Setup: Create test tenant and user
    testTenantId = 'test-tenant-' + Date.now();
    testUserId = 'test-user-' + Date.now();

    // Login to get auth token
    const loginResponse = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'test@example.com',
        password: 'TestPassword123!',
      });

    authToken = loginResponse.body.token;
  });

  afterAll(async () => {
    // Cleanup: Remove test data
    // TODO: Implement cleanup logic
  });

${routes.map(route => generateRouteTests(route, basePath)).join('\n\n')}

  // Tenant isolation tests
  describe('Tenant Isolation', () => {
    it('should prevent cross-tenant data access', async () => {
      // Create resource for tenant A
      const resourceA = await request(app)
        .post('${basePath}')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send({
          tenantId: 'tenant-A',
          // TODO: Add resource data
        });

      // Try to access from tenant B
      const responseB = await request(app)
        .get(\`${basePath}/\${resourceA.body.id}\`)
        .set('Authorization', 'Bearer ${authToken for tenant B}')
        .expect(403);
    });
  });

  // Rate limiting tests
  describe('Rate Limiting', () => {
    it('should enforce rate limits', async () => {
      const requests = Array(101).fill(null).map(() =>
        request(app)
          .get('${basePath}')
          .set('Authorization', \`Bearer \${authToken}\`)
      );

      const responses = await Promise.all(requests);
      const rateLimited = responses.filter(r => r.status === 429);

      expect(rateLimited.length).toBeGreaterThan(0);
    });
  });

  // Input validation tests
  describe('Input Validation', () => {
    it('should prevent SQL injection', async () => {
      const response = await request(app)
        .get(\`${basePath}?id=1' OR '1'='1\`)
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(400);
    });

    it('should prevent XSS attacks', async () => {
      const response = await request(app)
        .post('${basePath}')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send({
          name: '<script>alert("XSS")</script>',
        })
        .expect(400);
    });
  });
});
`;
}

function generateRouteTests(route: RouteInfo, basePath: string): string {
  const { method, path, requiresAuth } = route;
  const fullPath = `${basePath}${path}`;
  const routeId = `${method} ${fullPath}`;

  let tests = `  describe('${routeId}', () => {`;

  // Authentication test
  if (requiresAuth) {
    tests += `
    it('should return 401 without authentication', async () => {
      const response = await request(app)
        .${method.toLowerCase()}('${fullPath}')
        .expect(401);

      expect(response.body).toHaveProperty('error');
    });
`;
  }

  // Happy path test
  if (method === 'GET') {
    tests += `
    it('should return data successfully', async () => {
      const response = await request(app)
        .get('${fullPath}')
        ${requiresAuth ? `.set('Authorization', \`Bearer \${authToken}\`)` : ''}
        .expect(200);

      expect(response.body).toBeDefined();
      // TODO: Add specific response validation
    });
`;
  } else if (method === 'POST') {
    tests += `
    it('should create resource successfully', async () => {
      const response = await request(app)
        .post('${fullPath}')
        ${requiresAuth ? `.set('Authorization', \`Bearer \${authToken}\`)` : ''}
        .send({
          // TODO: Add valid request body
          tenantId: testTenantId,
        })
        .expect(201);

      expect(response.body).toHaveProperty('id');
    });

    it('should validate required fields', async () => {
      const response = await request(app)
        .post('${fullPath}')
        ${requiresAuth ? `.set('Authorization', \`Bearer \${authToken}\`)` : ''}
        .send({})
        .expect(400);

      expect(response.body).toHaveProperty('errors');
    });
`;
  } else if (method === 'PUT' || method === 'PATCH') {
    tests += `
    it('should update resource successfully', async () => {
      const response = await request(app)
        .${method.toLowerCase()}('${fullPath}')
        ${requiresAuth ? `.set('Authorization', \`Bearer \${authToken}\`)` : ''}
        .send({
          // TODO: Add valid update data
        })
        .expect(200);

      expect(response.body).toBeDefined();
    });

    it('should return 404 for non-existent resource', async () => {
      const response = await request(app)
        .${method.toLowerCase()}('${fullPath.replace(':id', '99999')}')
        ${requiresAuth ? `.set('Authorization', \`Bearer \${authToken}\`)` : ''}
        .send({})
        .expect(404);
    });
`;
  } else if (method === 'DELETE') {
    tests += `
    it('should delete resource successfully', async () => {
      const response = await request(app)
        .delete('${fullPath}')
        ${requiresAuth ? `.set('Authorization', \`Bearer \${authToken}\`)` : ''}
        .expect(204);
    });

    it('should return 404 for non-existent resource', async () => {
      const response = await request(app)
        .delete('${fullPath.replace(':id', '99999')}')
        ${requiresAuth ? `.set('Authorization', \`Bearer \${authToken}\`)` : ''}
        .expect(404);
    });
`;
  }

  tests += `  });`;
  return tests;
}

async function main() {
  const routesDir = path.join(__dirname, '../src/routes');
  const testsDir = path.join(__dirname, '../tests/integration/routes');

  // Create tests directory
  if (!fs.existsSync(testsDir)) {
    fs.mkdirSync(testsDir, { recursive: true });
  }

  // Get all route files
  const routeFiles = fs.readdirSync(routesDir)
    .filter(file => file.endsWith('.ts') && !file.includes('index'));

  console.log(`\nüß™ Integration Test Generator - Agent 5\n`);
  console.log(`Found ${routeFiles.length} route files\n`);

  let generated = 0;
  let skipped = 0;
  let totalRoutes = 0;

  for (const file of routeFiles) {
    const routePath = path.join(routesDir, file);
    const testFileName = file.replace('.ts', '.integration.test.ts');
    const testPath = path.join(testsDir, testFileName);

    // Skip if test already exists
    if (fs.existsSync(testPath)) {
      console.log(`  ‚è≠Ô∏è  ${file} - test exists`);
      skipped++;
      continue;
    }

    const routeInfo = analyzeRouteFile(routePath);

    if (!routeInfo || routeInfo.routes.length === 0) {
      console.log(`  ‚ö†Ô∏è  ${file} - no routes found`);
      skipped++;
      continue;
    }

    const testContent = generateIntegrationTest(routeInfo);
    fs.writeFileSync(testPath, testContent);

    console.log(`  ‚úÖ ${file} - ${routeInfo.routes.length} routes`);
    generated++;
    totalRoutes += routeInfo.routes.length;
  }

  console.log(`\nüìä Summary:`);
  console.log(`  Generated: ${generated} test files`);
  console.log(`  Total Routes: ${totalRoutes}`);
  console.log(`  Skipped: ${skipped} files`);
  console.log(`  Total: ${routeFiles.length} route files\n`);
  console.log(`‚ö†Ô∏è  Next steps:`);
  console.log(`  1. Review generated tests in ${testsDir}`);
  console.log(`  2. Fill in TODO items with actual test data`);
  console.log(`  3. Run: npm test -- integration`);
  console.log(`  4. Achieve 100% route coverage\n`);
}

main().catch(console.error);
