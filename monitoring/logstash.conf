# Logstash Configuration for CTAFleet
# Collects, parses, and forwards logs to Elasticsearch

input {
  # Receive logs from Beats
  beats {
    port => 5044
  }

  # Receive logs via TCP
  tcp {
    port => 5000
    codec => json
  }

  # Receive logs from Docker
  tcp {
    port => 5001
    codec => json_lines
  }
}

filter {
  # Parse JSON logs
  if [message] =~ /^\{/ {
    json {
      source => "message"
      target => "parsed"
    }
  }

  # Extract timestamp
  date {
    match => [ "timestamp", "ISO8601" ]
    target => "@timestamp"
  }

  # Add environment labels
  mutate {
    add_field => {
      "environment" => "production"
      "cluster" => "ctafleet"
    }
  }

  # Parse application logs
  if [kubernetes][container][name] == "api" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{GREEDYDATA:log_message}" }
    }
    mutate {
      add_field => { "application" => "fleet-api" }
    }
  }

  if [kubernetes][container][name] == "frontend" {
    mutate {
      add_field => { "application" => "fleet-frontend" }
    }
  }

  # Parse PostgreSQL logs
  if [kubernetes][container][name] == "postgres" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{WORD:timezone} \[%{NUMBER:pid}\] %{WORD:user}@%{WORD:database} %{LOGLEVEL:level}: %{GREEDYDATA:log_message}" }
    }
    mutate {
      add_field => { "application" => "postgres" }
    }
  }

  # Parse Redis logs
  if [kubernetes][container][name] == "redis" {
    grok {
      match => { "message" => "%{NUMBER:pid}:%{WORD:role} %{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{GREEDYDATA:log_message}" }
    }
    mutate {
      add_field => { "application" => "redis" }
    }
  }

  # Remove empty fields
  prune {
    whitelist_names => ["^@", "^kubernetes", "^application", "^level", "^log_message", "^environment", "^cluster"]
  }
}

output {
  # Send to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "fleet-logs-%{+YYYY.MM.dd}"
    document_type => "_doc"
  }

  # Debug output (comment out in production)
  # stdout {
  #   codec => rubydebug
  # }
}
