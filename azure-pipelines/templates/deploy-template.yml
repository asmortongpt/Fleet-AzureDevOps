# ============================================================================
# Deploy to Kubernetes Template
# ============================================================================
jobs:
  - job: DeployToProduction
    displayName: 'Deploy to Production'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
      - checkout: self
        displayName: 'Checkout code'
        clean: true

      # ==================================================================
      # Azure Login & AKS Context
      # ==================================================================
      - task: AzureCLI@2
        displayName: 'Get AKS Credentials'
        inputs:
          azureSubscription: 'FleetManagement-ServiceConnection'
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
            az aks get-credentials \
              --resource-group $(aksResourceGroup) \
              --name $(aksCluster) \
              --overwrite-existing

      # ==================================================================
      # Create Namespace (if not exists)
      # ==================================================================
      - script: |
          kubectl create namespace $(namespace) --dry-run=client -o yaml | kubectl apply -f -
        displayName: 'Create namespace if not exists'
        continueOnError: true

      # ==================================================================
      # Fetch secrets from Azure Key Vault
      # ==================================================================
      - task: AzureKeyVault@2
        displayName: 'Fetch secrets from Key Vault'
        inputs:
          azureSubscription: 'FleetManagement-ServiceConnection'
          KeyVaultName: 'fleet-secrets-0d326d71'
          SecretsFilter: '*'
          RunAsPreJob: false
        continueOnError: true

      # ==================================================================
      # Save Current Deployment State (for rollback)
      # ==================================================================
      - script: |
          # Get current image tags
          FLEET_APP_IMAGE=$(kubectl get deployment fleet-app -n $(namespace) -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null || echo "")

          echo "##vso[task.setvariable variable=previousFleetAppImage;isOutput=true]$FLEET_APP_IMAGE"
          echo "Previous Fleet App image: ${FLEET_APP_IMAGE}"

          # Save to file for rollback stage
          mkdir -p $(Build.ArtifactStagingDirectory)
          echo "$FLEET_APP_IMAGE" > $(Build.ArtifactStagingDirectory)/previous-fleet-app-image.txt
        displayName: 'Save current deployment state'
        name: saveState
        continueOnError: true

      - task: PublishPipelineArtifact@1
        displayName: 'Publish deployment state'
        inputs:
          targetPath: '$(Build.ArtifactStagingDirectory)'
          artifact: 'deployment-state'
          publishLocation: 'pipeline'
        continueOnError: true

      # ==================================================================
      # Build and Push Docker Image
      # ==================================================================
      - task: AzureCLI@2
        displayName: 'Build and push Docker image'
        inputs:
          azureSubscription: 'FleetManagement-ServiceConnection'
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
            # Login to ACR
            az acr login --name fleetappregistry

            # Build and push the image
            docker build -t fleetappregistry.azurecr.io/fleet-app:$(Build.BuildId) -f Dockerfile .
            docker push fleetappregistry.azurecr.io/fleet-app:$(Build.BuildId)

            # Also tag as latest
            docker tag fleetappregistry.azurecr.io/fleet-app:$(Build.BuildId) fleetappregistry.azurecr.io/fleet-app:latest
            docker push fleetappregistry.azurecr.io/fleet-app:latest

      # ==================================================================
      # Update Deployment
      # ==================================================================
      - script: |
          echo "Updating fleet-app deployment..."
          kubectl set image deployment/fleet-app \
            fleet-app=fleetappregistry.azurecr.io/fleet-app:$(Build.BuildId) \
            -n $(namespace)

          echo "Setting environment variables..."
          kubectl set env deployment/fleet-app \
            VITE_API_URL=$(productionUrl) \
            VITE_ENVIRONMENT=production \
            VITE_BUILD_VERSION=$(Build.BuildId) \
            -n $(namespace)
        displayName: 'Update fleet-app deployment'

      # ==================================================================
      # Wait for Rollout
      # ==================================================================
      - script: |
          echo "Waiting for rollout to complete..."
          kubectl rollout status deployment/fleet-app -n $(namespace) --timeout=5m
        displayName: 'Wait for rollout'

      # ==================================================================
      # Verify Deployment
      # ==================================================================
      - script: |
          echo "=========================================="
          echo "Deployment Verification"
          echo "=========================================="
          kubectl get pods -n $(namespace) -l app=fleet-app
          kubectl get services -n $(namespace)
          kubectl get ingress -n $(namespace)
          echo "=========================================="

          echo "Checking runtime config..."
          POD=$(kubectl get pods -n $(namespace) -l app=fleet-app -o jsonpath='{.items[0].metadata.name}')
          kubectl exec -n $(namespace) $POD -- cat /usr/share/nginx/html/runtime-config.js || true
        displayName: 'Verify deployment resources'

      # ==================================================================
      # Health Check
      # ==================================================================
      - script: |
          echo "Waiting 30 seconds for services to stabilize..."
          sleep 30

          echo "Testing health endpoint..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" $(productionUrl)/api/health)
          if [ "$HTTP_CODE" = "200" ]; then
            echo "##vso[task.complete result=Succeeded;]Health check passed!"
          else
            echo "##vso[task.logissue type=warning]Health check returned $HTTP_CODE"
          fi

          echo "Testing frontend..."
          FRONTEND_CODE=$(curl -s -o /dev/null -w "%{http_code}" $(productionUrl)/)
          if [ "$FRONTEND_CODE" = "200" ]; then
            echo "##vso[task.complete result=Succeeded;]Frontend check passed!"
          else
            echo "##vso[task.logissue type=warning]Frontend returned $FRONTEND_CODE"
          fi
        displayName: 'Health check'
        continueOnError: true
