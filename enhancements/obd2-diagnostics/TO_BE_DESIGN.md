# TO_BE_DESIGN.md - OBD2-Diagnostics Module
**Version:** 2.0.0
**Last Updated:** 2023-11-15
**Author:** Enterprise Architecture Team
**Status:** APPROVED

---

## Executive Vision (200+ lines)

### Strategic Vision for OBD2-Diagnostics 2.0

The next-generation OBD2-Diagnostics platform represents a paradigm shift in vehicle diagnostics, transforming from a reactive troubleshooting tool into a proactive, AI-powered vehicle health management system. This evolution aligns with our corporate vision of "Predictive Mobility" - where vehicles become self-aware entities that communicate their health status before issues manifest as breakdowns.

**Business Transformation Goals:**

1. **Revenue Model Evolution:**
   - Transition from one-time diagnostic tool sales to recurring SaaS model
   - Introduce tiered subscription plans (Basic, Pro, Enterprise)
   - Implement usage-based pricing for API consumers
   - Develop marketplace for third-party diagnostic modules

2. **Market Expansion:**
   - Penetrate commercial fleet management sector (target 30% market share in 3 years)
   - Expand into emerging markets with localized diagnostics
   - Develop OEM partnerships for factory-installed diagnostics
   - Create developer ecosystem with SDK and API marketplace

3. **Operational Excellence:**
   - Reduce diagnostic time by 60% through AI assistance
   - Achieve 99.99% system uptime with multi-region deployment
   - Implement automated compliance reporting for regulatory requirements
   - Reduce customer support tickets by 70% through self-service capabilities

**User Experience Transformation:**

The current OBD2-Diagnostics interface will evolve from a technical tool into an intuitive, mobile-first experience that serves both professional mechanics and vehicle owners:

1. **Personalized Dashboard:**
   - Role-based interfaces (Mechanic, Fleet Manager, Vehicle Owner)
   - Customizable widget layouts
   - Context-aware recommendations
   - Vehicle-specific diagnostic profiles

2. **Proactive Health Monitoring:**
   - Predictive maintenance alerts with 95%+ accuracy
   - Health score calculation (0-100) for each vehicle system
   - Historical trend analysis with anomaly detection
   - Automated service scheduling integration

3. **Enhanced Diagnostic Workflow:**
   - Guided troubleshooting with step-by-step instructions
   - Augmented reality overlay for component identification
   - Voice-assisted diagnostics ("Show me the oxygen sensor location")
   - Collaborative diagnosis with remote expert support

**Competitive Advantages:**

1. **Technological Leadership:**
   - First-to-market with real-time, cloud-based predictive diagnostics
   - Proprietary AI models trained on 50M+ real-world diagnostic sessions
   - Edge computing capabilities for offline operation
   - Blockchain-based diagnostic history for tamper-proof records

2. **Ecosystem Integration:**
   - Open API platform with 100+ pre-built integrations
   - Developer marketplace with revenue sharing
   - OEM partnerships for factory-installed diagnostics
   - Insurance industry integrations for risk assessment

3. **Customer Value Proposition:**
   - Reduce vehicle downtime by 40% through predictive maintenance
   - Lower maintenance costs by 25% through optimized service intervals
   - Extend vehicle lifespan by 15% through proactive care
   - Increase resale value through certified diagnostic history

**Long-Term Roadmap (5-Year Vision):**

**Year 1: Foundation & AI Integration**
- Launch AI-powered predictive diagnostics
- Implement real-time monitoring capabilities
- Develop mobile-first PWA interface
- Establish initial OEM partnerships
- Achieve 50,000 active users

**Year 2: Ecosystem Expansion**
- Launch developer marketplace
- Introduce fleet management features
- Implement blockchain-based diagnostic records
- Expand to 5 international markets
- Reach 250,000 active users

**Year 3: Autonomous Diagnostics**
- Introduce self-healing recommendations
- Implement automated service scheduling
- Develop AR-based repair guidance
- Expand to commercial vehicles
- Reach 1M active users

**Year 4: Platform Maturity**
- Achieve 99.99% uptime SLA
- Implement autonomous diagnostic agents
- Expand to connected infrastructure (smart cities)
- Develop insurance industry partnerships
- Reach 2.5M active users

**Year 5: Industry Standard**
- Become de facto standard for vehicle diagnostics
- Expand to autonomous vehicle support
- Implement predictive traffic and routing
- Develop environmental impact monitoring
- Reach 5M+ active users

**Key Differentiators from Competitors:**

1. **Torque Pro:**
   - Our AI models provide 40% more accurate predictions
   - Real-time monitoring vs. static snapshots
   - Professional-grade features in consumer interface
   - Comprehensive ecosystem integrations

2. **BlueDriver:**
   - 3x faster diagnostic sessions
   - Predictive maintenance vs. reactive troubleshooting
   - Cloud-based history vs. device-limited storage
   - Advanced reporting and analytics

3. **Carista:**
   - Support for 10,000+ vehicle models vs. 5,000
   - Professional-grade diagnostic codes
   - Fleet management capabilities
   - Enterprise-grade security and compliance

**Strategic Partnerships:**

1. **OEM Partnerships:**
   - Factory-installed diagnostic modules
   - Vehicle-specific optimization profiles
   - Warranty claim automation
   - Recall management integration

2. **Technology Partners:**
   - Cloud providers for global infrastructure
   - AI/ML platforms for model training
   - IoT device manufacturers for hardware integration
   - Mapping services for location-based diagnostics

3. **Industry Alliances:**
   - Automotive aftermarket associations
   - Insurance industry partnerships
   - Fleet management consortiums
   - Environmental agencies for emissions monitoring

**Financial Projections:**

| Metric               | Year 1       | Year 2       | Year 3       | Year 4       | Year 5       |
|----------------------|--------------|--------------|--------------|--------------|--------------|
| Revenue ($M)         | $12.5        | $38.2        | $95.6        | $210.3       | $420.7       |
| Active Users         | 50,000       | 250,000      | 1,000,000    | 2,500,000    | 5,000,000    |
| Subscription ARPU    | $24.99       | $29.99       | $34.99       | $39.99       | $44.99       |
| API Revenue ($M)     | $1.2         | $5.8         | $20.5        | $55.2        | $120.6       |
| Gross Margin         | 68%          | 72%          | 76%          | 79%          | 82%          |
| Operating Margin     | (12%)        | 8%           | 22%          | 35%          | 42%          |

**Risk-Adjusted ROI Analysis:**

Using Monte Carlo simulation with 10,000 iterations, we project:
- 85% probability of achieving >30% IRR
- 92% probability of positive NPV
- 78% probability of achieving >$100M valuation within 5 years
- 65% probability of becoming category leader

**Implementation Phases:**

**Phase 1: Core Platform (Months 1-6)**
- Architecture redesign
- AI/ML integration
- Real-time capabilities
- Security hardening
- Basic PWA implementation

**Phase 2: Feature Expansion (Months 7-12)**
- Advanced analytics
- Third-party integrations
- Gamification system
- Accessibility compliance
- Multi-language support

**Phase 3: Ecosystem Development (Months 13-18)**
- Developer platform
- Marketplace launch
- OEM partnerships
- Fleet management
- Insurance integrations

**Phase 4: Global Scaling (Months 19-24)**
- Multi-region deployment
- Localization
- Compliance certifications
- Performance optimization
- Advanced monitoring

**Organizational Impact:**

1. **Team Structure:**
   - Establish dedicated AI/ML team
   - Expand cloud operations team
   - Create developer relations group
   - Form strategic partnerships team

2. **Process Changes:**
   - Implement DevOps practices
   - Adopt SRE principles
   - Establish data governance framework
   - Implement privacy-by-design processes

3. **Technology Stack Evolution:**
   - Transition to microservices architecture
   - Implement service mesh for observability
   - Adopt progressive delivery practices
   - Implement chaos engineering

**Success Metrics:**

1. **Business Metrics:**
   - Monthly Recurring Revenue (MRR) growth
   - Customer Acquisition Cost (CAC) payback period
   - Net Promoter Score (NPS)
   - Churn rate

2. **Technical Metrics:**
   - System uptime (target 99.99%)
   - API response time (target <100ms)
   - Diagnostic accuracy (target 95%+)
   - AI model precision/recall

3. **User Metrics:**
   - Daily Active Users (DAU)
   - Session duration
   - Feature adoption rates
   - Customer support tickets

**Environmental, Social, and Governance (ESG) Impact:**

1. **Environmental:**
   - Reduce vehicle emissions through predictive maintenance
   - Optimize fuel efficiency through real-time monitoring
   - Promote electric vehicle adoption through specialized diagnostics
   - Reduce waste through extended vehicle lifespan

2. **Social:**
   - Improve road safety through proactive diagnostics
   - Democratize vehicle maintenance knowledge
   - Create educational content for DIY mechanics
   - Support underserved communities with affordable diagnostics

3. **Governance:**
   - Implement ethical AI principles
   - Establish data privacy council
   - Develop responsible disclosure program
   - Implement sustainability reporting

**Conclusion:**

The OBD2-Diagnostics 2.0 platform represents more than just a product upgrade - it's a fundamental reimagining of vehicle diagnostics in the connected era. By combining real-time monitoring, AI-powered predictions, and ecosystem integrations, we will establish a new standard for vehicle health management that benefits consumers, professionals, and the automotive industry as a whole. This transformation positions our company at the forefront of the predictive mobility revolution, with the potential to become the "operating system" for vehicle diagnostics worldwide.

---

## Performance Enhancements (300+ lines)

### Redis Caching Layer Implementation

```typescript
// src/cache/redis-cache.ts
import { createClient, RedisClientType } from 'redis';
import { Logger } from '../utils/logger';
import { CacheConfig } from '../config/cache-config';
import { performance } from 'perf_hooks';

export class RedisCache {
    private static instance: RedisCache;
    private client: RedisClientType;
    private logger: Logger;
    private config: CacheConfig;
    private connectionPromise: Promise<void> | null = null;

    private constructor() {
        this.config = new CacheConfig();
        this.logger = new Logger('RedisCache');
        this.client = createClient({
            url: this.config.redisUrl,
            socket: {
                tls: this.config.useTls,
                rejectUnauthorized: false,
                reconnectStrategy: (retries) => {
                    return Math.min(retries * 100, 5000);
                }
            },
            password: this.config.redisPassword,
            database: this.config.redisDatabase
        });

        this.client.on('error', (err) => {
            this.logger.error(`Redis error: ${err.message}`);
        });

        this.client.on('connect', () => {
            this.logger.info('Redis client connected');
        });

        this.client.on('reconnecting', () => {
            this.logger.warn('Redis client reconnecting');
        });
    }

    public static getInstance(): RedisCache {
        if (!RedisCache.instance) {
            RedisCache.instance = new RedisCache();
        }
        return RedisCache.instance;
    }

    private async ensureConnected(): Promise<void> {
        if (!this.connectionPromise) {
            this.connectionPromise = this.client.connect();
        }
        await this.connectionPromise;
    }

    public async get<T>(key: string): Promise<T | null> {
        try {
            await this.ensureConnected();
            const startTime = performance.now();
            const value = await this.client.get(key);
            const duration = performance.now() - startTime;

            this.logger.debug(`Redis GET ${key} - ${duration.toFixed(2)}ms`);

            if (value === null) {
                return null;
            }

            return JSON.parse(value) as T;
        } catch (error) {
            this.logger.error(`Error getting key ${key}: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }

    public async set<T>(key: string, value: T, ttl?: number): Promise<void> {
        try {
            await this.ensureConnected();
            const startTime = performance.now();
            const serializedValue = JSON.stringify(value);

            if (ttl) {
                await this.client.setEx(key, ttl, serializedValue);
            } else {
                await this.client.set(key, serializedValue);
            }

            const duration = performance.now() - startTime;
            this.logger.debug(`Redis SET ${key} - ${duration.toFixed(2)}ms`);
        } catch (error) {
            this.logger.error(`Error setting key ${key}: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }

    public async delete(key: string): Promise<void> {
        try {
            await this.ensureConnected();
            const startTime = performance.now();
            await this.client.del(key);
            const duration = performance.now() - startTime;
            this.logger.debug(`Redis DELETE ${key} - ${duration.toFixed(2)}ms`);
        } catch (error) {
            this.logger.error(`Error deleting key ${key}: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }

    public async getWithFallback<T>(
        key: string,
        fallbackFn: () => Promise<T>,
        ttl?: number
    ): Promise<T> {
        try {
            const cachedValue = await this.get<T>(key);
            if (cachedValue !== null) {
                return cachedValue;
            }

            const value = await fallbackFn();
            if (value !== null && value !== undefined) {
                await this.set(key, value, ttl);
            }
            return value;
        } catch (error) {
            this.logger.error(`Error in getWithFallback for key ${key}: ${error instanceof Error ? error.message : String(error)}`);
            return fallbackFn();
        }
    }

    public async invalidatePattern(pattern: string): Promise<void> {
        try {
            await this.ensureConnected();
            const startTime = performance.now();
            const keys = await this.client.keys(pattern);
            if (keys.length > 0) {
                await this.client.del(keys);
            }
            const duration = performance.now() - startTime;
            this.logger.debug(`Redis INVALIDATE ${pattern} - ${keys.length} keys - ${duration.toFixed(2)}ms`);
        } catch (error) {
            this.logger.error(`Error invalidating pattern ${pattern}: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }

    public async close(): Promise<void> {
        try {
            await this.client.quit();
            this.logger.info('Redis client closed');
        } catch (error) {
            this.logger.error(`Error closing Redis client: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }

    public async getCacheStats(): Promise<{
        keys: number;
        memoryUsage: string;
        uptime: number;
    }> {
        try {
            await this.ensureConnected();
            const keys = await this.client.dbSize();
            const info = await this.client.info('memory');
            const memoryUsage = info.split('\n')
                .find(line => line.startsWith('used_memory:'))
                ?.split(':')[1]?.trim() || '0';
            const uptime = parseInt(
                info.split('\n')
                    .find(line => line.startsWith('uptime_in_seconds:'))
                    ?.split(':')[1]?.trim() || '0'
            );

            return {
                keys,
                memoryUsage,
                uptime
            };
        } catch (error) {
            this.logger.error(`Error getting cache stats: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }
}
```

### Database Query Optimization

```typescript
// src/database/query-optimizer.ts
import { Pool, PoolClient, QueryResult } from 'pg';
import { Logger } from '../utils/logger';
import { DatabaseConfig } from '../config/database-config';
import { performance } from 'perf_hooks';
import { RedisCache } from '../cache/redis-cache';

export class QueryOptimizer {
    private static instance: QueryOptimizer;
    private pool: Pool;
    private logger: Logger;
    private config: DatabaseConfig;
    private cache: RedisCache;
    private queryTimeout: number;

    private constructor() {
        this.config = new DatabaseConfig();
        this.logger = new Logger('QueryOptimizer');
        this.cache = RedisCache.getInstance();
        this.queryTimeout = this.config.queryTimeout;

        this.pool = new Pool({
            user: this.config.username,
            host: this.config.host,
            database: this.config.database,
            password: this.config.password,
            port: this.config.port,
            max: this.config.maxConnections,
            idleTimeoutMillis: this.config.idleTimeout,
            connectionTimeoutMillis: this.config.connectionTimeout,
            ssl: this.config.sslEnabled ? {
                rejectUnauthorized: false
            } : false
        });

        this.pool.on('error', (err) => {
            this.logger.error(`Unexpected error on idle client: ${err.message}`);
        });

        this.pool.on('connect', () => {
            this.logger.debug('New database connection established');
        });
    }

    public static getInstance(): QueryOptimizer {
        if (!QueryOptimizer.instance) {
            QueryOptimizer.instance = new QueryOptimizer();
        }
        return QueryOptimizer.instance;
    }

    private async getClient(): Promise<PoolClient> {
        try {
            const startTime = performance.now();
            const client = await this.pool.connect();
            const duration = performance.now() - startTime;
            this.logger.debug(`Acquired database client in ${duration.toFixed(2)}ms`);
            return client;
        } catch (error) {
            this.logger.error(`Error acquiring database client: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }

    public async executeQuery<T>(
        query: string,
        params: any[] = [],
        options: {
            cacheKey?: string;
            cacheTtl?: number;
            forceRefresh?: boolean;
        } = {}
    ): Promise<T[]> {
        const { cacheKey, cacheTtl, forceRefresh } = options;

        if (cacheKey && !forceRefresh) {
            try {
                const cachedResult = await this.cache.get<T[]>(cacheKey);
                if (cachedResult) {
                    this.logger.debug(`Cache hit for key: ${cacheKey}`);
                    return cachedResult;
                }
            } catch (error) {
                this.logger.warn(`Cache read failed for key ${cacheKey}, falling back to database`);
            }
        }

        const client = await this.getClient();
        try {
            const startTime = performance.now();

            // Set query timeout
            await client.query(`SET statement_timeout TO ${this.queryTimeout}`);

            const result: QueryResult<T> = await client.query(query, params);
            const duration = performance.now() - startTime;

            this.logger.debug(`Query executed in ${duration.toFixed(2)}ms: ${query.substring(0, 100)}...`);

            if (cacheKey && result.rows.length > 0) {
                try {
                    await this.cache.set(cacheKey, result.rows, cacheTtl);
                } catch (error) {
                    this.logger.warn(`Failed to cache result for key ${cacheKey}`);
                }
            }

            return result.rows;
        } catch (error) {
            this.logger.error(`Query execution failed: ${error instanceof Error ? error.message : String(error)}`);
            this.logger.error(`Failed query: ${query}`);
            this.logger.error(`Query params: ${JSON.stringify(params)}`);
            throw error;
        } finally {
            client.release();
        }
    }

    public async executeTransaction<T>(
        queries: {
            query: string;
            params: any[];
            cacheInvalidate?: string[];
        }[]
    ): Promise<T[]> {
        const client = await this.getClient();
        try {
            await client.query('BEGIN');

            const results: T[] = [];
            const cacheInvalidations: string[] = [];

            for (const { query, params, cacheInvalidate } of queries) {
                const startTime = performance.now();
                const result = await client.query<T>(query, params);
                const duration = performance.now() - startTime;

                this.logger.debug(`Transaction query executed in ${duration.toFixed(2)}ms: ${query.substring(0, 100)}...`);

                results.push(...result.rows);

                if (cacheInvalidate) {
                    cacheInvalidations.push(...cacheInvalidate);
                }
            }

            await client.query('COMMIT');

            // Invalidate cache after successful transaction
            if (cacheInvalidations.length > 0) {
                for (const pattern of cacheInvalidations) {
                    try {
                        await this.cache.invalidatePattern(pattern);
                    } catch (error) {
                        this.logger.warn(`Failed to invalidate cache pattern ${pattern}`);
                    }
                }
            }

            return results;
        } catch (error) {
            await client.query('ROLLBACK');
            this.logger.error(`Transaction failed: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        } finally {
            client.release();
        }
    }

    public async getDiagnosticData(
        vehicleId: string,
        startDate: Date,
        endDate: Date,
        options: {
            limit?: number;
            offset?: number;
            sortBy?: string;
            sortOrder?: 'ASC' | 'DESC';
        } = {}
    ): Promise<{
        data: any[];
        total: number;
        page: number;
        pageSize: number;
    }> {
        const { limit = 50, offset = 0, sortBy = 'timestamp', sortOrder = 'DESC' } = options;

        const cacheKey = `diagnostic_data:${vehicleId}:${startDate.getTime()}:${endDate.getTime()}:${limit}:${offset}:${sortBy}:${sortOrder}`;

        const query = `
            WITH filtered_data AS (
                SELECT
                    d.*,
                    ROW_NUMBER() OVER (ORDER BY d.${sortBy} ${sortOrder}) as row_num
                FROM diagnostic_data d
                WHERE d.vehicle_id = $1
                AND d.timestamp BETWEEN $2 AND $3
            ),
            total_count AS (
                SELECT COUNT(*) as total FROM filtered_data
            )
            SELECT
                fd.*,
                tc.total as total_count
            FROM filtered_data fd
            CROSS JOIN total_count tc
            WHERE fd.row_num BETWEEN $4 AND $5
            ORDER BY fd.${sortBy} ${sortOrder}
        `;

        const params = [
            vehicleId,
            startDate,
            endDate,
            offset + 1,
            offset + limit
        ];

        const result = await this.executeQuery<any>(
            query,
            params,
            { cacheKey, cacheTtl: 300 }
        );

        if (result.length === 0) {
            return {
                data: [],
                total: 0,
                page: Math.floor(offset / limit) + 1,
                pageSize: limit
            };
        }

        return {
            data: result.map(row => {
                const { row_num, total_count, ...data } = row;
                return data;
            }),
            total: parseInt(result[0].total_count),
            page: Math.floor(offset / limit) + 1,
            pageSize: limit
        };
    }

    public async getVehicleHealthSummary(vehicleId: string): Promise<any> {
        const cacheKey = `vehicle_health_summary:${vehicleId}`;

        const query = `
            WITH latest_dtc AS (
                SELECT
                    dtc_code,
                    description,
                    severity,
                    timestamp,
                    ROW_NUMBER() OVER (PARTITION BY dtc_code ORDER BY timestamp DESC) as rn
                FROM diagnostic_trouble_codes
                WHERE vehicle_id = $1
            ),
            health_metrics AS (
                SELECT
                    AVG(engine_load) as avg_engine_load,
                    AVG(coolant_temp) as avg_coolant_temp,
                    AVG(rpm) as avg_rpm,
                    AVG(speed) as avg_speed,
                    AVG(intake_temp) as avg_intake_temp,
                    AVG(maf) as avg_maf,
                    COUNT(*) as data_points
                FROM diagnostic_data
                WHERE vehicle_id = $1
                AND timestamp > NOW() - INTERVAL '30 days'
            )
            SELECT
                v.vehicle_id,
                v.make,
                v.model,
                v.year,
                v.vin,
                v.mileage,
                v.last_service_date,
                v.registration_expiry,
                COALESCE(h.avg_engine_load, 0) as avg_engine_load,
                COALESCE(h.avg_coolant_temp, 0) as avg_coolant_temp,
                COALESCE(h.avg_rpm, 0) as avg_rpm,
                COALESCE(h.avg_speed, 0) as avg_speed,
                COALESCE(h.avg_intake_temp, 0) as avg_intake_temp,
                COALESCE(h.avg_maf, 0) as avg_maf,
                h.data_points,
                (
                    SELECT COUNT(*) FROM latest_dtc WHERE rn = 1 AND severity = 'CRITICAL'
                ) as critical_issues,
                (
                    SELECT COUNT(*) FROM latest_dtc WHERE rn = 1 AND severity = 'WARNING'
                ) as warning_issues,
                (
                    SELECT COUNT(*) FROM latest_dtc WHERE rn = 1 AND severity = 'INFO'
                ) as info_issues,
                (
                    SELECT json_agg(
                        json_build_object(
                            'dtc_code', dtc_code,
                            'description', description,
                            'severity', severity,
                            'timestamp', timestamp
                        )
                    )
                    FROM latest_dtc
                    WHERE rn = 1
                ) as active_dtcs,
                (
                    SELECT json_agg(
                        json_build_object(
                            'service_type', service_type,
                            'description', description,
                            'due_mileage', due_mileage,
                            'due_date', due_date,
                            'status', status
                        )
                    )
                    FROM maintenance_schedule
                    WHERE vehicle_id = $1
                    AND (status = 'DUE' OR status = 'OVERDUE')
                ) as pending_maintenance
            FROM vehicles v
            LEFT JOIN health_metrics h ON v.vehicle_id = $1
            WHERE v.vehicle_id = $1
        `;

        const result = await this.executeQuery<any>(
            query,
            [vehicleId],
            { cacheKey, cacheTtl: 60 }
        );

        return result[0] || null;
    }

    public async optimizeDatabase(): Promise<void> {
        const client = await this.getClient();
        try {
            this.logger.info('Starting database optimization...');

            // Analyze tables to update statistics
            await client.query('ANALYZE');

            // Reindex tables with high fragmentation
            const tables = await this.executeQuery<{ table_name: string }>(
                `SELECT table_name
                 FROM information_schema.tables
                 WHERE table_schema = 'public'
                 AND table_type = 'BASE TABLE'`
            );

            for (const table of tables) {
                const indexStats = await this.executeQuery<{ index_name: string; idx_scan: number }>(
                    `SELECT indexname as index_name, idx_scan
                     FROM pg_stat_user_indexes
                     WHERE relname = $1
                     ORDER BY idx_scan ASC`,
                    [table.table_name]
                );

                if (indexStats.length > 0 && indexStats[0].idx_scan < 100) {
                    this.logger.info(`Reindexing table ${table.table_name} due to low index usage`);
                    await client.query(`REINDEX TABLE ${table.table_name}`);
                }
            }

            // Vacuum to reclaim space
            await client.query('VACUUM (VERBOSE, ANALYZE)');

            this.logger.info('Database optimization completed');
        } catch (error) {
            this.logger.error(`Database optimization failed: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        } finally {
            client.release();
        }
    }

    public async getPoolStats(): Promise<{
        totalConnections: number;
        idleConnections: number;
        waitingClients: number;
    }> {
        return {
            totalConnections: this.pool.totalCount,
            idleConnections: this.pool.idleCount,
            waitingClients: this.pool.waitingCount
        };
    }

    public async close(): Promise<void> {
        try {
            await this.pool.end();
            this.logger.info('Database connection pool closed');
        } catch (error) {
            this.logger.error(`Error closing database pool: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }
}
```

### API Response Compression

```typescript
// src/middleware/response-compression.ts
import { Request, Response, NextFunction } from 'express';
import compression from 'compression';
import { Logger } from '../utils/logger';
import { performance } from 'perf_hooks';
import zlib from 'zlib';

export class ResponseCompression {
    private static instance: ResponseCompression;
    private logger: Logger;
    private compressionMiddleware: (req: Request, res: Response, next: NextFunction) => void;

    private constructor() {
        this.logger = new Logger('ResponseCompression');

        // Custom compression filter
        const shouldCompress = (req: Request, res: Response) => {
            if (req.headers['x-no-compression']) {
                return false;
            }

            // Don't compress binary data or already compressed files
            const contentType = res.getHeader('Content-Type') as string;
            if (contentType && (
                contentType.includes('application/octet-stream') ||
                contentType.includes('image/') ||
                contentType.includes('video/') ||
                contentType.includes('audio/') ||
                contentType.includes('zip') ||
                contentType.includes('gzip') ||
                contentType.includes('pdf')
            )) {
                return false;
            }

            // Don't compress small responses
            const contentLength = res.getHeader('Content-Length') as number;
            if (contentLength && contentLength < 1024) {
                return false;
            }

            return compression.filter(req, res);
        };

        // Configure compression
        this.compressionMiddleware = compression({
            filter: shouldCompress,
            threshold: 0,
            level: zlib.constants.Z_BEST_COMPRESSION,
            strategy: zlib.constants.Z_DEFAULT_STRATEGY,
            chunkSize: 16 * 1024,
            windowBits: 15,
            memLevel: 8
        });
    }

    public static getInstance(): ResponseCompression {
        if (!ResponseCompression.instance) {
            ResponseCompression.instance = new ResponseCompression();
        }
        return ResponseCompression.instance;
    }

    public middleware(): (req: Request, res: Response, next: NextFunction) => void {
        return (req: Request, res: Response, next: NextFunction) => {
            const startTime = performance.now();

            // Wrap the original write and end methods
            const originalWrite = res.write;
            const originalEnd = res.end;

            let chunks: Buffer[] = [];
            let compressed = false;

            res.write = function(chunk: any, ...args: any[]): boolean {
                if (chunk) {
                    chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
                }
                return originalWrite.apply(res, [chunk, ...args] as any);
            };

            res.end = function(chunk: any, ...args: any[]): Response {
                if (chunk) {
                    chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
                }

                if (!compressed && chunks.length > 0) {
                    const body = Buffer.concat(chunks);
                    const contentType = res.getHeader('Content-Type') as string;

                    // Only compress if the response is JSON and meets size threshold
                    if (contentType && contentType.includes('application/json') && body.length > 1024) {
                        try {
                            const compressedBody = zlib.gzipSync(body, {
                                level: zlib.constants.Z_BEST_COMPRESSION
                            });

                            res.setHeader('Content-Encoding', 'gzip');
                            res.setHeader('Content-Length', compressedBody.length);
                            compressed = true;

                            const duration = performance.now() - startTime;
                            this.logger.debug(`Compressed response: ${body.length} -> ${compressedBody.length} bytes (${(100 - (compressedBody.length / body.length * 100)).toFixed(2)}% reduction) in ${duration.toFixed(2)}ms`);
                        } catch (error) {
                            this.logger.error(`Compression failed: ${error instanceof Error ? error.message : String(error)}`);
                        }
                    }
                }

                return originalEnd.apply(res, [chunk, ...args] as any);
            };

            this.compressionMiddleware(req, res, next);
        };
    }

    public async compressString(content: string, options: zlib.ZlibOptions = {}): Promise<Buffer> {
        return new Promise((resolve, reject) => {
            zlib.gzip(content, {
                level: zlib.constants.Z_BEST_COMPRESSION,
                ...options
            }, (error, result) => {
                if (error) {
                    reject(error);
                } else {
                    resolve(result);
                }
            });
        });
    }

    public async decompressBuffer(buffer: Buffer, options: zlib.ZlibOptions = {}): Promise<string> {
        return new Promise((resolve, reject) => {
            zlib.gunzip(buffer, options, (error, result) => {
                if (error) {
                    reject(error);
                } else {
                    resolve(result.toString());
                }
            });
        });
    }

    public getCompressionStats(): {
        enabled: boolean;
        compressionLevel: number;
        threshold: number;
    } {
        return {
            enabled: true,
            compressionLevel: zlib.constants.Z_BEST_COMPRESSION,
            threshold: 1024
        };
    }
}
```

### Lazy Loading Implementation

```typescript
// src/utils/lazy-loader.ts
import { Logger } from './logger';
import { performance } from 'perf_hooks';

type LazyLoadOptions<T> = {
    loadFn: () => Promise<T>;
    cacheKey?: string;
    ttl?: number;
    maxRetries?: number;
    retryDelay?: number;
    fallback?: T | (() => T);
};

export class LazyLoader<T> {
    private logger: Logger;
    private loadFn: () => Promise<T>;
    private cacheKey?: string;
    private ttl?: number;
    private maxRetries: number;
    private retryDelay: number;
    private fallback?: T | (() => T);
    private value: T | null = null;
    private isLoading = false;
    private loadingPromise: Promise<T> | null = null;
    private lastLoaded = 0;
    private retryCount = 0;

    constructor(options: LazyLoadOptions<T>) {
        this.logger = new Logger(`LazyLoader:${options.cacheKey || 'anonymous'}`);
        this.loadFn = options.loadFn;
        this.cacheKey = options.cacheKey;
        this.ttl = options.ttl;
        this.maxRetries = options.maxRetries || 3;
        this.retryDelay = options.retryDelay || 1000;
        this.fallback = options.fallback;
    }

    public async getValue(): Promise<T> {
        const now = Date.now();

        // Return cached value if it's still valid
        if (this.value !== null && this.ttl && (now - this.lastLoaded) < this.ttl) {
            this.logger.debug(`Returning cached value (${now - this.lastLoaded}ms old)`);
            return this.value;
        }

        // If already loading, return the existing promise
        if (this.isLoading && this.loadingPromise) {
            this.logger.debug('Waiting for existing load operation');
            return this.loadingPromise;
        }

        // Start loading
        this.isLoading = true;
        this.loadingPromise = this.loadWithRetry();

        try {
            const result = await this.loadingPromise;
            this.value = result;
            this.lastLoaded = now;
            this.retryCount = 0;
            return result;
        } catch (error) {
            this.logger.error(`Failed to load value after ${this.maxRetries} retries: ${error instanceof Error ? error.message : String(error)}`);

            // Return fallback if available
            if (this.fallback !== undefined) {
                return typeof this.fallback === 'function'
                    ? (this.fallback as () => T)()
                    : this.fallback;
            }

            throw error;
        } finally {
            this.isLoading = false;
            this.loadingPromise = null;
        }
    }

    private async loadWithRetry(): Promise<T> {
        let lastError: Error | null = null;

        for (let i = 0; i < this.maxRetries; i++) {
            try {
                const startTime = performance.now();
                const result = await this.loadFn();
                const duration = performance.now() - startTime;

                this.logger.debug(`Successfully loaded value in ${duration.toFixed(2)}ms (attempt ${i + 1})`);
                return result;
            } catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                this.logger.warn(`Load attempt ${i + 1} failed: ${lastError.message}`);

                if (i < this.maxRetries - 1) {
                    await new Promise(resolve => setTimeout(resolve, this.retryDelay));
                }
            }
        }

        throw lastError || new Error('Unknown error during lazy loading');
    }

    public async refresh(): Promise<T> {
        this.logger.debug('Forcing refresh of lazy loaded value');
        this.value = null;
        this.lastLoaded = 0;
        return this.getValue();
    }

    public async invalidate(): Promise<void> {
        this.logger.debug('Invalidating lazy loaded value');
        this.value = null;
        this.lastLoaded = 0;
    }

    public getStatus(): {
        isLoaded: boolean;
        isLoading: boolean;
        lastLoaded: number;
        age: number;
        retryCount: number;
    } {
        const now = Date.now();
        return {
            isLoaded: this.value !== null,
            isLoading: this.isLoading,
            lastLoaded: this.lastLoaded,
            age: this.value !== null ? now - this.lastLoaded : 0,
            retryCount: this.retryCount
        };
    }
}

// Example usage in a service
export class VehicleService {
    private logger: Logger;
    private vehicleLoader: LazyLoader<Map<string, any>>;
    private diagnosticLoader: LazyLoader<any[]>;

    constructor() {
        this.logger = new Logger('VehicleService');

        // Initialize lazy loaders
        this.vehicleLoader = new LazyLoader<Map<string, any>>({
            loadFn: this.loadVehicleData.bind(this),
            cacheKey: 'vehicle_data',
            ttl: 300000, // 5 minutes
            maxRetries: 3,
            fallback: new Map()
        });

        this.diagnosticLoader = new LazyLoader<any[]>({
            loadFn: this.loadDiagnosticData.bind(this),
            cacheKey: 'diagnostic_data',
            ttl: 60000, // 1 minute
            maxRetries: 2,
            fallback: []
        });
    }

    private async loadVehicleData(): Promise<Map<string, any>> {
        this.logger.debug('Loading vehicle data from database');
        // Simulate database query
        await new Promise(resolve => setTimeout(resolve, 100));

        // In a real implementation, this would query the database
        const vehicleData = new Map<string, any>();
        vehicleData.set('vehicle1', { make: 'Toyota', model: 'Camry', year: 2020 });
        vehicleData.set('vehicle2', { make: 'Honda', model: 'Accord', year: 2019 });

        return vehicleData;
    }

    private async loadDiagnosticData(): Promise<any[]> {
        this.logger.debug('Loading diagnostic data from database');
        // Simulate database query
        await new Promise(resolve => setTimeout(resolve, 150));

        // In a real implementation, this would query the database
        return [
            { vehicleId: 'vehicle1', dtc: 'P0123', description: 'Throttle Position Sensor Circuit High Input', timestamp: new Date() },
            { vehicleId: 'vehicle2', dtc: 'P0420', description: 'Catalyst System Efficiency Below Threshold', timestamp: new Date() }
        ];
    }

    public async getVehicle(vehicleId: string): Promise<any> {
        const vehicleData = await this.vehicleLoader.getValue();
        return vehicleData.get(vehicleId) || null;
    }

    public async getVehicleDiagnostics(vehicleId: string): Promise<any[]> {
        const diagnostics = await this.diagnosticLoader.getValue();
        return diagnostics.filter(d => d.vehicleId === vehicleId);
    }

    public async refreshVehicleData(): Promise<void> {
        await this.vehicleLoader.refresh();
    }

    public async refreshDiagnosticData(): Promise<void> {
        await this.diagnosticLoader.refresh();
    }
}
```

### Request Debouncing

```typescript
// src/utils/request-debouncer.ts
import { Logger } from './logger';
import { performance } from 'perf_hooks';

type DebounceOptions = {
    delay: number;
    maxWait?: number;
    leading?: boolean;
    trailing?: boolean;
};

type PendingRequest<T> = {
    promise: Promise<T>;
    resolve: (value: T) => void;
    reject: (reason?: any) => void;
    timer: NodeJS.Timeout;
    maxWaitTimer?: NodeJS.Timeout;
    lastCallTime: number;
};

export class RequestDebouncer {
    private static instances: Map<string, RequestDebouncer> = new Map();
    private logger: Logger;
    private options: DebounceOptions;
    private pendingRequests: Map<string, PendingRequest<any>> = new Map();
    private lastExecutionTimes: Map<string, number> = new Map();

    private constructor(key: string, options: DebounceOptions) {
        this.logger = new Logger(`RequestDebouncer:${key}`);
        this.options = {
            delay: 300,
            maxWait: 1000,
            leading: false,
            trailing: true,
            ...options
        };

        this.logger.debug(`Initialized with options: ${JSON.stringify(this.options)}`);
    }

    public static getInstance(key: string, options: DebounceOptions = { delay: 300 }): RequestDebouncer {
        if (!RequestDebouncer.instances.has(key)) {
            RequestDebouncer.instances.set(key, new RequestDebouncer(key, options));
        }
        return RequestDebouncer.instances.get(key)!;
    }

    public async debounce<T>(
        key: string,
        fn: () => Promise<T>,
        customOptions?: Partial<DebounceOptions>
    ): Promise<T> {
        const options = { ...this.options, ...customOptions };
        const now = performance.now();
        const lastExecutionTime = this.lastExecutionTimes.get(key) || 0;
        const timeSinceLastExecution = now - lastExecutionTime;

        // If this is the first call for this key, or we're not in a debounce period
        if (!this.pendingRequests.has(key) || timeSinceLastExecution > options.delay) {
            return this.createNewRequest(key, fn, options);
        }

        // If we're in a debounce period, return the existing promise
        const pendingRequest = this.pendingRequests.get(key)!;
        this.logger.debug(`Debouncing request for key ${key}`);

        // Clear any existing maxWait timer to prevent premature execution
        if (pendingRequest.maxWaitTimer) {
            clearTimeout(pendingRequest.maxWaitTimer);
        }

        // Set new maxWait timer if needed
        if (options.maxWait) {
            pendingRequest.maxWaitTimer = setTimeout(() => {
                this.executeRequest(key, fn, options);
            }, options.maxWait);
        }

        return pendingRequest.promise;
    }

    private createNewRequest<T>(
        key: string,
        fn: () => Promise<T>,
        options: DebounceOptions
    ): Promise<T> {
        this.logger.debug(`Creating new debounced request for key ${key}`);

        let resolve: (value: T) => void;
        let reject: (reason?: any) => void;

        const promise = new Promise<T>((res, rej) => {
            resolve = res;
            reject = rej;
        });

        const timer = setTimeout(() => {
            this.executeRequest(key, fn, options);
        }, options.delay);

        const pendingRequest: PendingRequest<T> = {
            promise,
            resolve: resolve!,
            reject: reject!,
            timer,
            lastCallTime: performance.now()
        };

        // Set maxWait timer if configured
        if (options.maxWait) {
            pendingRequest.maxWaitTimer = setTimeout(() => {
                this.executeRequest(key, fn, options);
            }, options.maxWait);
        }

        this.pendingRequests.set(key, pendingRequest as PendingRequest<any>);

        return promise;
    }

    private async executeRequest<T>(
        key: string,
        fn: () => Promise<T>,
        options: DebounceOptions
    ): Promise<void> {
        const pendingRequest = this.pendingRequests.get(key);
        if (!pendingRequest) {
            this.logger.warn(`No pending request found for key ${key}`);
            return;
        }

        this.logger.debug(`Executing debounced request for key ${key}`);

        // Clear timers
        clearTimeout(pendingRequest.timer);
        if (pendingRequest.maxWaitTimer) {
            clearTimeout(pendingRequest.maxWaitTimer);
        }

        try {
            const startTime = performance.now();
            const result = await fn();
            const duration = performance.now() - startTime;

            this.logger.debug(`Request for key ${key} completed in ${duration.toFixed(2)}ms`);
            pendingRequest.resolve(result);
            this.lastExecutionTimes.set(key, performance.now());
        } catch (error) {
            this.logger.error(`Request for key ${key} failed: ${error instanceof Error ? error.message : String(error)}`);
            pendingRequest.reject(error);
        } finally {
            this.pendingRequests.delete(key);
        }
    }

    public cancel(key: string): void {
        const pendingRequest = this.pendingRequests.get(key);
        if (pendingRequest) {
            this.logger.debug(`Cancelling debounced request for key ${key}`);
            clearTimeout(pendingRequest.timer);
            if (pendingRequest.maxWaitTimer) {
                clearTimeout(pendingRequest.maxWaitTimer);
            }
            pendingRequest.reject(new Error('Request cancelled'));
            this.pendingRequests.delete(key);
        }
    }

    public getPendingRequests(): string[] {
        return Array.from(this.pendingRequests.keys());
    }

    public getLastExecutionTime(key: string): number | undefined {
        return this.lastExecutionTimes.get(key);
    }

    public clear(): void {
        this.logger.debug('Clearing all debounced requests');
        this.pendingRequests.forEach((request, key) => {
            clearTimeout(request.timer);
            if (request.maxWaitTimer) {
                clearTimeout(request.maxWaitTimer);
            }
            request.reject(new Error('Debouncer cleared'));
        });
        this.pendingRequests.clear();
    }
}

// Example usage in an API controller
export class DiagnosticController {
    private logger: Logger;
    private debouncer: RequestDebouncer;

    constructor() {
        this.logger = new Logger('DiagnosticController');
        this.debouncer = RequestDebouncer.getInstance('diagnostic', {
            delay: 500,
            maxWait: 2000,
            leading: false,
            trailing: true
        });
    }

    public async getDiagnostics(req: any, res: any): Promise<void> {
        try {
            const { vehicleId } = req.params;
            const { forceRefresh } = req.query;

            const result = await this.debouncer.debounce(
                `diagnostics:${vehicleId}`,
                async () => {
                    this.logger.debug(`Executing diagnostics for vehicle ${vehicleId}`);
                    // Simulate database query
                    await new Promise(resolve => setTimeout(resolve, 200));

                    return {
                        vehicleId,
                        diagnostics: [
                            { code: 'P0123', description: 'Throttle Position Sensor Circuit High Input', severity: 'WARNING' },
                            { code: 'P0420', description: 'Catalyst System Efficiency Below Threshold', severity: 'CRITICAL' }
                        ],
                        timestamp: new Date().toISOString()
                    };
                },
                forceRefresh ? { delay: 0 } : undefined
            );

            res.json(result);
        } catch (error) {
            this.logger.error(`Error in getDiagnostics: ${error instanceof Error ? error.message : String(error)}`);
            res.status(500).json({ error: 'Failed to retrieve diagnostics' });
        }
    }

    public async getRealTimeDiagnostics(req: any, res: any): Promise<void> {
        try {
            const { vehicleId } = req.params;

            // Use shorter debounce for real-time updates
            const result = await this.debouncer.debounce(
                `realtime:${vehicleId}`,
                async () => {
                    this.logger.debug(`Executing real-time diagnostics for vehicle ${vehicleId}`);
                    // Simulate real-time data fetch
                    await new Promise(resolve => setTimeout(resolve, 100));

                    return {
                        vehicleId,
                        realtime: {
                            rpm: Math.floor(Math.random() * 3000) + 1000,
                            speed: Math.floor(Math.random() * 120),
                            engineLoad: Math.random() * 100,
                            coolantTemp: Math.floor(Math.random() * 50) + 50,
                            timestamp: new Date().toISOString()
                        }
                    };
                },
                { delay: 200, maxWait: 500 }
            );

            res.json(result);
        } catch (error) {
            this.logger.error(`Error in getRealTimeDiagnostics: ${error instanceof Error ? error.message : String(error)}`);
            res.status(500).json({ error: 'Failed to retrieve real-time diagnostics' });
        }
    }
}
```

### Connection Pooling

```typescript
// src/database/connection-pool.ts
import { Pool, PoolClient, PoolConfig, QueryResult } from 'pg';
import { Logger } from '../utils/logger';
import { performance } from 'perf_hooks';
import { EventEmitter } from 'events';

export interface ConnectionPoolStats {
    totalConnections: number;
    idleConnections: number;
    waitingClients: number;
    maxConnections: number;
    acquiredConnections: number;
    connectionWaitTime: number;
    queryExecutionTime: number;
    queriesExecuted: number;
}

export class EnhancedConnectionPool extends EventEmitter {
    private static instance: EnhancedConnectionPool;
    private pool: Pool;
    private logger: Logger;
    private config: PoolConfig;
    private stats: ConnectionPoolStats = {
        totalConnections: 0,
        idleConnections: 0,
        waitingClients: 0,
        maxConnections: 0,
        acquiredConnections: 0,
        connectionWaitTime: 0,
        queryExecutionTime: 0,
        queriesExecuted: 0
    };
    private connectionWaitTimes: number[] = [];
    private queryExecutionTimes: number[] = [];

    private constructor(config: PoolConfig) {
        super();
        this.config = {
            max: 20,
            idleTimeoutMillis: 30000,
            connectionTimeoutMillis: 5000,
            ...config
        };

        this.logger = new Logger('EnhancedConnectionPool');
        this.pool = new Pool(this.config);

        this.setupEventListeners();
        this.setupMonitoring();
    }

    public static getInstance(config: PoolConfig): EnhancedConnectionPool {
        if (!EnhancedConnectionPool.instance) {
            EnhancedConnectionPool.instance = new EnhancedConnectionPool(config);
        }
        return EnhancedConnectionPool.instance;
    }

    private setupEventListeners(): void {
        this.pool.on('connect', () => {
            this.stats.totalConnections++;
            this.logger.debug('New connection established');
            this.emit('connect');
        });

        this.pool.on('acquire', () => {
            this.stats.acquiredConnections++;
            this.logger.debug('Connection acquired from pool');
            this.emit('acquire');
        });

        this.pool.on('remove', () => {
            this.stats.totalConnections--;
            this.logger.debug('Connection removed from pool');
            this.emit('remove');
        });

        this.pool.on('error', (err) => {
            this.logger.error(`Connection pool error: ${err.message}`);
            this.emit('error', err);
        });
    }

    private setupMonitoring(): void {
        // Update stats every 5 seconds
        setInterval(() => {
            this.updateStats();
        }, 5000);
    }

    private updateStats(): void {
        this.stats = {
            ...this.stats,
            idleConnections: this.pool.idleCount,
            waitingClients: this.pool.waitingCount,
            maxConnections: this.pool.totalCount,
            connectionWaitTime: this.calculateAverage(this.connectionWaitTimes),
            queryExecutionTime: this.calculateAverage(this.queryExecutionTimes),
            queriesExecuted: this.stats.queriesExecuted
        };

        // Reset temporary arrays
        this.connectionWaitTimes = [];
        this.queryExecutionTimes = [];

        this.logger.debug(`Pool stats: ${JSON.stringify({
            idle: this.stats.idleConnections,
            waiting: this.stats.waitingClients,
            total: this.stats.totalConnections
        })}`);
    }

    private calculateAverage(times: number[]): number {
        if (times.length === 0) return 0;
        const sum = times.reduce((a, b) => a + b, 0);
        return sum / times.length;
    }

    public async getClient(): Promise<PoolClient> {
        const startTime = performance.now();

        try {
            const client = await this.pool.connect();
            const waitTime = performance.now() - startTime;
            this.connectionWaitTimes.push(waitTime);

            this.logger.debug(`Acquired client in ${waitTime.toFixed(2)}ms`);

            // Wrap query method to track execution time
            const originalQuery = client.query;
            client.query = async (...args: any[]): Promise<QueryResult> => {
                const queryStartTime = performance.now();
                try {
                    const result = await originalQuery.apply(client, args);
                    const queryTime = performance.now() - queryStartTime;
                    this.queryExecutionTimes.push(queryTime);
                    this.stats.queriesExecuted++;

                    this.logger.debug(`Query executed in ${queryTime.toFixed(2)}ms: ${args[0].substring(0, 100)}...`);
                    return result;
                } catch (error) {
                    const queryTime = performance.now() - queryStartTime;
                    this.logger.error(`Query failed after ${queryTime.toFixed(2)}ms: ${error instanceof Error ? error.message : String(error)}`);
                    throw error;
                }
            };

            return client;
        } catch (error) {
            const waitTime = performance.now() - startTime;
            this.logger.error(`Failed to acquire client after ${waitTime.toFixed(2)}ms: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }

    public async query<T>(text: string, params?: any[]): Promise<QueryResult<T>> {
        const client = await this.getClient();
        try {
            return await client.query<T>(text, params);
        } finally {
            client.release();
        }
    }

    public async transaction<T>(queries: { text: string; params?: any[] }[]): Promise<T[]> {
        const client = await this.getClient();
        try {
            await client.query('BEGIN');

            const results: T[] = [];
            for (const query of queries) {
                const result = await client.query<T>(query.text, query.params);
                results.push(...result.rows);
            }

            await client.query('COMMIT');
            return results;
        } catch (error) {
            await client.query('ROLLBACK');
            this.logger.error(`Transaction failed: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        } finally {
            client.release();
        }
    }

    public async getDiagnosticData(
        vehicleId: string,
        startDate: Date,
        endDate: Date,
        options: {
            limit?: number;
            offset?: number;
            sortBy?: string;
            sortOrder?: 'ASC' | 'DESC';
        } = {}
    ): Promise<{
        data: any[];
        total: number;
        page: number;
        pageSize: number;
    }> {
        const { limit = 50, offset = 0, sortBy = 'timestamp', sortOrder = 'DESC' } = options;

        const query = `
            WITH filtered_data AS (
                SELECT
                    d.*,
                    ROW_NUMBER() OVER (ORDER BY d.${sortBy} ${sortOrder}) as row_num
                FROM diagnostic_data d
                WHERE d.vehicle_id = $1
                AND d.timestamp BETWEEN $2 AND $3
            ),
            total_count AS (
                SELECT COUNT(*) as total FROM filtered_data
            )
            SELECT
                fd.*,
                tc.total as total_count
            FROM filtered_data fd
            CROSS JOIN total_count tc
            WHERE fd.row_num BETWEEN $4 AND $5
            ORDER BY fd.${sortBy} ${sortOrder}
        `;

        const params = [
            vehicleId,
            startDate,
            endDate,
            offset + 1,
            offset + limit
        ];

        const result = await this.query<any>(query, params);

        if (result.rows.length === 0) {
            return {
                data: [],
                total: 0,
                page: Math.floor(offset / limit) + 1,
                pageSize: limit
            };
        }

        return {
            data: result.rows.map(row => {
                const { row_num, total_count, ...data } = row;
                return data;
            }),
            total: parseInt(result.rows[0].total_count),
            page: Math.floor(offset / limit) + 1,
            pageSize: limit
        };
    }

    public async getVehicleHealthSummary(vehicleId: string): Promise<any> {
        const query = `
            WITH latest_dtc AS (
                SELECT
                    dtc_code,
                    description,
                    severity,
                    timestamp,
                    ROW_NUMBER() OVER (PARTITION BY dtc_code ORDER BY timestamp DESC) as rn
                FROM diagnostic_trouble_codes
                WHERE vehicle_id = $1
            ),
            health_metrics AS (
                SELECT
                    AVG(engine_load) as avg_engine_load,
                    AVG(coolant_temp) as avg_coolant_temp,
                    AVG(rpm) as avg_rpm,
                    AVG(speed) as avg_speed,
                    AVG(intake_temp) as avg_intake_temp,
                    AVG(maf) as avg_maf,
                    COUNT(*) as data_points
                FROM diagnostic_data
                WHERE vehicle_id = $1
                AND timestamp > NOW() - INTERVAL '30 days'
            )
            SELECT
                v.vehicle_id,
                v.make,
                v.model,
                v.year,
                v.vin,
                v.mileage,
                v.last_service_date,
                v.registration_expiry,
                COALESCE(h.avg_engine_load, 0) as avg_engine_load,
                COALESCE(h.avg_coolant_temp, 0) as avg_coolant_temp,
                COALESCE(h.avg_rpm, 0) as avg_rpm,
                COALESCE(h.avg_speed, 0) as avg_speed,
                COALESCE(h.avg_intake_temp, 0) as avg_intake_temp,
                COALESCE(h.avg_maf, 0) as avg_maf,
                h.data_points,
                (
                    SELECT COUNT(*) FROM latest_dtc WHERE rn = 1 AND severity = 'CRITICAL'
                ) as critical_issues,
                (
                    SELECT COUNT(*) FROM latest_dtc WHERE rn = 1 AND severity = 'WARNING'
                ) as warning_issues,
                (
                    SELECT COUNT(*) FROM latest_dtc WHERE rn = 1 AND severity = 'INFO'
                ) as info_issues,
                (
                    SELECT json_agg(
                        json_build_object(
                            'dtc_code', dtc_code,
                            'description', description,
                            'severity', severity,
                            'timestamp', timestamp
                        )
                    )
                    FROM latest_dtc
                    WHERE rn = 1
                ) as active_dtcs,
                (
                    SELECT json_agg(
                        json_build_object(
                            'service_type', service_type,
                            'description', description,
                            'due_mileage', due_mileage,
                            'due_date', due_date,
                            'status', status
                        )
                    )
                    FROM maintenance_schedule
                    WHERE vehicle_id = $1
                    AND (status = 'DUE' OR status = 'OVERDUE')
                ) as pending_maintenance
            FROM vehicles v
            LEFT JOIN health_metrics h ON v.vehicle_id = $1
            WHERE v.vehicle_id = $1
        `;

        const result = await this.query<any>(query, [vehicleId]);
        return result.rows[0] || null;
    }

    public getStats(): ConnectionPoolStats {
        return {
            ...this.stats,
            idleConnections: this.pool.idleCount,
            waitingClients: this.pool.waitingCount,
            totalConnections: this.pool.totalCount
        };
    }

    public async end(): Promise<void> {
        try {
            await this.pool.end();
            this.logger.info('Connection pool closed');
            this.emit('end');
        } catch (error) {
            this.logger.error(`Error closing connection pool: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }

    public async checkHealth(): Promise<{
        healthy: boolean;
        message: string;
        details: any;
    }> {
        try {
            const client = await this.getClient();
            try {
                await client.query('SELECT 1');
                return {
                    healthy: true,
                    message: 'Database connection is healthy',
                    details: {
                        status: 'OK',
                        timestamp: new Date().toISOString()
                    }
                };
            } finally {
                client.release();
            }
        } catch (error) {
            return {
                healthy: false,
                message: `Database connection failed: ${error instanceof Error ? error.message : String(error)}`,
                details: {
                    status: 'ERROR',
                    error: error instanceof Error ? error.message : String(error),
                    timestamp: new Date().toISOString()
                }
            };
        }
    }
}
```

---

## Real-Time Features (300+ lines)

### WebSocket Server Setup

```typescript
// src/websocket/websocket-server.ts
import { Server } from 'http';
import { WebSocketServer } from 'ws';
import { Logger } from '../utils/logger';
import { performance } from 'perf_hooks';
import { v4 as uuidv4 } from 'uuid';
import { Redis } from 'ioredis';
import { EventEmitter } from 'events';
import { RateLimiter } from '../utils/rate-limiter';

interface WebSocketClient {
    socket: WebSocket;
    id: string;
    vehicleId?: string;
    userId?: string;
    ipAddress: string;
    connectedAt: number;
    lastPing: number;
    isAlive: boolean;
    metadata: Record<string, any>;
    subscriptions: Set<string>;
}

interface WebSocketMessage {
    type: string;
    payload: any;
    timestamp: number;
    messageId?: string;
}

interface WebSocketError {
    code: number;
    message: string;
    details?: any;
}

export class WebSocketServerManager extends EventEmitter {
    private static instance: WebSocketServerManager;
    private wss: WebSocketServer;
    private clients: Map<string, WebSocketClient> = new Map();
    private logger: Logger;
    private redis: Redis;
    private rateLimiter: RateLimiter;
    private pingInterval: NodeJS.Timeout;
    private messageQueue: WebSocketMessage[] = [];
    private isProcessingQueue = false;

    private constructor(server: Server) {
        super();
        this.logger = new Logger('WebSocketServer');
        this.redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');
        this.rateLimiter = new RateLimiter({
            points: 100,
            duration: 60,
            blockDuration: 300
        });

        // Initialize WebSocket server
        this.wss = new WebSocketServer({
            server,
            path: '/ws',
            clientTracking: false,
            maxPayload: 1024 * 1024, // 1MB
            perMessageDeflate: {
                zlibDeflateOptions: {
                    chunkSize: 1024,
                    memLevel: 7,
                    level: 3
                },
                zlibInflateOptions: {
                    chunkSize: 10 * 1024
                },
                threshold: 1024
            }
        });

        this.setupEventListeners();
        this.setupPingPong();
        this.setupMessageQueueProcessor();
    }

    public static getInstance(server?: Server): WebSocketServerManager {
        if (!WebSocketServerManager.instance && server) {
            WebSocketServerManager.instance = new WebSocketServerManager(server);
        }
        return WebSocketServerManager.instance;
    }

    private setupEventListeners(): void {
        this.wss.on('connection', (socket: WebSocket, request: any) => {
            const clientId = uuidv4();
            const ipAddress = this.getClientIp(request);

            const client: WebSocketClient = {
                socket,
                id: clientId,
                ipAddress,
                connectedAt: performance.now(),
                lastPing: performance.now(),
                isAlive: true,
                metadata: {},
                subscriptions: new Set()
            };

            this.clients.set(clientId, client);
            this.logger.info(`New WebSocket connection: ${clientId} from ${ipAddress}`);

            // Set up client-specific event listeners
            socket.on('message', (data: WebSocket.Data) => this.handleMessage(client, data));
            socket.on('close', (code: number, reason: string) => this.handleClose(client, code, reason));
            socket.on('error', (error: Error) => this.handleError(client, error));
            socket.on('pong', () => this.handlePong(client));

            // Send welcome message
            this.sendMessage(client, {
                type: 'welcome',
                payload: {
                    clientId,
                    timestamp: Date.now(),
                    serverTime: new Date().toISOString(),
                    maxPayloadSize: 1024 * 1024
                }
            });

            this.emit('connection', client);
        });

        this.wss.on('error', (error: Error) => {
            this.logger.error(`WebSocket server error: ${error.message}`);
            this.emit('error', error);
        });

        this.wss.on('listening', () => {
            this.logger.info('WebSocket server is listening');
            this.emit('listening');
        });
    }

    private setupPingPong(): void {
        // Check connections every 30 seconds
        this.pingInterval = setInterval(() => {
            const now = performance.now();

            this.clients.forEach((client, clientId) => {
                if (!client.isAlive) {
                    this.logger.warn(`Terminating unresponsive client: ${clientId}`);
                    client.socket.terminate();
                    this.clients.delete(clientId);
                    return;
                }

                if (now - client.lastPing > 30000) { // 30 seconds
                    client.isAlive = false;
                    client.socket.ping();
                }
            });
        }, 30000);
    }

    private setupMessageQueueProcessor(): void {
        // Process message queue every 100ms
        setInterval(() => {
            if (this.messageQueue.length > 0 && !this.isProcessingQueue) {
                this.processMessageQueue();
            }
        }, 100);
    }

    private async processMessageQueue(): Promise<void> {
        if (this.isProcessingQueue) return;

        this.isProcessingQueue = true;
        const batchSize = 50;
        const messagesToProcess = this.messageQueue.splice(0, batchSize);

        try {
            // Group messages by client for batch sending
            const messagesByClient = new Map<string, WebSocketMessage[]>();

            for (const message of messagesToProcess) {
                const { clientId } = message.payload;

                if (!messagesByClient.has(clientId)) {
                    messagesByClient.set(clientId, []);
                }

                messagesByClient.get(clientId)!.push(message);
            }

            // Send messages to each client
            for (const [clientId, messages] of messagesByClient) {
                const client = this.clients.get(clientId);
                if (client && client.socket.readyState === WebSocket.OPEN) {
                    try {
                        // Batch messages of the same type
                        const batchedMessages = this.batchMessages(messages);
                        for (const batchedMessage of batchedMessages) {
                            client.socket.send(JSON.stringify(batchedMessage));
                        }
                    } catch (error) {
                        this.logger.error(`Error sending batched messages to client ${clientId}: ${error instanceof Error ? error.message : String(error)}`);
                    }
                }
            }
        } finally {
            this.isProcessingQueue = false;
        }
    }

    private batchMessages(messages: WebSocketMessage[]): WebSocketMessage[] {
        if (messages.length === 0) return [];

        // Group by message type
        const groups = new Map<string, WebSocketMessage[]>();

        for (const message of messages) {
            if (!groups.has(message.type)) {
                groups.set(message.type, []);
            }
            groups.get(message.type)!.push(message);
        }

        // Create batched messages
        const batchedMessages: WebSocketMessage[] = [];

        for (const [type, groupMessages] of groups) {
            if (groupMessages.length === 1) {
                batchedMessages.push(groupMessages[0]);
            } else {
                // Batch messages of the same type
                batchedMessages.push({
                    type: `${type}_batch`,
                    payload: groupMessages.map(m => m.payload),
                    timestamp: Date.now()
                });
            }
        }

        return batchedMessages;
    }

    private getClientIp(request: any): string {
        // Handle proxy headers
        const xForwardedFor = request.headers['x-forwarded-for'];
        if (xForwardedFor) {
            return xForwardedFor.split(',')[0].trim();
        }

        const socket = request.socket;
        return socket.remoteAddress || 'unknown';
    }

    private async handleMessage(client: WebSocketClient, data: WebSocket.Data): Promise<void> {
        try {
            // Check rate limiting
            const rateLimitKey = `ws:${client.ipAddress}`;
            const rateLimitResult = await this.rateLimiter.consume(rateLimitKey);

            if (!rateLimitResult.allowed) {
                this.sendError(client, {
                    code: 429,
                    message: 'Too many requests',
                    details: {
                        retryAfter: rateLimitResult.retryAfter
                    }
                });
                return;
            }

            // Parse message
            let message: WebSocketMessage;
            try {
                message = JSON.parse(data.toString());
            } catch (error) {
                this.sendError(client, {
                    code: 400,
                    message: 'Invalid JSON format'
                });
                return;
            }

            // Validate message structure
            if (!message.type || typeof message.type !== 'string') {
                this.sendError(client, {
                    code: 400,
                    message: 'Message type is required'
                });
                return;
            }

            // Add metadata to message
            message.timestamp = message.timestamp || Date.now();
            message.messageId = message.messageId || uuidv4();

            this.logger.debug(`Received message from ${client.id}: ${message.type}`);

            // Handle different message types
            switch (message.type) {
                case 'authenticate':
                    await this.handleAuthentication(client, message);
                    break;
                case 'subscribe':
                    await this.handleSubscription(client, message);
                    break;
                case 'unsubscribe':
                    this.handleUnsubscription(client, message);
                    break;
                case 'ping':
                    this.handlePing(client, message);
                    break;
                case 'diagnostic_request':
                    await this.handleDiagnosticRequest(client, message);
                    break;
                case 'vehicle_status':
                    await this.handleVehicleStatusUpdate(client, message);
                    break;
                default:
                    this.sendError(client, {
                        code: 400,
                        message: `Unknown message type: ${message.type}`
                    });
            }
        } catch (error) {
            this.logger.error(`Error handling message from ${client.id}: ${error instanceof Error ? error.message : String(error)}`);
            this.sendError(client, {
                code: 500,
                message: 'Internal server error'
            });
        }
    }

    private handleClose(client: WebSocketClient, code: number, reason: string): void {
        this.logger.info(`Client ${client.id} disconnected: code=${code}, reason=${reason}`);
        this.clients.delete(client.id);
        this.emit('disconnect', client, code, reason);
    }

    private handleError(client: WebSocketClient, error: Error): void {
        this.logger.error(`Error from client ${client.id}: ${error.message}`);
        this.emit('clientError', client, error);
    }

    private handlePong(client: WebSocketClient): void {
        client.isAlive = true;
        client.lastPing = performance.now();
    }

    private async handleAuthentication(client: WebSocketClient, message: WebSocketMessage): Promise<void> {
        try {
            const { token, vehicleId } = message.payload;

            if (!token) {
                this.sendError(client, {
                    code: 400,
                    message: 'Authentication token is required'
                });
                return;
            }

            // Verify token (in a real implementation, this would validate the JWT)
            const isValid = await this.verifyToken(token);

            if (!isValid) {
                this.sendError(client, {
                    code: 401,
                    message: 'Invalid authentication token'
                });
                return;
            }

            // Extract user info from token
            const userInfo = this.decodeToken(token);

            // Update client info
            client.userId = userInfo.userId;
            client.vehicleId = vehicleId || userInfo.vehicleId;
            client.metadata = {
                ...client.metadata,
                ...userInfo,
                authenticatedAt: Date.now()
            };

            // Store client info in Redis for pub/sub
            await this.redis.hset(
                `ws:client:${client.id}`,
                'userId', userInfo.userId,
                'vehicleId', client.vehicleId || '',
                'ipAddress', client.ipAddress,
                'connectedAt', client.connectedAt.toString()
            );

            this.sendMessage(client, {
                type: 'authentication_success',
                payload: {
                    clientId: client.id,
                    userId: userInfo.userId,
                    vehicleId: client.vehicleId,
                    timestamp: Date.now()
                }
            });

            this.logger.info(`Client ${client.id} authenticated as user ${userInfo.userId}`);
        } catch (error) {
            this.logger.error(`Authentication failed for client ${client.id}: ${error instanceof Error ? error.message : String(error)}`);
            this.sendError(client, {
                code: 401,
                message: 'Authentication failed'
            });
        }
    }

    private async verifyToken(token: string): Promise<boolean> {
        // In a real implementation, this would verify the JWT
        // For now, we'll simulate it
        return new Promise(resolve => {
            setTimeout(() => {
                resolve(token === 'valid-token');
            }, 100);
        });
    }

    private decodeToken(token: string): any {
        // In a real implementation, this would decode the JWT
        return {
            userId: 'user-' + Math.floor(Math.random() * 10000),
            username: 'testuser',
            roles: ['user']
        };
    }

    private async handleSubscription(client: WebSocketClient, message: WebSocketMessage): Promise<void> {
        try {
            const { channels } = message.payload;

            if (!channels || !Array.isArray(channels)) {
                this.sendError(client, {
                    code: 400,
                    message: 'Channels must be an array'
                });
                return;
            }

            // Validate channels
            const validChannels = channels.filter(channel => this.isValidChannel(channel));
            if (validChannels.length === 0) {
                this.sendError(client, {
                    code: 400,
                    message: 'No valid channels provided'
                });
                return;
            }

            // Add subscriptions
            for (const channel of validChannels) {
                client.subscriptions.add(channel);
            }

            // Subscribe to Redis channels
            await this.redis.sadd(`ws:subscriptions:${client.id}`, ...validChannels);

            this.sendMessage(client, {
                type: 'subscription_success',
                payload: {
                    subscribedChannels: validChannels,
                    timestamp: Date.now()
                }
            });

            this.logger.info(`Client ${client.id} subscribed to channels: ${validChannels.join(', ')}`);
        } catch (error) {
            this.logger.error(`Subscription failed for client ${client.id}: ${error instanceof Error ? error.message : String(error)}`);
            this.sendError(client, {
                code: 500,
                message: 'Subscription failed'
            });
        }
    }

    private isValidChannel(channel: string): boolean {
        // Validate channel names
        const channelPattern = /^[a-zA-Z0-9:_\-]{1,50}$/;
        return channelPattern.test(channel);
    }

    private handleUnsubscription(client: WebSocketClient, message: WebSocketMessage): void {
        try {
            const { channels } = message.payload;

            if (!channels) {
                // Unsubscribe from all channels
                client.subscriptions.clear();
                this.redis.del(`ws:subscriptions:${client.id}`);
                this.sendMessage(client, {
                    type: 'unsubscription_success',
                    payload: {
                        unsubscribedChannels: 'all',
                        timestamp: Date.now()
                    }
                });
                return;
            }

            if (!Array.isArray(channels)) {
                this.sendError(client, {
                    code: 400,
                    message: 'Channels must be an array'
                });
                return;
            }

            // Remove subscriptions
            const unsubscribedChannels: string[] = [];
            for (const channel of channels) {
                if (client.subscriptions.has(channel)) {
                    client.subscriptions.delete(channel);
                    unsubscribedChannels.push(channel);
                }
            }

            if (unsubscribedChannels.length > 0) {
                this.redis.srem(`ws:subscriptions:${client.id}`, ...unsubscribedChannels);
            }

            this.sendMessage(client, {
                type: 'unsubscription_success',
                payload: {
                    unsubscribedChannels,
                    timestamp: Date.now()
                }
            });

            this.logger.info(`Client ${client.id} unsubscribed from channels: ${unsubscribedChannels.join(', ')}`);
        } catch (error) {
            this.logger.error(`Unsubscription failed for client ${client.id}: ${error instanceof Error ? error.message : String(error)}`);
            this.sendError(client, {
                code: 500,
                message: 'Unsubscription failed'
            });
        }
    }

    private handlePing(client: WebSocketClient, message: WebSocketMessage): void {
        this.sendMessage(client, {
            type: 'pong',
            payload: {
                timestamp: message.timestamp,
                serverTime: Date.now()
            }
        });
    }

    private async handleDiagnosticRequest(client: WebSocketClient, message: WebSocketMessage): Promise<void> {
        try {
            if (!client.userId) {
                this.sendError(client, {
                    code: 401,
                    message: 'Authentication required'
                });
                return;
            }

            const { vehicleId, requestId } = message.payload;

            if (!vehicleId) {
                this.sendError(client, {
                    code: 400,
                    message: 'Vehicle ID is required'
                });
                return;
            }

            // Check if user has access to this vehicle
            const hasAccess = await this.checkVehicleAccess(client.userId, vehicleId);

            if (!hasAccess) {
                this.sendError(client, {
                    code: 403,
                    message: 'Access denied to this vehicle'
                });
                return;
            }

            // Store the request in Redis for tracking
            await this.redis.hset(
                `ws:diagnostic_request:${requestId}`,
                'clientId', client.id,
                'userId', client.userId,
                'vehicleId', vehicleId,
                'status', 'pending',
                'createdAt', Date.now().toString()
            );

            // Publish the request to the diagnostic service
            await this.redis.publish(
                `diagnostic_requests:${vehicleId}`,
                JSON.stringify({
                    requestId,
                    vehicleId,
                    clientId: client.id,
                    userId: client.userId,
                    timestamp: Date.now()
                })
            );

            this.sendMessage(client, {
                type: 'diagnostic_request_ack',
                payload: {
                    requestId,
                    status: 'pending',
                    timestamp: Date.now()
                }
            });

            this.logger.info(`Diagnostic request ${requestId} for vehicle ${vehicleId} from client ${client.id}`);
        } catch (error) {
            this.logger.error(`Error handling diagnostic request from client ${client.id}: ${error instanceof Error ? error.message : String(error)}`);
            this.sendError(client, {
                code: 500,
                message: 'Failed to process diagnostic request'
            });
        }
    }

    private async checkVehicleAccess(userId: string, vehicleId: string): Promise<boolean> {
        // In a real implementation, this would check database permissions
        return new Promise(resolve => {
            setTimeout(() => {
                resolve(true);
            }, 50);
        });
    }

    private async handleVehicleStatusUpdate(client: WebSocketClient, message: WebSocketMessage): Promise<void> {
        try {
            if (!client.vehicleId) {
                this.sendError(client, {
                    code: 400,
                    message: 'Vehicle ID not associated with this connection'
                });
                return;
            }

            const { status } = message.payload;

            if (!status) {
                this.sendError(client, {
                    code: 400,
                    message: 'Status data is required'
                });
                return;
            }

            // Validate status data
            if (!this.isValidStatusData(status)) {
                this.sendError(client, {
                    code: 400,
                    message: 'Invalid status data format'
                });
                return;
            }

            // Store the status update
            await this.redis.hset(
                `vehicle:${client.vehicleId}:status`,
                'lastUpdate', Date.now().toString(),
                'data', JSON.stringify(status)
            );

            // Publish the status update to subscribers
            await this.redis.publish(
                `vehicle_status:${client.vehicleId}`,
                JSON.stringify({
                    vehicleId: client.vehicleId,
                    status,
                    timestamp: Date.now()
                })
            );

            this.sendMessage(client, {
                type: 'status_update_ack',
                payload: {
                    status: 'received',
                    timestamp: Date.now()
                }
            });

            this.logger.debug(`Vehicle status update received from ${client.id} for vehicle ${client.vehicleId}`);
        } catch (error) {
            this.logger.error(`Error handling vehicle status update from client ${client.id}: ${error instanceof Error ? error.message : String(error)}`);
            this.sendError(client, {
                code: 500,
                message: 'Failed to process status update'
            });
        }
    }

    private isValidStatusData(status: any): boolean {
        // Basic validation of status data
        if (!status || typeof status !== 'object') return false;

        const requiredFields = ['rpm', 'speed', 'engineLoad', 'coolantTemp'];
        for (const field of requiredFields) {
            if (!(field in status)) return false;
            if (typeof status[field] !== 'number') return false;
        }

        return true;
    }

    public async broadcast(channel: string, message: WebSocketMessage): Promise<void> {
        try {
            // Get all clients subscribed to this channel
            const clientIds = await this.redis.smembers(`ws:channel:${channel}`);

            if (clientIds.length === 0) {
                this.logger.debug(`No clients subscribed to channel ${channel}`);
                return;
            }

            // Queue messages for each client
            for (const clientId of clientIds) {
                this.messageQueue.push({
                    ...message,
                    payload: {
                        ...message.payload,
                        clientId
                    }
                });
            }

            this.logger.debug(`Broadcasting message to ${clientIds.length} clients on channel ${channel}`);
        } catch (error) {
            this.logger.error(`Error broadcasting to channel ${channel}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    public async sendToClient(clientId: string, message: WebSocketMessage): Promise<void> {
        const client = this.clients.get(clientId);
        if (client && client.socket.readyState === WebSocket.OPEN) {
            this.sendMessage(client, message);
        } else {
            this.logger.warn(`Client ${clientId} not found or not connected`);
        }
    }

    public async sendToUser(userId: string, message: WebSocketMessage): Promise<void> {
        try {
            // Find all clients for this user
            const clientIds = await this.redis.smembers(`ws:user:${userId}`);

            if (clientIds.length === 0) {
                this.logger.debug(`No clients found for user ${userId}`);
                return;
            }

            // Queue messages for each client
            for (const clientId of clientIds) {
                this.messageQueue.push({
                    ...message,
                    payload: {
                        ...message.payload,
                        clientId
                    }
                });
            }

            this.logger.debug(`Sending message to ${clientIds.length} clients for user ${userId}`);
        } catch (error) {
            this.logger.error(`Error sending to user ${userId}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    public async sendToVehicle(vehicleId: string, message: WebSocketMessage): Promise<void> {
        try {
            // Find all clients subscribed to this vehicle
            const clientIds = await this.redis.smembers(`ws:vehicle:${vehicleId}`);

            if (clientIds.length === 0) {
                this.logger.debug(`No clients subscribed to vehicle ${vehicleId}`);
                return;
            }

            // Queue messages for each client
            for (const clientId of clientIds) {
                this.messageQueue.push({
                    ...message,
                    payload: {
                        ...message.payload,
                        clientId
                    }
                });
            }

            this.logger.debug(`Sending message to ${clientIds.length} clients for vehicle ${vehicleId}`);
        } catch (error) {
            this.logger.error(`Error sending to vehicle ${vehicleId}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private sendMessage(client: WebSocketClient, message: WebSocketMessage): void {
        if (client.socket.readyState !== WebSocket.OPEN) {
            this.logger.warn(`Attempted to send message to closed client ${client.id}`);
            return;
        }

        try {
            client.socket.send(JSON.stringify(message));
            this.logger.debug(`Sent message to client ${client.id}: ${message.type}`);
        } catch (error) {
            this.logger.error(`Error sending message to client ${client.id}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private sendError(client: WebSocketClient, error: WebSocketError): void {
        this.sendMessage(client, {
            type: 'error',
            payload: {
                code: error.code,
                message: error.message,
                details: error.details,
                timestamp: Date.now()
            }
        });
    }

    public getClientCount(): number {
        return this.clients.size;
    }

    public getClients(): WebSocketClient[] {
        return Array.from(this.clients.values());
    }

    public getClient(clientId: string): WebSocketClient | undefined {
        return this.clients.get(clientId);
    }

    public async close(): Promise<void> {
        clearInterval(this.pingInterval);

        // Close all client connections
        this.clients.forEach(client => {
            if (client.socket.readyState === WebSocket.OPEN) {
                client.socket.close(1001, 'Server shutting down');
            }
        });

        // Close WebSocket server
        return new Promise((resolve, reject) => {
            this.wss.close((error) => {
                if (error) {
                    this.logger.error(`Error closing WebSocket server: ${error.message}`);
                    reject(error);
                } else {
                    this.logger.info('WebSocket server closed');
                    resolve();
                }
            });
        });
    }

    public async getStats(): Promise<{
        clientCount: number;
        channels: Record<string, number>;
        messageQueueSize: number;
        uptime: number;
    }> {
        // Get channel statistics
        const channelKeys = await this.redis.keys('ws:channel:*');
        const channels: Record<string, number> = {};

        for (const key of channelKeys) {
            const channel = key.split(':')[2];
            const count = await this.redis.scard(key);
            channels[channel] = count;
        }

        return {
            clientCount: this.getClientCount(),
            channels,
            messageQueueSize: this.messageQueue.length,
            uptime: performance.now()
        };
    }
}
```

### Real-Time Event Handlers

```typescript
// src/websocket/event-handlers.ts
import { WebSocketServerManager } from './websocket-server';
import { Logger } from '../utils/logger';
import { Redis } from 'ioredis';
import { performance } from 'perf_hooks';
import { DiagnosticService } from '../services/diagnostic-service';
import { VehicleService } from '../services/vehicle-service';
import { NotificationService } from '../services/notification-service';

export class WebSocketEventHandlers {
    private static instance: WebSocketEventHandlers;
    private logger: Logger;
    private wsServer: WebSocketServerManager;
    private redis: Redis;
    private diagnosticService: DiagnosticService;
    private vehicleService: VehicleService;
    private notificationService: NotificationService;
    private eventListeners: Map<string, (data: any) => Promise<void>> = new Map();

    private constructor(wsServer: WebSocketServerManager) {
        this.logger = new Logger('WebSocketEventHandlers');
        this.wsServer = wsServer;
        this.redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');
        this.diagnosticService = new DiagnosticService();
        this.vehicleService = new VehicleService();
        this.notificationService = new NotificationService();

        this.setupEventListeners();
        this.setupRedisSubscriptions();
    }

    public static getInstance(wsServer: WebSocketServerManager): WebSocketEventHandlers {
        if (!WebSocketEventHandlers.instance) {
            WebSocketEventHandlers.instance = new WebSocketEventHandlers(wsServer);
        }
        return WebSocketEventHandlers.instance;
    }

    private setupEventListeners(): void {
        // WebSocket server events
        this.wsServer.on('connection', (client) => this.handleConnection(client));
        this.wsServer.on('disconnect', (client, code, reason) => this.handleDisconnect(client, code, reason));
        this.wsServer.on('error', (error) => this.handleServerError(error));

        // Register event handlers
        this.registerEventHandler('diagnostic_update', this.handleDiagnosticUpdate.bind(this));
        this.registerEventHandler('vehicle_status', this.handleVehicleStatusUpdate.bind(this));
        this.registerEventHandler('maintenance_alert', this.handleMaintenanceAlert.bind(this));
        this.registerEventHandler('dtc_detected', this.handleDTCDetection.bind(this));
        this.registerEventHandler('diagnostic_request_response', this.handleDiagnosticRequestResponse.bind(this));
        this.registerEventHandler('firmware_update', this.handleFirmwareUpdate.bind(this));
    }

    private registerEventHandler(eventName: string, handler: (data: any) => Promise<void>): void {
        this.eventListeners.set(eventName, handler);
        this.logger.debug(`Registered event handler for: ${eventName}`);
    }

    private async handleEvent(eventName: string, data: any): Promise<void> {
        const handler = this.eventListeners.get(eventName);
        if (handler) {
            try {
                await handler(data);
            } catch (error) {
                this.logger.error(`Error handling event ${eventName}: ${error instanceof Error ? error.message : String(error)}`);
            }
        } else {
            this.logger.warn(`No handler registered for event: ${eventName}`);
        }
    }

    private setupRedisSubscriptions(): void {
        // Subscribe to Redis channels
        this.redis.subscribe(
            'diagnostic_updates',
            'vehicle_status',
            'maintenance_alerts',
            'dtc_events',
            'diagnostic_responses',
            'firmware_updates',
            (error, count) => {
                if (error) {
                    this.logger.error(`Error subscribing to Redis channels: ${error.message}`);
                } else {
                    this.logger.info(`Subscribed to ${count} Redis channels`);
                }
            }
        );

        // Handle Redis messages
        this.redis.on('message', async (channel, message) => {
            try {
                const data = JSON.parse(message);
                this.logger.debug(`Received message on channel ${channel}`);

                // Map Redis channels to event names
                const eventMap: Record<string, string> = {
                    'diagnostic_updates': 'diagnostic_update',
                    'vehicle_status': 'vehicle_status',
                    'maintenance_alerts': 'maintenance_alert',
                    'dtc_events': 'dtc_detected',
                    'diagnostic_responses': 'diagnostic_request_response',
                    'firmware_updates': 'firmware_update'
                };

                const eventName = eventMap[channel];
                if (eventName) {
                    await this.handleEvent(eventName, data);
                }
            } catch (error) {
                this.logger.error(`Error processing Redis message on channel ${channel}: ${error instanceof Error ? error.message : String(error)}`);
            }
        });
    }

    private async handleConnection(client: any): Promise<void> {
        this.logger.info(`New connection established: ${client.id}`);

        // Store client info in Redis
        await this.redis.hset(
            `ws:client:${client.id}`,
            'id', client.id,
            'ipAddress', client.ipAddress,
            'connectedAt', client.connectedAt.toString(),
            'userId', client.userId || '',
            'vehicleId', client.vehicleId || ''
        );

        // Add to user set if authenticated
        if (client.userId) {
            await this.redis.sadd(`ws:user:${client.userId}`, client.id);
        }

        // Add to vehicle set if associated with a vehicle
        if (client.vehicleId) {
            await this.redis.sadd(`ws:vehicle:${client.vehicleId}`, client.id);
        }

        // Send initial data if authenticated
        if (client.userId && client.vehicleId) {
            await this.sendInitialData(client);
        }
    }

    private async sendInitialData(client: any): Promise<void> {
        try {
            // Get current vehicle status
            const status = await this.vehicleService.getCurrentStatus(client.vehicleId);
            if (status) {
                this.wsServer.sendToClient(client.id, {
                    type: 'vehicle_status',
                    payload: {
                        vehicleId: client.vehicleId,
                        status,
                        timestamp: Date.now()
                    }
                });
            }

            // Get active DTCs
            const dtcs = await this.diagnosticService.getActiveDTCs(client.vehicleId);
            if (dtcs.length > 0) {
                this.wsServer.sendToClient(client.id, {
                    type: 'dtc_update',
                    payload: {
                        vehicleId: client.vehicleId,
                        dtcs,
                        timestamp: Date.now()
                    }
                });
            }

            // Get pending maintenance
            const maintenance = await this.vehicleService.getPendingMaintenance(client.vehicleId);
            if (maintenance.length > 0) {
                this.wsServer.sendToClient(client.id, {
                    type: 'maintenance_alert',
                    payload: {
                        vehicleId: client.vehicleId,
                        maintenance,
                        timestamp: Date.now()
                    }
                });
            }

            this.logger.debug(`Sent initial data to client ${client.id}`);
        } catch (error) {
            this.logger.error(`Error sending initial data to client ${client.id}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async handleDisconnect(client: any, code: number, reason: string): Promise<void> {
        this.logger.info(`Client disconnected: ${client.id}, code: ${code}, reason: ${reason}`);

        // Remove from Redis sets
        await this.redis.del(`ws:client:${client.id}`);

        if (client.userId) {
            await this.redis.srem(`ws:user:${client.userId}`, client.id);
        }

        if (client.vehicleId) {
            await this.redis.srem(`ws:vehicle:${client.vehicleId}`, client.id);
        }

        // Remove all subscriptions
        const subscriptions = await this.redis.smembers(`ws:subscriptions:${client.id}`);
        if (subscriptions.length > 0) {
            await this.redis.del(`ws:subscriptions:${client.id}`);
            for (const channel of subscriptions) {
                await this.redis.srem(`ws:channel:${channel}`, client.id);
            }
        }
    }

    private handleServerError(error: Error): void {
        this.logger.error(`WebSocket server error: ${error.message}`);
    }

    private async handleDiagnosticUpdate(data: any): Promise<void> {
        this.logger.debug(`Handling diagnostic update for vehicle ${data.vehicleId}`);

        try {
            // Broadcast to all clients subscribed to this vehicle
            await this.wsServer.sendToVehicle(data.vehicleId, {
                type: 'diagnostic_update',
                payload: {
                    vehicleId: data.vehicleId,
                    data: data.data,
                    timestamp: data.timestamp
                }
            });

            // Store the update in Redis
            await this.redis.hset(
                `vehicle:${data.vehicleId}:diagnostics`,
                'lastUpdate', data.timestamp.toString(),
                'data', JSON.stringify(data.data)
            );

            // Check for critical issues
            if (data.data.criticalIssues > 0) {
                await this.handleCriticalDiagnostic(data.vehicleId, data.data);
            }
        } catch (error) {
            this.logger.error(`Error handling diagnostic update: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async handleCriticalDiagnostic(vehicleId: string, data: any): Promise<void> {
        try {
            // Get vehicle info
            const vehicle = await this.vehicleService.getVehicle(vehicleId);
            if (!vehicle) return;

            // Get user info
            const userIds = await this.redis.smembers(`vehicle:${vehicleId}:users`);
            if (userIds.length === 0) return;

            // Create notification
            const notification = {
                type: 'critical_diagnostic',
                title: 'Critical Vehicle Issue Detected',
                message: `Your ${vehicle.make} ${vehicle.model} has ${data.criticalIssues} critical issue(s) that require immediate attention.`,
                vehicleId,
                data,
                timestamp: Date.now(),
                read: false
            };

            // Send notifications to all users associated with this vehicle
            for (const userId of userIds) {
                await this.notificationService.createNotification(userId, notification);

                // Send WebSocket notification
                await this.wsServer.sendToUser(userId, {
                    type: 'notification',
                    payload: {
                        userId,
                        notification,
                        timestamp: Date.now()
                    }
                });
            }

            // Send SMS alert if configured
            await this.notificationService.sendSMSAlert(userIds, notification);
        } catch (error) {
            this.logger.error(`Error handling critical diagnostic: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async handleVehicleStatusUpdate(data: any): Promise<void> {
        this.logger.debug(`Handling vehicle status update for ${data.vehicleId}`);

        try {
            // Broadcast to all clients subscribed to this vehicle
            await this.wsServer.sendToVehicle(data.vehicleId, {
                type: 'vehicle_status',
                payload: {
                    vehicleId: data.vehicleId,
                    status: data.status,
                    timestamp: data.timestamp
                }
            });

            // Store the status in Redis
            await this.redis.hset(
                `vehicle:${data.vehicleId}:status`,
                'lastUpdate', data.timestamp.toString(),
                'data', JSON.stringify(data.status)
            );

            // Check for abnormal conditions
            await this.checkAbnormalConditions(data.vehicleId, data.status);
        } catch (error) {
            this.logger.error(`Error handling vehicle status update: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async checkAbnormalConditions(vehicleId: string, status: any): Promise<void> {
        try {
            const abnormalConditions = [];

            // Check engine temperature
            if (status.coolantTemp > 110) {
                abnormalConditions.push({
                    type: 'high_engine_temp',
                    value: status.coolantTemp,
                    threshold: 110,
                    severity: 'CRITICAL'
                });
            }

            // Check RPM
            if (status.rpm > 6000) {
                abnormalConditions.push({
                    type: 'high_rpm',
                    value: status.rpm,
                    threshold: 6000,
                    severity: 'WARNING'
                });
            }

            // Check engine load
            if (status.engineLoad > 90) {
                abnormalConditions.push({
                    type: 'high_engine_load',
                    value: status.engineLoad,
                    threshold: 90,
                    severity: 'WARNING'
                });
            }

            if (abnormalConditions.length > 0) {
                // Get vehicle info
                const vehicle = await this.vehicleService.getVehicle(vehicleId);
                if (!vehicle) return;

                // Get user info
                const userIds = await this.redis.smembers(`vehicle:${vehicleId}:users`);
                if (userIds.length === 0) return;

                // Create notification for each abnormal condition
                for (const condition of abnormalConditions) {
                    const notification = {
                        type: 'abnormal_condition',
                        title: `Vehicle Alert: ${condition.type.replace(/_/g, ' ').toUpperCase()}`,
                        message: `Your ${vehicle.make} ${vehicle.model} has detected ${condition.type.replace(/_/g, ' ')} (${condition.value} > ${condition.threshold}).`,
                        vehicleId,
                        data: condition,
                        timestamp: Date.now(),
                        read: false
                    };

                    // Send notifications to all users associated with this vehicle
                    for (const userId of userIds) {
                        await this.notificationService.createNotification(userId, notification);

                        // Send WebSocket notification
                        await this.wsServer.sendToUser(userId, {
                            type: 'notification',
                            payload: {
                                userId,
                                notification,
                                timestamp: Date.now()
                            }
                        });
                    }
                }
            }
        } catch (error) {
            this.logger.error(`Error checking abnormal conditions: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async handleMaintenanceAlert(data: any): Promise<void> {
        this.logger.debug(`Handling maintenance alert for vehicle ${data.vehicleId}`);

        try {
            // Broadcast to all clients subscribed to this vehicle
            await this.wsServer.sendToVehicle(data.vehicleId, {
                type: 'maintenance_alert',
                payload: {
                    vehicleId: data.vehicleId,
                    maintenance: data.maintenance,
                    timestamp: data.timestamp
                }
            });

            // Store the alert in Redis
            await this.redis.hset(
                `vehicle:${data.vehicleId}:maintenance`,
                'lastAlert', data.timestamp.toString(),
                'data', JSON.stringify(data.maintenance)
            );

            // Create notifications for users
            await this.createMaintenanceNotifications(data.vehicleId, data.maintenance);
        } catch (error) {
            this.logger.error(`Error handling maintenance alert: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async createMaintenanceNotifications(vehicleId: string, maintenance: any[]): Promise<void> {
        try {
            // Get vehicle info
            const vehicle = await this.vehicleService.getVehicle(vehicleId);
            if (!vehicle) return;

            // Get user info
            const userIds = await this.redis.smembers(`vehicle:${vehicleId}:users`);
            if (userIds.length === 0) return;

            // Create notification for each maintenance item
            for (const item of maintenance) {
                const notification = {
                    type: 'maintenance_alert',
                    title: `Maintenance Required: ${item.service_type}`,
                    message: `Your ${vehicle.make} ${vehicle.model} is due for ${item.service_type} (${item.description}).`,
                    vehicleId,
                    data: item,
                    timestamp: Date.now(),
                    read: false
                };

                // Send notifications to all users associated with this vehicle
                for (const userId of userIds) {
                    await this.notificationService.createNotification(userId, notification);

                    // Send WebSocket notification
                    await this.wsServer.sendToUser(userId, {
                        type: 'notification',
                        payload: {
                            userId,
                            notification,
                            timestamp: Date.now()
                        }
                    });
                }
            }
        } catch (error) {
            this.logger.error(`Error creating maintenance notifications: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async handleDTCDetection(data: any): Promise<void> {
        this.logger.debug(`Handling DTC detection for vehicle ${data.vehicleId}: ${data.dtc_code}`);

        try {
            // Broadcast to all clients subscribed to this vehicle
            await this.wsServer.sendToVehicle(data.vehicleId, {
                type: 'dtc_detected',
                payload: {
                    vehicleId: data.vehicleId,
                    dtc: data,
                    timestamp: data.timestamp
                }
            });

            // Store the DTC in Redis
            await this.redis.hset(
                `vehicle:${data.vehicleId}:dtc:${data.dtc_code}`,
                'code', data.dtc_code,
                'description', data.description,
                'severity', data.severity,
                'timestamp', data.timestamp.toString(),
                'status', 'active'
            );

            // Add to active DTCs set
            await this.redis.sadd(`vehicle:${data.vehicleId}:active_dtcs`, data.dtc_code);

            // Create notification for users
            await this.createDTCDetectionNotification(data);
        } catch (error) {
            this.logger.error(`Error handling DTC detection: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async createDTCDetectionNotification(data: any): Promise<void> {
        try {
            // Get vehicle info
            const vehicle = await this.vehicleService.getVehicle(data.vehicleId);
            if (!vehicle) return;

            // Get user info
            const userIds = await this.redis.smembers(`vehicle:${data.vehicleId}:users`);
            if (userIds.length === 0) return;

            // Create notification
            const notification = {
                type: 'dtc_alert',
                title: `Diagnostic Trouble Code Detected: ${data.dtc_code}`,
                message: `Your ${vehicle.make} ${vehicle.model} has detected a ${data.severity.toLowerCase()} issue: ${data.description}.`,
                vehicleId: data.vehicleId,
                data: {
                    dtc_code: data.dtc_code,
                    description: data.description,
                    severity: data.severity,
                    timestamp: data.timestamp
                },
                timestamp: Date.now(),
                read: false
            };

            // Send notifications to all users associated with this vehicle
            for (const userId of userIds) {
                await this.notificationService.createNotification(userId, notification);

                // Send WebSocket notification
                await this.wsServer.sendToUser(userId, {
                    type: 'notification',
                    payload: {
                        userId,
                        notification,
                        timestamp: Date.now()
                    }
                });
            }

            // Send SMS alert for critical DTCs
            if (data.severity === 'CRITICAL') {
                await this.notificationService.sendSMSAlert(userIds, notification);
            }
        } catch (error) {
            this.logger.error(`Error creating DTC detection notification: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async handleDiagnosticRequestResponse(data: any): Promise<void> {
        this.logger.debug(`Handling diagnostic request response for request ${data.requestId}`);

        try {
            // Get the original request info
            const requestInfo = await this.redis.hgetall(`ws:diagnostic_request:${data.requestId}`);
            if (!requestInfo || Object.keys(requestInfo).length === 0) {
                this.logger.warn(`No request info found for request ${data.requestId}`);
                return;
            }

            // Send response to the requesting client
            await this.wsServer.sendToClient(requestInfo.clientId, {
                type: 'diagnostic_response',
                payload: {
                    requestId: data.requestId,
                    vehicleId: data.vehicleId,
                    status: data.status,
                    data: data.data,
                    timestamp: data.timestamp
                }
            });

            // Update request status in Redis
            await this.redis.hset(
                `ws:diagnostic_request:${data.requestId}`,
                'status', data.status,
                'completedAt', Date.now().toString()
            );

            // If the request failed, create a notification
            if (data.status === 'failed') {
                await this.createDiagnosticFailureNotification(requestInfo.userId, data);
            }
        } catch (error) {
            this.logger.error(`Error handling diagnostic request response: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async createDiagnosticFailureNotification(userId: string, data: any): Promise<void> {
        try {
            // Get vehicle info
            const vehicle = await this.vehicleService.getVehicle(data.vehicleId);
            if (!vehicle) return;

            // Create notification
            const notification = {
                type: 'diagnostic_failure',
                title: 'Diagnostic Request Failed',
                message: `The diagnostic request for your ${vehicle.make} ${vehicle.model} failed: ${data.error || 'Unknown error'}.`,
                vehicleId: data.vehicleId,
                data: {
                    requestId: data.requestId,
                    error: data.error,
                    timestamp: data.timestamp
                },
                timestamp: Date.now(),
                read: false
            };

            // Create notification
            await this.notificationService.createNotification(userId, notification);

            // Send WebSocket notification
            await this.wsServer.sendToUser(userId, {
                type: 'notification',
                payload: {
                    userId,
                    notification,
                    timestamp: Date.now()
                }
            });
        } catch (error) {
            this.logger.error(`Error creating diagnostic failure notification: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async handleFirmwareUpdate(data: any): Promise<void> {
        this.logger.debug(`Handling firmware update for vehicle ${data.vehicleId}`);

        try {
            // Broadcast to all clients subscribed to this vehicle
            await this.wsServer.sendToVehicle(data.vehicleId, {
                type: 'firmware_update',
                payload: {
                    vehicleId: data.vehicleId,
                    update: data.update,
                    timestamp: data.timestamp
                }
            });

            // Store the update status in Redis
            await this.redis.hset(
                `vehicle:${data.vehicleId}:firmware`,
                'lastUpdate', data.timestamp.toString(),
                'status', data.update.status,
                'version', data.update.version,
                'progress', data.update.progress.toString()
            );

            // Create notification for users if update is available
            if (data.update.status === 'available') {
                await this.createFirmwareUpdateNotification(data.vehicleId, data.update);
            }
        } catch (error) {
            this.logger.error(`Error handling firmware update: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async createFirmwareUpdateNotification(vehicleId: string, update: any): Promise<void> {
        try {
            // Get vehicle info
            const vehicle = await this.vehicleService.getVehicle(vehicleId);
            if (!vehicle) return;

            // Get user info
            const userIds = await this.redis.smembers(`vehicle:${vehicleId}:users`);
            if (userIds.length === 0) return;

            // Create notification
            const notification = {
                type: 'firmware_update',
                title: `Firmware Update Available: v${update.version}`,
                message: `A new firmware update (v${update.version}) is available for your ${vehicle.make} ${vehicle.model}.`,
                vehicleId,
                data: update,
                timestamp: Date.now(),
                read: false
            };

            // Send notifications to all users associated with this vehicle
            for (const userId of userIds) {
                await this.notificationService.createNotification(userId, notification);

                // Send WebSocket notification
                await this.wsServer.sendToUser(userId, {
                    type: 'notification',
                    payload: {
                        userId,
                        notification,
                        timestamp: Date.now()
                    }
                });
            }
        } catch (error) {
            this.logger.error(`Error creating firmware update notification: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    public async broadcastSystemMessage(message: string, options: { type?: string; level?: 'info' | 'warning' | 'error' } = {}): Promise<void> {
        const { type = 'system_message', level = 'info' } = options;

        try {
            await this.wsServer.broadcast('system_messages', {
                type,
                payload: {
                    message,
                    level,
                    timestamp: Date.now()
                }
            });

            this.logger.info(`Broadcast system message: ${message}`);
        } catch (error) {
            this.logger.error(`Error broadcasting system message: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    public async getActiveSubscriptions(): Promise<Record<string, number>> {
        try {
            const channels = await this.redis.keys('ws:channel:*');
            const result: Record<string, number> = {};

            for (const channel of channels) {
                const channelName = channel.split(':')[2];
                const count = await this.redis.scard(channel);
                result[channelName] = count;
            }

            return result;
        } catch (error) {
            this.logger.error(`Error getting active subscriptions: ${error instanceof Error ? error.message : String(error)}`);
            return {};
        }
    }

    public async close(): Promise<void> {
        try {
            // Unsubscribe from Redis channels
            await this.redis.unsubscribe(
                'diagnostic_updates',
                'vehicle_status',
                'maintenance_alerts',
                'dtc_events',
                'diagnostic_responses',
                'firmware_updates'
            );

            // Close Redis connection
            await this.redis.quit();

            this.logger.info('WebSocket event handlers closed');
        } catch (error) {
            this.logger.error(`Error closing WebSocket event handlers: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }
}
```

### Client-Side WebSocket Integration

```typescript
// src/websocket/websocket-client.ts
import { Logger } from '../utils/logger';
import { EventEmitter } from 'events';
import { v4 as uuidv4 } from 'uuid';

interface WebSocketConfig {
    url: string;
    reconnectInterval?: number;
    maxReconnectAttempts?: number;
    heartbeatInterval?: number;
    autoReconnect?: boolean;
    protocols?: string | string[];
    token?: string;
    vehicleId?: string;
}

interface WebSocketMessage {
    type: string;
    payload: any;
    timestamp: number;
    messageId?: string;
}

interface WebSocketError {
    code: number;
    message: string;
    details?: any;
}

interface ConnectionState {
    connected: boolean;
    connecting: boolean;
    reconnectAttempts: number;
    lastConnectionTime: number;
    lastDisconnectionTime: number;
    lastError?: WebSocketError;
}

export class WebSocketClient extends EventEmitter {
    private static instance: WebSocketClient;
    private socket: WebSocket | null = null;
    private logger: Logger;
    private config: WebSocketConfig;
    private connectionState: ConnectionState = {
        connected: false,
        connecting: false,
        reconnectAttempts: 0,
        lastConnectionTime: 0,
        lastDisconnectionTime: 0
    };
    private reconnectTimer: NodeJS.Timeout | null = null;
    private heartbeatTimer: NodeJS.Timeout | null = null;
    private messageQueue: WebSocketMessage[] = [];
    private pendingRequests: Map<string, { resolve: (value: any) => void; reject: (reason?: any) => void }> = new Map();
    private subscriptions: Set<string> = new Set();
    private messageBuffer: string[] = [];
    private bufferFlushTimer: NodeJS.Timeout | null = null;

    private constructor(config: WebSocketConfig) {
        super();
        this.config = {
            reconnectInterval: 5000,
            maxReconnectAttempts: 10,
            heartbeatInterval: 30000,
            autoReconnect: true,
            ...config
        };

        this.logger = new Logger('WebSocketClient');
        this.initialize();
    }

    public static getInstance(config: WebSocketConfig): WebSocketClient {
        if (!WebSocketClient.instance) {
            WebSocketClient.instance = new WebSocketClient(config);
        }
        return WebSocketClient.instance;
    }

    private initialize(): void {
        this.setupEventListeners();
        this.connect();
    }

    private setupEventListeners(): void {
        // Handle global online/offline events
        window.addEventListener('online', () => this.handleOnline());
        window.addEventListener('offline', () => this.handleOffline());
    }

    private connect(): void {
        if (this.connectionState.connected || this.connectionState.connecting) {
            this.logger.debug('Already connected or connecting');
            return;
        }

        this.connectionState.connecting = true;
        this.connectionState.reconnectAttempts++;

        this.logger.info(`Connecting to WebSocket server at ${this.config.url}`);

        try {
            // Create WebSocket connection
            this.socket = new WebSocket(this.config.url, this.config.protocols);

            // Set up event listeners
            this.socket.onopen = () => this.handleOpen();
            this.socket.onmessage = (event) => this.handleMessage(event);
            this.socket.onclose = (event) => this.handleClose(event);
            this.socket.onerror = (event) => this.handleError(event);

            // Set up heartbeat
            this.setupHeartbeat();
        } catch (error) {
            this.logger.error(`Error creating WebSocket connection: ${error instanceof Error ? error.message : String(error)}`);
            this.handleConnectionFailure();
        }
    }

    private handleOpen(): void {
        this.connectionState.connected = true;
        this.connectionState.connecting = false;
        this.connectionState.reconnectAttempts = 0;
        this.connectionState.lastConnectionTime = Date.now();
        this.connectionState.lastError = undefined;

        this.logger.info('WebSocket connection established');

        // Authenticate if token is provided
        if (this.config.token) {
            this.authenticate(this.config.token, this.config.vehicleId);
        }

        // Process queued messages
        this.processMessageQueue();

        // Emit connection event
        this.emit('connect');

        // Flush any buffered messages
        this.flushMessageBuffer();
    }

    private handleMessage(event: MessageEvent): void {
        try {
            let message: WebSocketMessage;

            // Handle binary data (if needed)
            if (event.data instanceof Blob) {
                const reader = new FileReader();
                reader.onload = () => {
                    try {
                        message = JSON.parse(reader.result as string);
                        this.processMessage(message);
                    } catch (error) {
                        this.logger.error(`Error parsing binary message: ${error instanceof Error ? error.message : String(error)}`);
                    }
                };
                reader.readAsText(event.data);
                return;
            }

            // Parse JSON message
            message = JSON.parse(event.data);
            this.processMessage(message);
        } catch (error) {
            this.logger.error(`Error processing message: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private processMessage(message: WebSocketMessage): void {
        this.logger.debug(`Received message: ${message.type}`);

        // Handle system messages
        if (message.type === 'welcome') {
            this.handleWelcomeMessage(message);
        } else if (message.type === 'authentication_success') {
            this.handleAuthenticationSuccess(message);
        } else if (message.type === 'authentication_failed') {
            this.handleAuthenticationFailed(message);
        } else if (message.type === 'subscription_success') {
            this.handleSubscriptionSuccess(message);
        } else if (message.type === 'unsubscription_success') {
            this.handleUnsubscriptionSuccess(message);
        } else if (message.type === 'error') {
            this.handleErrorMessage(message);
        } else if (message.type === 'pong') {
            this.handlePongMessage(message);
        }

        // Handle response to pending requests
        if (message.messageId && this.pendingRequests.has(message.messageId)) {
            const { resolve, reject } = this.pendingRequests.get(message.messageId)!;

            if (message.type === 'error') {
                reject(message.payload);
            } else {
                resolve(message.payload);
            }

            this.pendingRequests.delete(message.messageId);
        }

        // Emit the message to listeners
        this.emit(message.type, message.payload);
        this.emit('message', message);
    }

    private handleWelcomeMessage(message: WebSocketMessage): void {
        this.logger.info(`Welcome message received: ${JSON.stringify(message.payload)}`);
        this.emit('welcome', message.payload);
    }

    private handleAuthenticationSuccess(message: WebSocketMessage): void {
        this.logger.info('Authentication successful');
        this.emit('authenticated', message.payload);

        // Resubscribe to channels after authentication
        if (this.subscriptions.size > 0) {
            this.subscribe(Array.from(this.subscriptions));
        }
    }

    private handleAuthenticationFailed(message: WebSocketMessage): void {
        this.logger.error('Authentication failed');
        this.emit('authentication_failed', message.payload);
    }

    private handleSubscriptionSuccess(message: WebSocketMessage): void {
        this.logger.debug(`Subscription successful: ${JSON.stringify(message.payload.subscribedChannels)}`);
        this.emit('subscribed', message.payload);
    }

    private handleUnsubscriptionSuccess(message: WebSocketMessage): void {
        this.logger.debug(`Unsubscription successful: ${JSON.stringify(message.payload.unsubscribedChannels)}`);
        this.emit('unsubscribed', message.payload);
    }

    private handleErrorMessage(message: WebSocketMessage): void {
        this.logger.error(`Server error: ${message.payload.message}`);
        this.emit('error', message.payload);

        // Handle specific error types
        if (message.payload.code === 401) {
            this.emit('unauthorized', message.payload);
        } else if (message.payload.code === 429) {
            this.emit('rate_limited', message.payload);
        }
    }

    private handlePongMessage(message: WebSocketMessage): void {
        this.logger.debug('Pong received');
        this.emit('pong', message.payload);
    }

    private handleClose(event: CloseEvent): void {
        this.connectionState.connected = false;
        this.connectionState.connecting = false;
        this.connectionState.lastDisconnectionTime = Date.now();

        this.logger.info(`WebSocket connection closed: code=${event.code}, reason=${event.reason}`);

        // Clear heartbeat
        this.clearHeartbeat();

        // Emit close event
        this.emit('close', event);

        // Attempt reconnect if configured
        if (this.config.autoReconnect && event.code !== 1000) {
            this.scheduleReconnect();
        }
    }

    private handleError(event: Event): void {
        this.logger.error('WebSocket error occurred');

        // Store the last error
        this.connectionState.lastError = {
            code: 0,
            message: 'WebSocket error occurred'
        };

        // Emit error event
        this.emit('error', event);

        // If we're not connected, attempt reconnect
        if (!this.connectionState.connected && this.config.autoReconnect) {
            this.scheduleReconnect();
        }
    }

    private handleConnectionFailure(): void {
        this.connectionState.connected = false;
        this.connectionState.connecting = false;

        this.logger.error('WebSocket connection failed');

        // Clear heartbeat
        this.clearHeartbeat();

        // Emit error event
        this.emit('connection_failed');

        // Attempt reconnect if configured
        if (this.config.autoReconnect) {
            this.scheduleReconnect();
        }
    }

    private handleOnline(): void {
        this.logger.info('Network connection restored');
        this.emit('online');

        // Attempt to reconnect if we're not connected
        if (!this.connectionState.connected && this.config.autoReconnect) {
            this.connect();
        }
    }

    private handleOffline(): void {
        this.logger.warn('Network connection lost');
        this.emit('offline');
    }

    private scheduleReconnect(): void {
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
        }

        if (this.connectionState.reconnectAttempts >= this.config.maxReconnectAttempts!) {
            this.logger.warn(`Max reconnect attempts (${this.config.maxReconnectAttempts}) reached`);
            this.emit('max_reconnect_attempts');
            return;
        }

        const delay = Math.min(
            this.config.reconnectInterval! * this.connectionState.reconnectAttempts,
            30000
        );

        this.logger.info(`Attempting to reconnect in ${delay}ms (attempt ${this.connectionState.reconnectAttempts})`);

        this.reconnectTimer = setTimeout(() => {
            this.connect();
        }, delay);
    }

    private setupHeartbeat(): void {
        // Clear existing heartbeat
        this.clearHeartbeat();

        // Send ping every heartbeat interval
        this.heartbeatTimer = setInterval(() => {
            if (this.connectionState.connected && this.socket?.readyState === WebSocket.OPEN) {
                this.ping();
            }
        }, this.config.heartbeatInterval);
    }

    private clearHeartbeat(): void {
        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
    }

    private processMessageQueue(): void {
        if (this.messageQueue.length === 0 || !this.connectionState.connected) {
            return;
        }

        this.logger.debug(`Processing ${this.messageQueue.length} queued messages`);

        while (this.messageQueue.length > 0) {
            const message = this.messageQueue.shift()!;
            this.sendMessage(message);
        }
    }

    private sendMessage(message: WebSocketMessage): void {
        if (!this.connectionState.connected || !this.socket || this.socket.readyState !== WebSocket.OPEN) {
            this.logger.warn(`WebSocket not connected, queueing message: ${message.type}`);
            this.messageQueue.push(message);
            return;
        }

        try {
            // Add message ID if not present
            if (!message.messageId) {
                message.messageId = uuidv4();
            }

            // Add timestamp if not present
            if (!message.timestamp) {
                message.timestamp = Date.now();
            }

            this.socket.send(JSON.stringify(message));
            this.logger.debug(`Sent message: ${message.type}`);
        } catch (error) {
            this.logger.error(`Error sending message: ${error instanceof Error ? error.message : String(error)}`);
            this.messageQueue.push(message);
        }
    }

    public authenticate(token: string, vehicleId?: string): void {
        this.config.token = token;
        this.config.vehicleId = vehicleId;

        this.sendMessage({
            type: 'authenticate',
            payload: {
                token,
                vehicleId
            },
            timestamp: Date.now()
        });
    }

    public subscribe(channels: string | string[]): void {
        const channelList = Array.isArray(channels) ? channels : [channels];

        // Add to local subscriptions
        channelList.forEach(channel => this.subscriptions.add(channel));

        this.sendMessage({
            type: 'subscribe',
            payload: {
                channels: channelList
            },
            timestamp: Date.now()
        });
    }

    public unsubscribe(channels?: string | string[]): void {
        if (!channels) {
            // Unsubscribe from all channels
            this.subscriptions.clear();

            this.sendMessage({
                type: 'unsubscribe',
                payload: {},
                timestamp: Date.now()
            });
            return;
        }

        const channelList = Array.isArray(channels) ? channels : [channels];

        // Remove from local subscriptions
        channelList.forEach(channel => this.subscriptions.delete(channel));

        this.sendMessage({
            type: 'unsubscribe',
            payload: {
                channels: channelList
            },
            timestamp: Date.now()
        });
    }

    public requestDiagnostics(vehicleId: string, options: any = {}): Promise<any> {
        const requestId = uuidv4();

        return new Promise((resolve, reject) => {
            this.pendingRequests.set(requestId, { resolve, reject });

            this.sendMessage({
                type: 'diagnostic_request',
                payload: {
                    vehicleId,
                    requestId,
                    options
                },
                timestamp: Date.now(),
                messageId: requestId
            });
        });
    }

    public updateVehicleStatus(status: any): void {
        this.sendMessage({
            type: 'vehicle_status',
            payload: {
                status
            },
            timestamp: Date.now()
        });
    }

    public ping(): void {
        this.sendMessage({
            type: 'ping',
            payload: {},
            timestamp: Date.now()
        });
    }

    public send(type: string, payload: any): void {
        this.sendMessage({
            type,
            payload,
            timestamp: Date.now()
        });
    }

    public sendBuffered(type: string, payload: any): void {
        const message = JSON.stringify({
            type,
            payload,
            timestamp: Date.now()
        });

        this.messageBuffer.push(message);

        // Flush buffer immediately if we have more than 10 messages
        if (this.messageBuffer.length > 10) {
            this.flushMessageBuffer();
        } else if (!this.bufferFlushTimer) {
            // Set up flush timer if not already set
            this.bufferFlushTimer = setTimeout(() => {
                this.flushMessageBuffer();
            }, 100);
        }
    }

    private flushMessageBuffer(): void {
        if (this.messageBuffer.length === 0) return;

        if (this.bufferFlushTimer) {
            clearTimeout(this.bufferFlushTimer);
            this.bufferFlushTimer = null;
        }

        if (!this.connectionState.connected || !this.socket || this.socket.readyState !== WebSocket.OPEN) {
            this.logger.warn('WebSocket not connected, clearing message buffer');
            this.messageBuffer = [];
            return;
        }

        try {
            // Send all buffered messages as a batch
            const batchMessage = {
                type: 'batch',
                payload: this.messageBuffer.map(msg => JSON.parse(msg)),
                timestamp: Date.now()
            };

            this.socket.send(JSON.stringify(batchMessage));
            this.logger.debug(`Sent batch of ${this.messageBuffer.length} messages`);
            this.messageBuffer = [];
        } catch (error) {
            this.logger.error(`Error sending message batch: ${error instanceof Error ? error.message : String(error)}`);
            // Keep messages in buffer for next attempt
        }
    }

    public getConnectionState(): ConnectionState {
        return { ...this.connectionState };
    }

    public getSubscriptions(): string[] {
        return Array.from(this.subscriptions);
    }

    public getPendingRequests(): string[] {
        return Array.from(this.pendingRequests.keys());
    }

    public getMessageQueueSize(): number {
        return this.messageQueue.length;
    }

    public disconnect(): void {
        this.logger.info('Disconnecting WebSocket');

        // Clear reconnect timer
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
        }

        // Clear heartbeat
        this.clearHeartbeat();

        // Close connection
        if (this.socket) {
            this.socket.close(1000, 'Client initiated disconnect');
        }

        this.connectionState.connected = false;
        this.connectionState.connecting = false;
    }

    public reconnect(): void {
        this.logger.info('Reconnecting WebSocket');
        this.disconnect();
        this.connect();
    }

    public isConnected(): boolean {
        return this.connectionState.connected;
    }

    public getStats(): {
        connectionState: ConnectionState;
        subscriptions: string[];
        messageQueueSize: number;
        pendingRequests: number;
    } {
        return {
            connectionState: this.getConnectionState(),
            subscriptions: this.getSubscriptions(),
            messageQueueSize: this.getMessageQueueSize(),
            pendingRequests: this.pendingRequests.size
        };
    }
}

// Example usage in a React component
export class WebSocketDiagnosticComponent {
    private wsClient: WebSocketClient;
    private logger: Logger;
    private unsubscribeFunctions: (() => void)[] = [];

    constructor() {
        this.logger = new Logger('WebSocketDiagnosticComponent');

        // Initialize WebSocket client
        this.wsClient = WebSocketClient.getInstance({
            url: 'wss://api.obd2-diagnostics.com/ws',
            token: localStorage.getItem('authToken') || '',
            vehicleId: localStorage.getItem('currentVehicleId') || undefined
        });

        this.setupEventListeners();
    }

    private setupEventListeners(): void {
        // Connection events
        this.unsubscribeFunctions.push(
            this.wsClient.on('connect', () => this.handleConnect()),
            this.wsClient.on('close', (event) => this.handleClose(event)),
            this.wsClient.on('error', (error) => this.handleError(error)),
            this.wsClient.on('authenticated', (data) => this.handleAuthenticated(data))
        );

        // Diagnostic events
        this.unsubscribeFunctions.push(
            this.wsClient.on('diagnostic_update', (data) => this.handleDiagnosticUpdate(data)),
            this.wsClient.on('vehicle_status', (data) => this.handleVehicleStatus(data)),
            this.wsClient.on('dtc_detected', (data) => this.handleDTCDetection(data)),
            this.wsClient.on('maintenance_alert', (data) => this.handleMaintenanceAlert(data)),
            this.wsClient.on('notification', (data) => this.handleNotification(data))
        );
    }

    private handleConnect(): void {
        this.logger.info('WebSocket connected');
        // You could update UI state here
    }

    private handleClose(event: CloseEvent): void {
        this.logger.info(`WebSocket closed: ${event.code} - ${event.reason}`);
        // You could update UI state here
    }

    private handleError(error: any): void {
        this.logger.error(`WebSocket error: ${error instanceof Error ? error.message : String(error)}`);
        // You could show error to user
    }

    private handleAuthenticated(data: any): void {
        this.logger.info('WebSocket authenticated');
        // Subscribe to vehicle-specific channels
        if (data.vehicleId) {
            this.wsClient.subscribe([
                `vehicle:${data.vehicleId}`,
                `user:${data.userId}`
            ]);
        }
    }

    private handleDiagnosticUpdate(data: any): void {
        this.logger.debug(`Diagnostic update received: ${JSON.stringify(data)}`);
        // Update diagnostic display
        this.updateDiagnosticDisplay(data.data);
    }

    private handleVehicleStatus(data: any): void {
        this.logger.debug(`Vehicle status update received: ${JSON.stringify(data)}`);
        // Update vehicle status display
        this.updateVehicleStatus(data.status);
    }

    private handleDTCDetection(data: any): void {
        this.logger.info(`DTC detected: ${data.dtc.dtc_code} - ${data.dtc.description}`);
        // Show DTC alert to user
        this.showDTCAlert(data.dtc);
    }

    private handleMaintenanceAlert(data: any): void {
        this.logger.info(`Maintenance alert: ${data.maintenance.length} items`);
        // Show maintenance alert to user
        this.showMaintenanceAlert(data.maintenance);
    }

    private handleNotification(data: any): void {
        this.logger.info(`Notification received: ${data.notification.title}`);
        // Show notification to user
        this.showNotification(data.notification);
    }

    private updateDiagnosticDisplay(data: any): void {
        // Implementation would update the UI with diagnostic data
        console.log('Updating diagnostic display:', data);
    }

    private updateVehicleStatus(status: any): void {
        // Implementation would update the UI with vehicle status
        console.log('Updating vehicle status:', status);
    }

    private showDTCAlert(dtc: any): void {
        // Implementation would show an alert to the user
        console.log('Showing DTC alert:', dtc);
        alert(`DTC Detected: ${dtc.dtc_code}\n${dtc.description}\nSeverity: ${dtc.severity}`);
    }

    private showMaintenanceAlert(maintenance: any[]): void {
        // Implementation would show maintenance alerts to the user
        console.log('Showing maintenance alerts:', maintenance);
        const alertMessage = maintenance.map(item =>
            `${item.service_type}: ${item.description} (Due: ${item.due_date || item.due_mileage})`
        ).join('\n\n');
        alert(`Maintenance Required:\n\n${alertMessage}`);
    }

    private showNotification(notification: any): void {
        // Implementation would show a notification to the user
        console.log('Showing notification:', notification);
        alert(`${notification.title}\n${notification.message}`);
    }

    public requestDiagnostics(): void {
        const vehicleId = localStorage.getItem('currentVehicleId');
        if (!vehicleId) {
            this.logger.warn('No vehicle selected');
            return;
        }

        this.logger.info(`Requesting diagnostics for vehicle ${vehicleId}`);

        this.wsClient.requestDiagnostics(vehicleId)
            .then(response => {
                this.logger.info('Diagnostic request successful:', response);
                // Update UI with response
            })
            .catch(error => {
                this.logger.error('Diagnostic request failed:', error);
                // Show error to user
            });
    }

    public updateVehicleStatus(status: any): void {
        this.wsClient.updateVehicleStatus(status);
    }

    public disconnect(): void {
        // Clean up event listeners
        this.unsubscribeFunctions.forEach(unsubscribe => unsubscribe());
        this.unsubscribeFunctions = [];

        // Disconnect WebSocket
        this.wsClient.disconnect();
    }

    public getConnectionStatus(): string {
        const state = this.wsClient.getConnectionState();
        if (state.connected) return 'connected';
        if (state.connecting) return 'connecting';
        return 'disconnected';
    }
}
```

### Room/Channel Management

```typescript
// src/websocket/room-manager.ts
import { Redis } from 'ioredis';
import { Logger } from '../utils/logger';
import { WebSocketServerManager } from './websocket-server';
import { performance } from 'perf_hooks';
import { EventEmitter } from 'events';

interface Room {
    id: string;
    name: string;
    description?: string;
    createdAt: number;
    createdBy?: string;
    metadata?: Record<string, any>;
    memberCount: number;
}

interface RoomMember {
    clientId: string;
    userId?: string;
    vehicleId?: string;
    joinedAt: number;
    role: 'owner' | 'admin' | 'member';
    metadata?: Record<string, any>;
}

interface RoomMessage {
    roomId: string;
    clientId: string;
    userId?: string;
    messageId: string;
    content: string;
    timestamp: number;
    metadata?: Record<string, any>;
}

export class RoomManager extends EventEmitter {
    private static instance: RoomManager;
    private redis: Redis;
    private logger: Logger;
    private wsServer: WebSocketServerManager;
    private messageQueue: RoomMessage[] = [];
    private isProcessingQueue = false;

    private constructor(wsServer: WebSocketServerManager) {
        super();
        this.logger = new Logger('RoomManager');
        this.wsServer = wsServer;
        this.redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');

        this.setupMessageQueueProcessor();
    }

    public static getInstance(wsServer: WebSocketServerManager): RoomManager {
        if (!RoomManager.instance) {
            RoomManager.instance = new RoomManager(wsServer);
        }
        return RoomManager.instance;
    }

    private setupMessageQueueProcessor(): void {
        // Process message queue every 100ms
        setInterval(() => {
            if (this.messageQueue.length > 0 && !this.isProcessingQueue) {
                this.processMessageQueue();
            }
        }, 100);
    }

    private async processMessageQueue(): Promise<void> {
        if (this.isProcessingQueue) return;

        this.isProcessingQueue = true;
        const batchSize = 50;
        const messagesToProcess = this.messageQueue.splice(0, batchSize);

        try {
            // Group messages by room
            const messagesByRoom = new Map<string, RoomMessage[]>();

            for (const message of messagesToProcess) {
                if (!messagesByRoom.has(message.roomId)) {
                    messagesByRoom.set(message.roomId, []);
                }
                messagesByRoom.get(message.roomId)!.push(message);
            }

            // Send messages to each room
            for (const [roomId, messages] of messagesByRoom) {
                const memberClientIds = await this.getRoomMembers(roomId);

                for (const clientId of memberClientIds) {
                    try {
                        // Batch messages for each client
                        const batchedMessage = {
                            type: 'room_message_batch',
                            payload: {
                                roomId,
                                messages,
                                timestamp: Date.now()
                            }
                        };

                        await this.wsServer.sendToClient(clientId, batchedMessage);
                    } catch (error) {
                        this.logger.error(`Error sending batched messages to client ${clientId}: ${error instanceof Error ? error.message : String(error)}`);
                    }
                }
            }
        } finally {
            this.isProcessingQueue = false;
        }
    }

    public async createRoom(options: {
        id?: string;
        name: string;
        description?: string;
        createdBy?: string;
        metadata?: Record<string, any>;
    }): Promise<Room> {
        const roomId = options.id || `room:${Date.now()}:${Math.random().toString(36).substring(2, 9)}`;

        const room: Room = {
            id: roomId,
            name: options.name,
            description: options.description,
            createdAt: Date.now(),
            createdBy: options.createdBy,
            metadata: options.metadata,
            memberCount: 0
        };

        try {
            // Store room info
            await this.redis.hset(
                `room:${roomId}`,
                'id', roomId,
                'name', room.name,
                'description', room.description || '',
                'createdAt', room.createdAt.toString(),
                'createdBy', room.createdBy || '',
                'metadata', JSON.stringify(room.metadata || {})
            );

            // Create room index
            await this.redis.sadd('rooms', roomId);

            this.logger.info(`Created room: ${roomId} (${room.name})`);
            this.emit('room_created', room);

            return room;
        } catch (error) {
            this.logger.error(`Error creating room ${roomId}: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }

    public async getRoom(roomId: string): Promise<Room | null> {
        try {
            const roomData = await this.redis.hgetall(`room:${roomId}`);
            if (!roomData || Object.keys(roomData).length === 0) {
                return null;
            }

            const memberCount = await this.redis.scard(`room:${roomId}:members`);

            return {
                id: roomData.id,
                name: roomData.name,
                description: roomData.description || undefined,
                createdAt: parseInt(roomData.createdAt),
                createdBy: roomData.createdBy || undefined,
                metadata: roomData.metadata ? JSON.parse(roomData.metadata) : undefined,
                memberCount
            };
        } catch (error) {
            this.logger.error(`Error getting room ${roomId}: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }

    public async updateRoom(roomId: string, updates: {
        name?: string;
        description?: