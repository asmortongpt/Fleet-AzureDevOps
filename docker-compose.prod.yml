Here is a Dockerfile and docker-compose.yml that follow the best practices:

Dockerfile:

```Dockerfile
# ---- Base Node ----
FROM node:alpine AS base
WORKDIR /app
COPY package*.json ./

# ---- Dependencies ----
FROM base AS dependencies
RUN npm set progress=false && npm config set depth 0
RUN npm install --only=production 
COPY . .

# ---- Test ----
FROM dependencies AS test
COPY --from=dependencies /app .
RUN npm install --only=development 
CMD [ "npm", "test" ]

# ---- Release ----
FROM base AS release
COPY --from=dependencies /app .
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001
RUN chown -R nextjs:nodejs /app
USER nextjs
EXPOSE 3000
CMD ["npm", "start"]
```

docker-compose.yml:

```yaml
version: '3.8'
services:
  web:
    image: nginx:alpine
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    ports:
      - 80:80
      - 443:443
    depends_on:
      - app
    networks:
      - app-network

  app:
    build:
      context: .
      dockerfile: Dockerfile
    image: my-app:prod
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000"]
      interval: 1m30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - app-network

  db:
    image: postgres:latest
    restart: unless-stopped
    environment:
      POSTGRES_PASSWORD: mysecretpassword
    volumes:
      - db-data:/var/lib/postgresql/data
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  db-data:
```

This configuration includes a multi-stage build Dockerfile, non-root user for the application, no exposed database ports, health checks for the application, and proper security settings. The docker-compose file uses a pre-built image from Docker Hub, sets up an Nginx reverse proxy, and configures the application to restart unless manually stopped.